<!doctype html>

<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>REST API 使用详解 - LeanCloud 文档</title>
<!-- build:js custom/js/docs-all.js -->
<script src="custom/js/lib/jquery.min.js"></script>
<script src="custom/js/lib/bootstrap.min.js"></script>
<script src="custom/js/lib/bootstrap-hover-dropdown.js"></script>
<script src="custom/js/lib/pretty/prettify.js"></script>
<script src="custom/js/lib/jquery.scrollTo.min.js"></script>
<script src="custom/js/lib/angular/angular.min.js"></script>
<script src="custom/js/lib/zeroclipboard/zeroclipboard.js"></script>
<script src="custom/js/lib/markdown.min.js"></script>
<script src="custom/js/lib/md5.js"></script>

<script src="custom/js/lib/angular-gravatar.js"></script>
<script src="custom/js/prepare-dom.js"></script>
<script src="custom/js/app.js"></script>
<script src="custom/js/common.js"></script>
<script src="custom/js/demo.js"></script>
<script src="custom/js/weapp-domains.js"></script>
<!-- endbuild -->

<script type="text/javascript">
      var _vds = _vds || [];
      window._vds = _vds;
      (function(){
        _vds.push(['setAccountId', 'a268202b003f2516']);
        (function() {
          var vds = document.createElement('script');
          vds.type='text/javascript';
          vds.async = true;
          vds.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'dn-growing.qbox.me/vds.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(vds, s);
        })();
      })();
  </script>

<link rel="stylesheet" type="text/css" href="custom/css/app-docs.css?githubv1">


</head>


<body class="dashboard-init" data-offset="0" ng-cloak="" ng-controller="AppCtrl">




  <nav class="dashboard-subnav navbar navbar-default navbar-static-top" role="navigation">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#app-options" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand nav-logo font-logo" title="LeanCloud 官网">LeanCloud</a>
    </div>

    <div class="collapse navbar-collapse" id="app-options">
      <!-- <ul class="nav navbar-nav navbar-app-select">
        <li>
          <a href="/dashboard/applist.html" class="nav-logo font-logo" title="LeanCloud 控制台">LeanCloud</a>
        </li>
      </ul> -->
      <div class="navbar-app-actions-wrap">
        <ul class="nav navbar-nav navbar-app-actions">
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="index.html">
              <i class="icon icon-dashbd-icon icon-home"></i>
              <div class="name">文档首页</div>
            </a>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="sdk_down.html" title="SDK 下载">
              <i class="icon icon-dashbd-icon icon-package"></i>
              <div class="name"><span class="mobile-hide">SDK </span>下载</div>
            </a>
          </li>
          <li class="dropdown dropdown-toggle-app-name">
            <a href="demo.html" title="Demos">
              <i class="icon icon-dashbd-icon icon-magic"></i>
              <div class="name">Demos</div>
            </a>
          </li>
          <li class="dropdown dropdown-toggle-app-name">
            <a class="nav-key-6 dropdown-toggle" title="API Docs" data-toggle="dropdown">
              <i class="icon icon-dashbd-icon icon-log"></i>
              <div class="name">API 文档</div>
            </a>
            <ul class="dropdown-menu">
            <li><a href="/api-docs/android/index.html" target="_blank">Android SDK API</a></li>
<li><a href="/api-docs/iOS/index.html" target="_blank">Objective-C SDK API</a></li>
<li><a href="https://leancloud.github.io/javascript-sdk/docs/" target="_blank">JavaScript 数据存储 SDK API</a></li>
<li><a href="https://leancloud.github.io/js-realtime-sdk/docs/" target="_blank">JavaScript 实时通信 SDK API</a></li>
<li><a href="https://leancloud.readthedocs.io/">Python SDK API</a></li>
<li><a href="/api-docs/php/" target="_blank">PHP SDK API</a></li>
<li><a href="/api-docs/dotnet/Help/index.html">.NET SDK API</a></li>

            </ul>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="opencourse.html">
              <i class="icon icon-dashbd-icon icon-play"></i>
              <div class="name">公开课</div>
            </a>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a class="nav-key-6 dropdown-toggle" title="帮助" data-toggle="dropdown">
              <i class="icon icon-dashbd-icon icon-question"></i>
              <div class="name">帮助</div>
            </a>
            <ul class="dropdown-menu">
              <li><a href="https://leanticket.cn/t/leancloud">技术支持</a></li>
              <li><a href="http://forum.leancloud.cn">社区</a></li>
              <li><a href="http://blog.leancloud.cn/">Blog</a></li>
              <li role="presentation" class="divider"></li>
              <li><a href="/dashboard/apionline/index.html">在线 API 工具</a></li>
              <li role="presentation" class="divider"></li>
              <!-- <li><a href="/apps.html">LeanCloud App</a></li> -->
              <li><a href="/pricing">价格</a></li>
              <!-- <li><a href="#" data-toggle="modal" data-target="#modal-shortcuts">快捷键</a></li> -->
            </ul>
          </li>
        </ul>
        <!-- hide search input on the home page -->
        
          <form role="search" action="/search.html" method="get">
            <div class="app-search">
              <input name="q" type="text" class="form-control" placeholder="搜索文档&hellip;">
            </div>
          </form>
        
      </div>

      <ul class="nav navbar-nav navbar-user-actions navbar-right" ng-cloak="">

        <li class="dropdown" ng-show="user.username">
          <a role="button" class="dropdown-toggle user-name" data-toggle="dropdown">
            <span class="user-gravatar">
              <img gravatar-src="user.email" gravatar-size="64">
            </span>
            <span class="user-name-text">{{user.username}}</span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/settings.html">账号设置</a></li>
            <li><a href="/applist.html">控制台</a></li>
            
            <li><a href="/settings.html#/setting/team">团队管理</a></li>
            
            <li><a href="/bill.html#/bill/general">财务</a></li>
            <!-- <li><a href="settings.html#/setting/invite">邀请好友</a></li> -->
            <li ng-show="user.username" style=""><a ng-click="signout()">登出</a></li>
          </ul>
        </li>
        <li ng-hide="user.username">
          <a href="/login.html#/signin">登录</a>
        </li>
        <li ng-hide="user.username">
          <a href="/login.html#/signup">注册</a>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div>
  <!-- .container-fluid -->
</nav>



<header class="doc-subnav" role="banner">
  <div class="container-fluid">
    <nav class="" role="navigation">
      <ul class="nav navbar-nav">
        
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">功能概览</a>
          <ul class="dropdown-menu">
            <li><a href="storage_overview.html">数据存储服务总览</a></li>
            <li><a href="leanengine_overview.html">云引擎总览</a></li>
            <li><a href="push_guide.html">消息推送服务总览</a></li>
            <li><a href="realtime_v2.html">实时通信服务总览</a></li>
            <li><a href="dashboard_guide.html">控制台使用指南</a></li>
            <li><a href="data_security.html">数据安全</a></li>
            <li><a href="error_code.html">错误码详解</a></li>
            <li><a href="faq.html">常见问题</a></li>
            <li><a href="tool_tips.html">常见功能提示</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Objective-C</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-objc.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-objc.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-objc.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="ios_push_guide.html">消息推送开发指南</a></li>
            <li><a href="ios_push_cert.html">iOS 推送证书设置指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-objc.html">实时通信开发指南</a></li>
            <li><a href="chatkit-ios.html">ChatKit 使用指南</a></li>
            <li><a href="livekit-ios.html">LiveKit 使用指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            <li><a href="ios_statistics.html">统计分析开发指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="ios_crashreporting_guide.html">崩溃报告使用指南</a></li>
            <li><a href="ios-macos-faq.html">FAQ</a></li>
            <li><a href="/api-docs/iOS/index.html" target="_blank">SDK API</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Swift</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-swift.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-swift.html">数据存储开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Android</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-android.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-android.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-android.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="android_push_guide.html">消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-android.html">实时通信开发指南</a></li>
            <li><a href="chatkit-android.html">ChatKit 使用指南</a></li>
            <li><a href="livekit-android.html">LiveKit 使用指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            <li><a href="android_statistics.html">统计分析开发指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="android_faq.html">FAQ</a></li>
            <li><a href="/api-docs/android/index.html" target="_blank">SDK API</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">JavaScript</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-js.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-js.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-js.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="weapp.html">微信小程序开发指南</a></li>
            <li><a href="leanstorage_guide-js.html#Push_通知">消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-js.html">实时通信开发指南</a></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="js_analytics.html">统计分析开发指南</a></li>
            <!-- <li><a href="js_faq.html">FAQ</a></li> -->
            <li role="separator" class="divider"></li>
            <li><a href="https://leancloud.github.io/javascript-sdk/docs/" target="_blank">数据存储 SDK API</a></li>
            <li><a href="https://leancloud.github.io/js-realtime-sdk/docs/" target="_blank">实时通信 SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-node.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-node.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">.NET / Unity3D</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-dotnet.html">.NET SDK 安装指南</a></li>
            <li><a href="dotnet_guide.html">.NET 数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="analytics-guide.html">.NET 统计开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="unity_guide.html">Unity3D 数据存储开发指南</a></li>
            <li><a href="realtime-unity.html">Unity3D 实时通信开发指南</a></li>
            <li><a href="analytics-guide.html">Unity3D 统计开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="dotnet_push_guide.html">WP8.0 消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <!-- <li><a href="dotnet_faq.html">FAQ</a></li> -->
            <li><a href="/api-docs/dotnet/Help/index.html" target="_blank">.NET SDK API</a></li>
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Python</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-python.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-python.html">数据存储开发指南</a></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="im-servermgmt-guide-python.html">实时通讯服务端管理开发指南</a></li>
            <li><a href="https://leancloud.readthedocs.io/" target="_blank">SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-python.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-python.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">PHP</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-php.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-php.html">数据存储开发指南</a></li>
            <li><a href="/api-docs/php/" target="_blank">SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-php.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-php.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Java</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-java.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-java.html">数据存储开发指南</a></li>
            <li><a href="sms-guide.html">短信 SMS 服务使用指南</a></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-java.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-java.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">REST API</a>
          <ul class="dropdown-menu">
            <li><a href="rest_api.html">数据存储 API</a></li>
            <li><a href="leanengine-rest-api.html">云引擎 API</a></li>
            <li><a href="rest_api.html#Push_通知">消息推送 API</a></li>
            <li><a href="realtime_rest_api.html">实时通信 API</a></li>
            
            <li><a href="rest_sms_api.html">短信验证 API</a></li>
            
            <li><a href="rest_api.html#统计数据_API">数据统计 API</a></li>
            <li><a href="status_system.html#REST_API">应用内社交 API</a></li>
            <li><a href="app_search_guide.html#搜索_API">应用内搜索 API</a></li>
            <li><a href="cql_guide.html">CQL 查询语言详解</a></li>
            <!--<li><a href="oauth2_provider.html">开放平台接入</a></li>-->
            <!-- <li><a href="rest_faq.html">FAQ</a></li> -->
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">云引擎</a>
          <ul class="dropdown-menu">
          <li><a href="leanengine_overview.html">云引擎总览</a></li>
          <li><a href="leanengine_quickstart.html">云引擎快速入门</a></li>
          <li><a href="leanengine_plan.html">云引擎运行方案</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Node.js</li>
          <li><a href="leanengine_webhosting_guide-node.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-node.html">云函数开发指南</a></li>
          <li class="dropdown-header">Python</li>
          <li><a href="leanengine_webhosting_guide-python.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-python.html">云函数开发指南</a></li>
          <li class="dropdown-header">PHP</li>
          <li><a href="leanengine_webhosting_guide-php.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-php.html">云函数开发指南</a></li>
          <li class="dropdown-header">Java</li>
          <li><a href="leanengine_webhosting_guide-java.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-java.html">云函数开发指南</a></li>
          <li role="separator" class="divider"></li>
          <li><a href="leanengine_examples.html">云引擎项目示例</a></li>
          <li><a href="leanengine_cli.html">命令行工具 CLI</a></li>
          <li><a href="acl_guide_leanengine.html">在云引擎中管理 ACL</a></li>
          <li><a href="push-guide-leanengine.html">在云引擎中使用 Push 推送服务</a></li>
          <li><a href="leanengine_faq.html">FAQ</a></li>
          <li><a href="leancache_guide.html">LeanCache 使用指南</a></li>
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">更多</a>
          <ul class="dropdown-menu">
            
            <li><a href="status_system.html">应用内社交使用指南</a></li>
            <li><a href="sns.html">第三方平台账号登录 SNS 开发指南</a></li>
            <li><a href="feedback.html">用户反馈开发指南</a></li>
            
            <li><a href="app_search_guide.html">应用内搜索和 DeepLink 开发指南</a></li>
            <li><a href="app_data_share.html">应用之间数据共享（Class 绑定）</a></li>
            <!-- <li><a href="user_groups.html">用户群分析指南</a></li> -->
            
            <li><a href="leaninsight_guide.html">离线数据分析使用指南</a></li>
            
            <li class="divider"></li>
            <li><a href="kb-network-connectivity-diagnosis.html">网络连通性诊断流程</a></li>
            <li class="divider"></li>
            <li><a href="tutorials.html">教程</a></li>
           <li><a href="demo.html">Demo</a></li>
          </ul>
        </li>
      </ul>
      <!-- <ul class="nav navbar-nav navbar-right">
        <li>
          <form action="/search.html" method="get" target="_blank" class="search-form">
            <input name="q" class="search-input" placeholder="搜索&hellip;">
          </form>
        </li>
      </ul> -->
    </nav>
  </div>
</header>


<div class="container-fluid">

  <div class="row">

    <div class="sidebar-gruntfile-trigger  col-sm-3" id="left-nav">

      <div class="sidebar-affix-shadow sidebar-hover-off">

        <div class="sidebar-wrapper" id="toc-wrapper">

        </div>
        <!-- .sidebar-wrapper -->

      </div>
      <!-- .sidebar-affix-shadow -->

    </div>
    <!-- .col-md-3 -->

    <div class="col-sm-9 sidebar-gruntfile-trigger">
      <div class="doc-content with-comment" id="content">
        <div class="docs-meta">
          <span class="icon icon-github"></span><a href="https://github.com/leancloud/docs#贡献">编辑文档</a>
        <span class="doc-mdate" data-toggle="tooltip" title="2017年10月23日晚上11点29分">更新于 <time datetime="2017-10-23T23:29:16+08:00">2017-10-23</time></span></div>
        <h1 id="rest-api-">REST API 使用详解</h1>
<p>REST API 可以让你用任何支持发送 HTTP 请求的设备来与 LeanCloud 进行交互，你可以使用 REST API 做很多事情，比如：</p>
<ul>
<li>一个移动网站可以通过 JavaScript 来获取 LeanCloud 上的数据.</li>
<li>一个网站可以展示来自 LeanCloud 的数据。</li>
<li>你可以上传大量的数据，之后可以被一个移动 App 读取。</li>
<li>你可以下载最近的数据来进行你自定义的分析统计。</li>
<li>使用任何语言写的程序都可以操作 LeanCloud 上的数据。</li>
<li>如果你不再需要使用 LeanCloud，你可以导出你所有的数据。</li>
</ul>
<h2 id="api-">API 版本</h2>
<table>
<thead>
<tr>
<th>版本</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.1</td>
<td>2014 年 8 月 13 号发布，修复 Date 类型和 createdAt、updatedAt 的时区问题，返回标准 UTC 时间。</td>
</tr>
<tr>
<td>1.0</td>
<td>存在时间不准确的 Bug，实际返回的 Date 类型和 createdAt、updatedAt 都是北京时间。<strong>不推荐再使用</strong>。</td>
</tr>
</tbody>
</table>
<h3 id="-">在线测试</h3>
<p><a href="/dashboard/apionline/index.html">API 在线测试工具</a>，目前仅支持调试<strong>中国节点</strong>下的应用。</p>
<h3 id="-">对象</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/classes/&lt;className&gt;</td>
      <td>POST</td>
      <td>创建对象</td>
    </tr>
    <tr>
      <td>/1.1/classes/&lt;className&gt;/&lt;objectId&gt;</td>
      <td>GET</td>
      <td>获取对象</td>
    </tr>
    <tr>
      <td>/1.1/classes/&lt;className&gt;/&lt;objectId&gt;</td>
      <td>PUT</td>
      <td>更新对象</td>
    </tr>
    <tr>
      <td>/1.1/classes/&lt;className&gt;</td>
      <td>GET</td>
      <td>查询对象</td>
    </tr>
    <tr>
      <td>/1.1/cloudQuery</td>
      <td>GET</td>
      <td>使用 CQL 查询对象</td>
    </tr>
    <tr>
      <td>/1.1/classes/&lt;className&gt;/&lt;objectId&gt;</td>
      <td>DELETE</td>
      <td>删除对象</td>
    </tr>
    <tr>
      <td>/1.1/scan/classes/&lt;className&gt;</td>
      <td>GET</td>
      <td>按照特定顺序遍历 Class</td>
    </tr>
  </tbody>
</table>

<h3 id="-">用户</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/users</td>
      <td>POST</td>
      <td>用户注册<br>用户连接</td>
    </tr>
    <tr>
      <td>/1.1/usersByMobilePhone</td>
      <td>POST</td>
      <td>使用手机号码注册或登录</td>
    </tr>
    <tr>
      <td>/1.1/login</td>
      <td>POST</td>
      <td>用户登录</td>
    </tr>
    <tr>
      <td>/1.1/users/&lt;objectId&gt;</td>
      <td>GET</td>
      <td>获取用户</td>
    </tr>
    <tr>
      <td>/1.1/users/me</td>
      <td>GET</td>
      <td>根据 <a href="leanstorage_guide-js.html#SessionToken">sessionToken</a> 获取用户信息</td>
    </tr>
    <tr>
      <td>/1.1/users/&lt;objectId&gt;/refreshSessionToken</td>
      <td>PUT</td>
      <td>重置用户 sessionToken。</td>
    </tr>
    <tr>
      <td>/1.1/users/&lt;objectId&gt;/updatePassword</td>
      <td>PUT</td>
      <td>更新密码，要求输入旧密码。</td>
    </tr>
    <tr>
      <td>/1.1/users/&lt;objectId&gt;</td>
      <td>PUT</td>
      <td>更新用户<br>用户连接<br>验证Email</td>
    </tr>
    <tr>
      <td>/1.1/users</td>
      <td>GET</td>
      <td>查询用户</td>
    </tr>
    <tr>
      <td>/1.1/users/&lt;objectId&gt;</td>
      <td>DELETE</td>
      <td>删除用户</td>
    </tr>
    <tr>
      <td>/1.1/requestPasswordReset</td>
      <td>POST</td>
      <td>请求密码重设</td>
    </tr>
    <tr>
      <td>/1.1/requestEmailVerify</td>
      <td>POST</td>
      <td>请求验证用户邮箱</td>
    </tr>

    <tr>
      <td>/1.1/requestMobilePhoneVerify</td>
      <td>POST</td>
      <td>请求发送用户手机号码验证短信</td>
    </tr>
    <tr>
      <td>/1.1/verifyMobilePhone/&lt;code&gt;</td>
      <td>POST</td>
      <td>使用&quot;验证码&quot;验证用户手机号码</td>
    </tr>
    <tr>
      <td>/1.1/requestLoginSmsCode</td>
      <td>POST</td>
      <td>请求发送手机号码登录短信。</td>
    </tr>
    <tr>
      <td>/1.1/requestPasswordResetBySmsCode</td>
      <td>POST</td>
      <td>请求发送手机短信验证码重置用户密码。</td>
    </tr>
    <tr>
      <td>/1.1/resetPasswordBySmsCode/&lt;code&gt;</td>
      <td>PUT</td>
      <td>验证手机短信验证码并重置密码。</td>
    </tr>

  </tbody>
</table>

<h3 id="-">角色</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/roles</td>
      <td>POST</td>
      <td>创建角色</td>
    </tr>
    <tr>
      <td>/1.1/roles/&lt;objectId&gt;</td>
      <td>GET</td>
      <td>获取角色</td>
    </tr>
    <tr>
      <td>/1.1/roles/&lt;objectId&gt;</td>
      <td>PUT</td>
      <td>更新角色</td>
    </tr>
    <tr>
      <td>/1.1/roles</td>
      <td>GET</td>
      <td>查询角色</td>
    </tr>
    <tr>
      <td>/1.1/roles/&lt;objectId&gt;</td>
      <td>DELETE</td>
      <td>删除角色</td>
    </tr>
  </tbody>
</table>


<h3 id="-">推送通知</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/push</td>
      <td>POST</td>
      <td>推送通知</td>
    </tr>
  </tbody>
</table>

<h3 id="-">安装数据</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/installations</td>
      <td>POST</td>
      <td>上传安装数据</td>
    </tr>
    <tr>
      <td>/1.1/installations/&lt;objectId&gt;</td>
      <td>GET</td>
      <td>获取安装数据</td>
    </tr>
    <tr>
      <td>/1.1/installations/&lt;objectId&gt;</td>
      <td>PUT</td>
      <td>更新安装数据</td>
    </tr>
    <tr>
      <td>/1.1/installations</td>
      <td>GET</td>
      <td>查询安装数据</td>
    </tr>
    <tr>
      <td>/1.1/installations/&lt;objectId&gt;</td>
      <td>DELETE</td>
      <td>删除安装数据</td>
    </tr>
  </tbody>
</table>

<h3 id="-schema">数据 Schema</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/schemas</td>
      <td>GET</td>
      <td>获取应用的所有 Class 的 Schema</td>
    </tr>
    <tr>
      <td>/1.1/schemas/&lt;className&gt;</td>
      <td>POST</td>
      <td>获取应用指定的 Class 的 Schema</td>
    </tr>
  </tbody>
</table>

<h3 id="-">云函数</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/functions</td>
      <td>POST</td>
      <td>调用云函数</td>
    </tr>
    <tr>
      <td>/1.1/call</td>
      <td>POST</td>
      <td>调用云函数，支持 AVObject 作为参数和结果</td>
    </tr>
  </tbody>
</table>

<h3 id="-">用户反馈组件</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/feedback</td>
      <td>POST</td>
      <td>提交新的用户反馈</td>
    </tr>
  </tbody>
</table>

<!--
### 短信验证 API

<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/requestSmsCode</td>
      <td>POST</td>
      <td>请求发送短信验证码</td>
    </tr>
        <tr>
      <td>/1.1/verifySmsCode/&lt;code&gt;</td>
      <td>POST</td>
      <td>验证短信验证码</td>
    </tr>
  </tbody>
</table>
-->
<h3 id="-">统计数据查询</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/stats/appinfo</td>
      <td>GET</td>
      <td>获取应用的基本信息</td>
    </tr>
    <tr>
      <td>/1.1/stats/appmetrics</td>
      <td>GET</td>
      <td>获取应用的具体统计数据</td>
    </tr>
  </tbody>
</table>

<h3 id="-">实时通信</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/rtm/messages/logs</td>
      <td>GET</td>
      <td>获得应用聊天记录</td>
    </tr>
    <tr>
      <td>/1.1/rtm/messages</td>
      <td>POST</td>
      <td>通过 API 向用户发消息</td>
    </tr>
    <tr>
      <td>/1.1/rtm/transient_group/onlines</td>
      <td>GET</td>
      <td>获取暂态对话（聊天室）的在线人数</td>
    </tr>
  </tbody>
</table>

<h3 id="-api">其他 API</h3>
<table>
  <thead>
    <tr>
      <th>URL</th>
      <th>HTTP</th>
      <th>功能</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>/1.1/date</td>
      <td>GET</td>
      <td>获得服务端当前时间</td>
    </tr>
    <tr>
      <td>/1.1/exportData</td>
      <td>POST</td>
      <td>请求导出应用数据</td>
    </tr>
    <tr>
      <td>/1.1/exportData/&lt;id&gt;</td>
      <td>GET</td>
      <td>获取导出数据任务状态和结果</td>
    </tr>
  </tbody>
</table>

<h3 id="-">请求格式</h3>
<p>对于 POST 和 PUT 请求，请求的主体必须是 JSON 格式，而且 HTTP header 的 Content-Type 需要设置为 <code>application/json</code>。</p>
<p>用户验证通过 HTTP header 来进行，<strong>X-LC-Id</strong> 标明正在运行的是哪个应用，<strong>X-LC-Key</strong> 用来授权鉴定 endpoint：</p>
<pre><code>curl -X PUT \
  -H &quot;X-LC-Id: FFnN2hso42Wego3pWq4X5qlu&quot; \
  -H &quot;X-LC-Key: UtOCzqb67d3sN12Kts4URwy8&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;content&quot;: &quot;更新一篇博客的内容&quot;}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre><p>对于 JavaScript 使用，LeanCloud 支持跨域资源共享，所以你可以将这些 header 同 XMLHttpRequest 一同使用。</p>
<h4 id="-">更安全的鉴权方式</h4>
<p>我们还支持一种新的 API 鉴权方式，即在 HTTP header 中使用 <strong>X-LC-Sign</strong> 来代替 <strong>X-LC-Key</strong>，以降低 App Key 的泄露风险。例如：</p>
<pre><code>curl -X PUT \
  -H &quot;X-LC-Id: FFnN2hso42Wego3pWq4X5qlu&quot; \
  -H &quot;X-LC-Sign: d5bcbb897e19b2f6633c716dfdfaf9be,1453014943466&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;content&quot;: &quot;在 HTTP header 中使用 X-LC-Sign 来更新一篇博客的内容&quot;}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre><p><strong>X-LC-Sign</strong> 的值是由 <code>sign,timestamp[,master]</code> 组成的字符串：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>约束</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>sign</td>
<td>必须</td>
<td>将 timestamp 加上 App Key 或 Master Key 组成的字符串，再对它做 MD5 签名后的结果。</td>
</tr>
<tr>
<td>timestamp</td>
<td>必须</td>
<td>客户端产生本次请求的 unix 时间戳（UTC），精确到<strong>毫秒</strong>。</td>
</tr>
<tr>
<td>master</td>
<td>可选</td>
<td>字符串 <code>&quot;master&quot;</code>，当使用 master key 签名请求的时候，必须加上这个后缀明确说明是使用 master key。</td>
</tr>
</tbody>
</table>
<p>举例来说，假设应用的信息如下：</p>
<table class="noheading">
  <tbody>
    <tr>
      <td scope="row">App Id</td>
      <td><code>FFnN2hso42Wego3pWq4X5qlu</code></td>
    </tr>
    <tr>
      <td scope="row">App Key</td>
      <td><code>UtOCzqb67d3sN12Kts4URwy8</code></td>
    </tr>
    <tr>
      <td scope="row">Master Key</td>
      <td><code>DyJegPlemooo4X1tg94gQkw1</code></td>
    </tr>
    <tr>
      <td scope="row">请求时间</td>
      <td>2016-01-17 15:15:43.466</td>
    </tr>
    <tr>
      <td scope="row">timestamp</td>
      <td><code>1453014943466</code></td>
    </tr>
  </tbody>
</table>

<p><strong>使用 App Key 来计算 sign</strong>：</p>
<blockquote>
<p>md5( timestamp + App Key ) <br>
= md5( <code><u>1453014943466</u>UtOCzqb67d3sN12Kts4URwy8</code> )<br>= d5bcbb897e19b2f6633c716dfdfaf9be</p>
</blockquote>
<pre><code class="lang-sh">  -H &quot;X-LC-Sign: d5bcbb897e19b2f6633c716dfdfaf9be,1453014943466&quot; \
</code></pre>
<p><strong>使用 Master Key 来计算 sign</strong>：</p>
<blockquote>
<p>md5( timestamp + Master Key )<br>
= md5( <code><u>1453014943466</u>DyJegPlemooo4X1tg94gQkw1</code> ) <br>
= e074720658078c898aa0d4b1b82bdf4b</p>
</blockquote>
<pre><code class="lang-sh">  -H &quot;X-LC-Sign: e074720658078c898aa0d4b1b82bdf4b,1453014943466,master&quot; \
</code></pre>
<p>（最后加上 <strong>master</strong> 来告诉服务器这个签名是使用 master key 生成的。）</p>
<div class="callout callout-danger">使用 master key 将绕过所有权限校验，应该确保只在可控环境中使用，比如自行开发的管理平台，并且要完全避免泄露。因此，以上两种计算 sign 的方法可以根据实际情况来选择一种使用。</div>

<h3 id="-">响应格式</h3>
<p>对于所有的请求，响应格式都是一个 JSON 对象。</p>
<p>一个请求是否成功是由 HTTP 状态码标明的。一个 2XX 的状态码表示成功，而一个 4XX 表示请求失败。当一个请求失败时响应的主体仍然是一个 JSON 对象，但是总是会包含 <code>code</code> 和 <code>error</code> 这两个字段，你可以用它们来进行调试。举个例子，如果尝试用非法的属性名来保存一个对象会得到如下信息：</p>
<pre><code class="lang-json">{
  &quot;code&quot;: 105,
  &quot;error&quot;: &quot;invalid field name: bl!ng&quot;
}
</code></pre>
<p>错误代码请看 <a href="./error_code.html">错误代码详解</a>。</p>
<h2 id="-">对象</h2>
<h3 id="-">对象格式</h3>
<p>LeanCloud 的数据存储服务是建立在 AVObject（对象）基础上的，每个 AVObject 包含若干属性值对（key-value，也称「键值对」），属性的值是与 JSON 格式兼容的数据。
通过 REST API 保存对象需要将对象的数据通过 JSON 来编码。这个数据是无模式化的（Schema Free），这意味着你不需要提前标注每个对象上有哪些 key，你只需要随意设置 key-value 对就可以，后端会保存它。</p>
<p>举个例子，假如我们要实现一个类似于微博的社交 App，主要有三类数据：账户、帖子、评论，一条微博帖子可能包含下面几个属性：</p>
<pre><code class="lang-json">{
  &quot;content&quot;: &quot;每个 Java 程序员必备的 8 个开发工具&quot;,
  &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,
  &quot;pubTimestamp&quot;: 1435541999
}
</code></pre>
<p>Key（属性名）必须是字母和数字组成的字符串，Value（属性值）可以是任何可以 JSON 编码的数据。</p>
<p>每个对象都有一个类名，你可以通过类名来区分不同的数据。例如，我们可以把微博的帖子对象称之为 Post。我们建议将类和属性名分别按照 <code>NameYourClassesLikeThis</code> 和 <code>nameYourKeysLikeThis</code> 这样的惯例来命名，即区分第一个字母的大小写，这样可以提高代码的可读性和可维护性。</p>
<p>当你从 LeanCloud 中获取对象时，一些字段会被自动加上，如 createdAt、updatedAt 和 objectId。这些字段的名字是保留的，值也不允许修改。我们上面设置的对象在获取时应该是下面的样子：</p>
<pre><code class="lang-json">{
  &quot;content&quot;: &quot;每个 Java 程序员必备的 8 个开发工具&quot;,
  &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,
  &quot;pubTimestamp&quot;: 1435541999,
  &quot;createdAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
  &quot;updatedAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
  &quot;objectId&quot;: &quot;558e20cbe4b060308e3eb36c&quot;
}
</code></pre>
<p>createdAt 和 updatedAt 都是 UTC 时间戳，以 ISO 8601 标准和毫秒级精度储存：<code>YYYY-MM-DDTHH:MM:SS.MMMZ</code>。objectId 是一个字符串，在类中可以唯一标识一个实例。
在 REST API 中，class 级的操作都是通过一个带类名的资源路径（URL）来标识的。例如，如果类名是 Post，那么 class 的 URL 就是：</p>
<pre><code>https://{{v2Domain}}/1.1/classes/Post
</code></pre><p>对于<strong>用户账户</strong>这种对象，有一个特殊的 URL：</p>
<pre><code>https://{{v2Domain}}/1.1/users
</code></pre><p>针对于一个特定的对象的操作可以通过组织一个 URL 来做。例如，对 Post 中的一个 objectId 为 <code>558e20cbe4b060308e3eb36c</code> 的对象的操作应使用如下 URL：</p>
<pre><code>https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre><h3 id="-">创建对象</h3>
<p>为了在 LeanCloud 上创建一个新的对象，应该向 class 的 URL 发送一个 <strong>POST</strong> 请求，其中应该包含对象本身。<span class="callout-danger" style="background-color: transparent;">class 的名称必须以字母开头，只能包含字母、数字和下划线。</span>例如，要创建如上所说的对象：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;content&quot;: &quot;每个 Java 程序员必备的 8 个开发工具&quot;,&quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,&quot;pubTimestamp&quot;: 1435541999}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>当创建成功时，HTTP 的返回是 <strong>201 Created</strong>，而 header 中的 Location 表示新的 object 的 URL：</p>
<pre><code class="lang-sh">Status: 201 Created
Location: https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<p>响应的主体是一个 JSON 对象，包含新的对象的 objectId 和 createdAt 时间戳。</p>
<pre><code class="lang-json">{
  &quot;createdAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
  &quot;objectId&quot;: &quot;558e20cbe4b060308e3eb36c&quot;
}
</code></pre>
<p>如果希望返回新创建的对象的完整信息，可以在 URL 里加上 <code>fetchWhenSave</code> 选项，并且设置为 true：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;content&quot;: &quot;每个 Java 程序员必备的 8 个开发工具&quot;,&quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,&quot;pubTimestamp&quot;: 1435541999}&#39; \
  https://{{v2Domain}}/1.1/classes/Post?fetchWhenSave=true
</code></pre>
<p>fetchWhenSave 选项对更新对象也同样有效，但是它仅返回已被更新的字段，而非全部字段。</p>
  <div class="callout callout-info">
  <p><strong>每个应用最多可以创建 500 个 class</strong>，但每个 class 中的记录数量没有限制。</p>
</div>


<h3 id="-">获取对象</h3>
<p>当你创建了一个对象时，你可以通过发送一个 GET 请求到返回的 header 的 Location 以获取它的内容。例如，为了得到我们上面创建的对象：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<p>返回的主体是一个 JSON 对象包含所有用户提供的 field 加上 createdAt、updatedAt 和 objectId 字段：</p>
<pre><code class="lang-json">{
  &quot;content&quot;: &quot;每个 Java 程序员必备的 8 个开发工具&quot;,
  &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,
  &quot;pubTimestamp&quot;: 1435541999,
  &quot;createdAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
  &quot;updatedAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
  &quot;objectId&quot;: &quot;558e20cbe4b060308e3eb36c&quot;
}
</code></pre>
<p>当获取的对象有指向其子对象的指针时，你可以加入 <code>include</code> 选项来获取这些子对象。假设微博记录中有一个字段 <code>author</code> 来指向发布者的账户信息，按上面的例子，可以这样来连带获取发布者完整信息：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;include=author&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<h3 id="-">更新对象</h3>
<p>为了更改一个对象已经有的数据，你可以发送一个 PUT 请求到对象相应的 URL 上，任何你未指定的 key 都不会更改，所以你可以只更新对象数据的一个子集。例如，我们来更改我们对象的一个 content 字段：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;content&quot;: &quot;每个 JavaScript 程序员必备的 8 个开发工具: http://buzzorange.com/techorange/2015/03/03/9-javascript-ide-editor/&quot;}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<p>返回的 JSON 对象只会包含一个 updatedAt 字段，表明更新发生的时间：</p>
<pre><code class="lang-json">{
  &quot;updatedAt&quot;: &quot;2015-06-30T18:02:52.248Z&quot;
}
</code></pre>
<h4 id="-">计数器</h4>
<p>比如一条微博，我们需要记录有多少人喜欢或者转发了它，但可能很多次喜欢都是同时发生的，如果每个客户端都直接把读到的计数值更改之后再写回去，那么极容易引发冲突和覆盖，导致最终结果不准。LeanCloud 提供了对数字类型字段进行原子增加或者减少的功能，稳妥地实现对计数器类型数据的更新：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;upvotes&quot;:{&quot;__op&quot;:&quot;Increment&quot;,&quot;amount&quot;:1}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<p>这样就将对象的 <strong>upvotes</strong> 属性值（被用户点赞的次数）加上 1，其中 <strong>amount</strong> 为递增的数字大小，如果为负数，则为递减。</p>
<p>除了 Increment，我们也提供了 Decrement 用于递减，等价于 Increment 一个负数。</p>
<h4 id="-">位运算</h4>
<p>如果数据表的某一列是整型，可以使用位运算操作符该列进行原子的位运算：</p>
<ul>
<li>BitAnd 与运算</li>
<li>BitOr 或运算</li>
<li>BitXor 异或运算</li>
</ul>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;flags&quot;:{&quot;__op&quot;:&quot;BitOr&quot;,&quot;value&quot;: 0x0000000000000004}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<h4 id="-">数组</h4>
<p>LeanCloud 提供 3 种原子性操作来存储和更改数组类型的字段：</p>
<ul>
<li><strong>Add</strong>：在一个数组字段的后面添加一些指定的对象（包装在一个数组内）</li>
<li><strong>AddUnique</strong>：只会在数组内原本没有这个对象的情形下才会添加入数组，插入的位置不定。</li>
<li><strong>Remove</strong>：从一个数组内移除所有的指定的对象</li>
</ul>
<p>每种操作都有一个 key <code>objects</code>，其值为被添加或删除的对象列表。例如为每条微博增加一个「标签」属性 tags，然后往里面加入一些值：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;tags&quot;:{&quot;__op&quot;:&quot;AddUnique&quot;,&quot;objects&quot;:[&quot;Frontend&quot;,&quot;JavaScript&quot;]}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<h4 id="-">按条件更新对象</h4>
<p>假设从某个账户对象 Account 的余额中扣除一定金额，但是要求余额要大于等于被扣除的金额才允许操作，那么就需要通过 <code>where</code> 参数为更新操作加上限定条件 <code>balance &gt;= amount</code>：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;balance&quot;:{&quot;__op&quot;:&quot;Decrement&quot;,&quot;amount&quot;: 30}}&#39; \
  &quot;https://{{v2Domain}}/1.1/classes/Account/558e20cbe4b060308e3eb36c?where=%7B%22balance%22%3A%7B%22%24gte%22%3A%2030%7D%7D&quot;
</code></pre>
<p>URL 中 where 参数的值是 <code>%7B%22balance%22%3A%7B%22%24gte%22%3A%2030%7D%7D</code>，其实这是 <code>{&quot;balance&quot;:{&quot;$gte&quot;: 30}}</code> 被 URL 编码后的结果。更多 where 查询的例子请参考 <a href="#查询">查询</a>。</p>
<p>如果条件不满足，更新将失败，同时返回错误码 <code>305</code>：</p>
<pre><code class="lang-json">{
  &quot;code&quot; : 305,
  &quot;error&quot;: &quot;No effect on updating/deleting a document.&quot;
}
</code></pre>
<p><strong>特别强调：where 一定要作为 URL 的 Query Parameters 传入。</strong></p>
<h4 id="__op-">__op 操作汇总</h4>
<p>使用 <code>__op(&quot;操作名称&quot;, {JSON 参数})</code> 函数可以完成原子性操作，确保数据的一致性。  </p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Delete</td>
<td>删除对象的一个属性</td>
<td><code>__op(&#39;Delete&#39;, {})</code></td>
</tr>
<tr>
<td>Add</td>
<td>在数组末尾添加对象</td>
<td><code>__op(&#39;Add&#39;,{&#39;objects&#39;:[&#39;Apple&#39;,&#39;Google&#39;]})</code></td>
</tr>
<tr>
<td>AddUnique</td>
<td>在数组末尾添加不会重复的对象，插入位置不定。</td>
<td><code>__op(&#39;AddUnique&#39;, {&#39;objects&#39;:[&#39;Apple&#39;,&#39;Google&#39;]})</code></td>
</tr>
<tr>
<td>Remove</td>
<td>从数组中删除对象</td>
<td><code>__op(&#39;Remove&#39;,{&#39;objects&#39;:[&#39;Apple&#39;,&#39;Google&#39;]})</code></td>
</tr>
<tr>
<td>AddRelation</td>
<td>添加一个关系</td>
<td><code>__op(&#39;AddRelation&#39;, {&#39;objects&#39;:[pointer(&#39;_User&#39;,&#39;558e20cbe4b060308e3eb36c&#39;)]})</code></td>
</tr>
<tr>
<td>RemoveRelation</td>
<td>删除一个关系</td>
<td><code>__op(&#39;RemoveRelation&#39;, {&#39;objects&#39;:[pointer(&#39;_User&#39;,&#39;558e20cbe4b060308e3eb36c&#39;)]})</code></td>
</tr>
<tr>
<td>Increment</td>
<td>递增</td>
<td><code>__op(&#39;Increment&#39;, {&#39;amount&#39;: 50})</code></td>
</tr>
<tr>
<td>Decrement</td>
<td>递减</td>
<td><code>__op(&#39;Decrement&#39;, {&#39;amount&#39;: 50})</code></td>
</tr>
<tr>
<td>BitAnd</td>
<td>与运算</td>
<td><code>__op(&#39;BitAnd&#39;, {&#39;value&#39;: 0x0000000000000004})</code></td>
</tr>
<tr>
<td>BitOr</td>
<td>或运算</td>
<td><code>__op(&#39;BitOr&#39;, {&#39;value&#39;: 0x0000000000000004})</code></td>
</tr>
<tr>
<td>BitXor</td>
<td>异或运算</td>
<td><code>__op(&#39;BitXor&#39;, {&#39;value&#39;: 0x0000000000000004})</code></td>
</tr>
</tbody>
</table>
<h3 id="-">删除对象</h3>
<p>为了在 LeanCloud 上删除一个对象，可以发送一个 DELETE 请求到指定的对象的 URL，比如：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<p>还可以使用 Delete 操作删除一个对象的一个字段（注意此时<strong> HTTP Method 还是 PUT</strong>）：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;downvotes&quot;:{&quot;__op&quot;:&quot;Delete&quot;}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre>
<h4 id="-">按条件删除对象</h4>
<p>为请求增加 <code>where</code> 参数即可以按指定的条件来删除对象。例如删除点击量 clicks 为 0 的帖子：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  &quot;https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c?where=%7B%22clicks%22%3A%200%7D&quot;
</code></pre>
<p>URL 中 where 参数的值是 <code>%7B%22clicks%22%3A%200%7D</code>，其实这是 <code>{&quot;clicks&quot;: 0}</code> 被 URL 编码后的结果。更多 where 查询的例子请参考 <a href="#查询">查询</a>。</p>
<p>如果条件不满足，删除将失败，同时返回错误码 <code>305</code>：</p>
<pre><code class="lang-json">{
  &quot;code&quot; : 305,
  &quot;error&quot;: &quot;No effect on updating/deleting a document.&quot;
}
</code></pre>
<p><strong>特别强调：where 一定要作为 URL 的 Query Parameters 传入。</strong></p>
<h3 id="-class">遍历 Class</h3>
<p>因为更新和删除都是基于单个对象的，都要求提供 objectId，但是有时候用户需要高效地遍历一个 Class，做一些批量的更新或者删除的操作。</p>
<p>通常情况下，如果 Class 的数量规模不大，使用查询加上 <code>skip</code> 和 <code>limit</code> 分页配合排序 <code>order</code> 就可以遍历所有数据。但是当 Class 数量规模比较大的时候， <code>skip</code> 的效率就非常低了（这跟 MySQL 等关系数据库的原因一样，深度翻页比较慢），因此我们提供了 <code>scan</code> 协议，可以按照特定字段排序来高效地遍历一张表，默认这个字段是 <code>objectId</code> 升序，同时支持设置 <code>limit</code>  限定每一批次的返回数量，默认 limit 为 100，最大可设置为 1000：</p>
<pre><code class="lang-sh">curl -X GET \
   -H &quot;X-LC-Id: {{appid}}&quot; \
   -H &quot;X-LC-Key: {{masterkey}},master&quot; \
   -G \
   --data-urlencode &#39;limit=10&#39; \
   https://{{v2Domain}}/1.1/scan/classes/Article
</code></pre>
<p><code>scan</code> 强制要求使用 master key。</p>
<p>返回：</p>
<pre><code class="lang-json">{
  &quot;results&quot;:
   [
      {
        &quot;tags&quot;     :  [&quot;clojure&quot;,&quot;\u7b97\u6cd5&quot;],
        &quot;createdAt&quot;:  &quot;2016-07-07T08:54:13.250Z&quot;,
        &quot;updatedAt&quot;:  &quot;2016-07-07T08:54:50.268Z&quot;,
        &quot;title&quot;    :  &quot;clojure persistent vector&quot;,
        &quot;objectId&quot; :  &quot;577e18b50a2b580057469a5e&quot;
       },
       ...
    ],
    &quot;cursor&quot;: &quot;pQRhIrac3AEpLzCA&quot;}
</code></pre>
<p>其中 <code>results</code> 对应的就是返回的对象列表，而 <code>cursor</code> 表示本次遍历当前位置的「指针」，当 <code>cursor</code> 为 null 的时候，表示已经遍历完成，如果不为 null，请继续传入 <code>cursor</code> 到 <code>scan</code> 接口就可以从上次到达的位置继续往后查找：</p>
<pre><code class="lang-sh">curl -X GET \
   -H &quot;X-LC-Id: {{appid}}&quot; \
   -H &quot;X-LC-Key: {{masterkey}},master&quot; \
   -G \
   --data-urlencode &#39;limit=10&#39; \
   --data-urlencode &#39;cursor=pQRhIrac3AEpLzCA&#39; \
   https://{{v2Domain}}/1.1/scan/classes/Article
</code></pre>
<p>每次返回的 <code>cursor</code> 的有效期是 10 分钟。</p>
<p>遍历还支持过滤条件，加入 where 参数：</p>
<pre><code class="lang-sh">curl -X GET \
   -H &quot;X-LC-Id: {{appid}}&quot; \
   -H &quot;X-LC-Key: {{masterkey}},master&quot; \
   -G \
   --data-urlencode &#39;limit=10&#39; \
   --data-urlencode &#39;where={&quot;score&quot;: 100}&#39; \
   https://{{v2Domain}}/1.1/scan/classes/Article
</code></pre>
<p>默认情况下系统按 <code>objectId</code> 升序排序，增加 <code>scan_key</code> 参数可以使用其他字段来排序：</p>
<pre><code class="lang-sh">curl -X GET \
   -H &quot;X-LC-Id: {{appid}}&quot; \
   -H &quot;X-LC-Key: {{masterkey}},master&quot; \
   -G \
   --data-urlencode &#39;limit=10&#39; \
   --data-urlencode &#39;scan_key=score&#39; \
   https://{{v2Domain}}/1.1/scan/classes/Article
</code></pre>
<p>scan_key 也支持倒序，前面加个减号即可，例如 <code>-score</code>。</p>
<p><strong>自定义的 scan_key 需要满足严格单调递增的条件，并且 scan_key 不可作为 where 查询条件存在。</strong></p>
<h3 id="-">批量操作</h3>
<p>为了减少网络交互的次数太多带来的时间浪费，你可以在一个请求中对多个对象进行 create、update、delete 操作。</p>
<p>在一个批次中每一个操作都有相应的方法、路径和主体，这些参数可以代替你通常会使用的 HTTP 方法。这些操作会以发送过去的顺序来执行，比如我们要一次发布一系列的微博：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;requests&quot;: [
          {
            &quot;method&quot;: &quot;POST&quot;,
            &quot;path&quot;: &quot;/1.1/classes/Post&quot;,
            &quot;body&quot;: {
              &quot;content&quot;: &quot;近期 LeanCloud 的文档已经支持评论功能，如果您有疑问、意见或是其他想法，都可以直接在我们文档中提出。&quot;,
              &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;
            }
          },
          {
            &quot;method&quot;: &quot;POST&quot;,
            &quot;path&quot;: &quot;/1.1/classes/Post&quot;,
            &quot;body&quot;: {
              &quot;content&quot;: &quot;很多用户表示很喜欢我们的文档风格，我们已将 LeanCloud 所有文档的 Markdown 格式的源码开放出来。&quot;,
              &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;
            }
          }
        ]
      }&#39; \
  https://{{v2Domain}}/1.1/batch
</code></pre>
<p>我们对每一批次中所包含的操作数量（requests 数组中的元素个数）暂不设限，但考虑到云端对每次请求的 body 内容大小有 20 MB 的限制，因此建议将每一批次的操作数量控制在 100 以内。</p>
<p>批量操作的响应 body 会是一个列表，列表的元素数量和顺序与给定的操作请求是一致的。每一个在列表中的元素都有一个字段是 success 或者 error。</p>
<pre><code>[
  {
    &quot;error&quot;: {
      &quot;code&quot;: 1,
      &quot;error&quot;: &quot;Could not find object by id &#39;558e20cbe4b060308e3eb36c&#39; for class &#39;Post&#39;.&quot;
    }
  },
  {
    &quot;success&quot;: {
      &quot;updatedAt&quot;: &quot;2017-02-22T06:35:29.419Z&quot;,
      &quot;objectId&quot;: &quot;58ad2e850ce463006b217888&quot;
    }
  }
]
</code></pre><p>需要注意，即使一个 batch 请求返回的响应码为 200，这仅代表服务端已收到并处理了这个请求，但并不说明该 
batch 中的所有操作都成功完成，只有当返回 body 的列表中<strong>不存在 error 元素</strong>，开发者才可以认为所有操作都已成功完成。</p>
<p>在 batch 操作中 update 和 delete 同样是有效的：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;requests&quot;: [
          {
            &quot;method&quot;: &quot;PUT&quot;,
            &quot;path&quot;: &quot;/1.1/classes/Post/55a39634e4b0ed48f0c1845b&quot;,
            &quot;body&quot;: {
              &quot;upvotes&quot;: 2
            }
          },
          {
            &quot;method&quot;: &quot;DELETE&quot;,
            &quot;path&quot;: &quot;/1.1/classes/Post/55a39634e4b0ed48f0c1845c&quot;
          }
        ]
      }&#39; \
  https://{{v2Domain}}/1.1/batch
</code></pre>
<h3 id="-">数据类型</h3>
<p>到现在为止我们只使用了可以被标准 JSON 编码的值，LeanCloud 移动客户端 SDK library 同样支持日期、二进制数据和关系型数据。在 REST API 中，这些值都被编码了，同时有一个 <code>__type</code> 字段（注意：<strong>前缀是两个下划线</strong>）来标示出它们的类型，所以如果你采用正确的编码的话就可以读或者写这些字段。</p>
<p><a id="datatype_date" name="datatype_date"></a><strong>Date</strong> 类型包含了一个 iso 字段，其值是一个 UTC 时间戳，以 ISO 8601 格式和毫秒级的精度来存储的时间值，格式为：<code>YYYY-MM-DDTHH:MM:SS.MMMZ</code>：</p>
<pre><code class="lang-json">{
  &quot;__type&quot;: &quot;Date&quot;,
  &quot;iso&quot;: &quot;2015-06-21T18:02:52.249Z&quot;
}
</code></pre>
<p>Date 和内置的 createdAt 字段和 updatedAt  字段相结合的时候特别有用，举个例子：为了找到在一个特殊时间发布的微博，只需要将 Date 编码后放在使用了比较条件的查询里面：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;createdAt&quot;:{&quot;$gte&quot;:{&quot;__type&quot;:&quot;Date&quot;,&quot;iso&quot;:&quot;2015-06-21T18:02:52.249Z&quot;}}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p><strong>Byte</strong> 类型包含了一个 base64 字段，这个字段是一些二进制数据编码过的 base64 字符串。base64 是 MIME 使用的标准，不包含空白符：</p>
<pre><code class="lang-json">{
  &quot;__type&quot;: &quot;Bytes&quot;,
  &quot;base64&quot;: &quot;5b6I5aSa55So5oi36KGo56S65b6I5Zac5qyi5oiR5Lus55qE5paH5qGj6aOO5qC877yM5oiR5Lus5bey5bCGIExlYW5DbG91ZCDmiYDmnInmlofmoaPnmoQgTWFya2Rvd24g5qC85byP55qE5rqQ56CB5byA5pS+5Ye65p2l44CC&quot;
}
</code></pre>
<p><strong>Pointer</strong> 类型是用来设定 AVObject 作为另一个对象的值时使用的，它包含了 className 和 objectId 两个属性值，用来提取目标对象：</p>
<pre><code class="lang-json">{
  &quot;__type&quot;: &quot;Pointer&quot;,
  &quot;className&quot;: &quot;Post&quot;,
  &quot;objectId&quot;: &quot;55a39634e4b0ed48f0c1845c&quot;
}
</code></pre>
<p>指向用户对象的 Pointer 的 className 为 <code>_User</code>，前面加一个下划线表示开发者不能定义的类名，而且所指的类是 LeanCloud 平台内置的。</p>
<p><strong>Relation</strong> 类型被用在多对多的类型上，移动端使用 AVRelation 作为值，它有一个 className 字段表示目标对象的类名。</p>
  <div class="callout callout-danger">
  <p>Relation 类型已被弃用。请使用 <a href="relation-guide.html#使用中间表实现多对多关系_推荐_">中间表</a> 来完成对关联数据的查询、排序等复杂操作。</p>
</div>


<pre><code class="lang-json">{
  &quot;__type&quot;: &quot;Relation&quot;,
  &quot;className&quot;: &quot;Post&quot;
}
</code></pre>
<p>在进行查询时，Relation 对象的行为很像是 Pointer 的数组，任何针对于 pointer 数组的操作（<code>include</code> 除外）都可以对 Relation 起作用。</p>
<p>当更多的数据类型被加入的时候，它们都会采用 hashmap 加上一个 <code>__type</code> 字段的形式，所以你不应该使用 <code>__type</code> 作为你自己的 JSON 对象的 key。</p>
<h2 id="-">查询</h2>
<h3 id="-">基础查询</h3>
<p>通过发送一个 GET 请求到类的 URL 上，不需要任何 URL 参数，你就可以一次获取多个对象。下面就是简单地获取所有微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>返回的值就是一个 JSON 对象包含了 results 字段，它的值就是对象的列表：</p>
<pre><code class="lang-json">{
  &quot;results&quot;: [
    {
      &quot;content&quot;: &quot;近期 LeanCloud 的文档已经支持评论功能，如果您有疑问、意见或是其他想法，都可以直接在我们文档中提出。&quot;,
      &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,
      &quot;upvotes&quot;: 2,
      &quot;createdAt&quot;: &quot;2015-06-29T03:43:35.931Z&quot;,
      &quot;objectId&quot;: &quot;55a39634e4b0ed48f0c1845b&quot;
    },
    {
      &quot;content&quot;: &quot;每个 Java 程序员必备的 8 个开发工具&quot;,
      &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,
      &quot;pubTimestamp&quot;: 1435541999,
      &quot;createdAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
      &quot;updatedAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
      &quot;objectId&quot;: &quot;558e20cbe4b060308e3eb36c&quot;
    }
  ]
}
</code></pre>
<p>注：应用控制台对 <code>createdAt</code> 和 <code>updatedAt</code> 做了在展示优化，它们会依据用户操作系统时区而显示为本地时间；客户端 SDK 获取到这些时间后也会将其转换为本地时间；而通过 REST API 获取到的则是原始的 UTC 时间，开发者可能需要根据情况做相应的时区转换。 </p>
<h3 id="-">查询约束</h3>
<p>通过 <code>where</code> 参数的形式可以对查询对象做出约束。</p>
<p><code>where</code> 参数的值应该是 JSON 编码过的。就是说，如果你查看真正被发出的 URL 请求，它应该是先被 JSON 编码过，然后又被 URL 编码过。最简单的使用 <code>where</code> 参数的方式就是包含应有的 key 和 value。例如，如果我们想要看到「LeanCloud官方客服」发布的所有微博，我们应该这样构造查询:</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;pubUser&quot;:&quot;LeanCloud官方客服&quot;}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>除了完全匹配一个给定的值以外，<code>where</code> 也支持比较的方式，而且它还支持对 key 的一些 hash 操作，比如包含。<code>where</code> 参数支持如下选项：</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Operation</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$ne</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>$lt</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>$lte</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>$gt</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>$gte</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>$regex</code></td>
<td>正则表达式。<code>$options</code> 指定 <a href="#regex-options">全局修饰符</a></td>
</tr>
<tr>
<td><code>$in</code></td>
<td>包含任意一个数组值</td>
</tr>
<tr>
<td><code>$nin</code></td>
<td>不包含任意一个数组值</td>
</tr>
<tr>
<td><code>$all</code></td>
<td>包括所有的数组值</td>
</tr>
<tr>
<td><code>$exists</code></td>
<td>指定 Key 有值</td>
</tr>
<tr>
<td><code>$select</code></td>
<td>匹配另一个查询的返回值</td>
</tr>
<tr>
<td><code>$dontSelect</code></td>
<td>排除另一个查询的返回值</td>
</tr>
</tbody>
</table>
<p>例如获取在 <strong>2015-06-29</strong> 当天发布的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;createdAt&quot;:{&quot;$gte&quot;:{&quot;__type&quot;:&quot;Date&quot;,&quot;iso&quot;:&quot;2015-06-29T00:00:00.000Z&quot;},&quot;$lt&quot;:{&quot;__type&quot;:&quot;Date&quot;,&quot;iso&quot;:&quot;2015-06-30T00:00:00.000Z&quot;}}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>求点赞次数少于 10 次，且该次数还是奇数的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;upvotes&quot;:{&quot;$in&quot;:[1,3,5,7,9]}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>获取不是「LeanCloud官方客服」发布的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;pubUser&quot;:{&quot;$nin&quot;:[&quot;LeanCloud官方客服&quot;]}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>获取有人喜欢的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;upvotes&quot;:{&quot;$exists&quot;:true}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>获取没有被人喜欢过的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;upvotes&quot;:{&quot;$exists&quot;:false}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>微博有用户互相关注的功能，如果我们用 <code>_Followee</code>（用户关注的人） 和 <code>_Follower</code>（用户的粉丝） 这两个类来存储用户之间的关注关系（我们的 <a href="./status_system.html">应用内社交组件</a> 已经实现了这样的模型），我们可以创建一个查询来找到某个用户关注的人发布的微博（<code>Post</code> 表中有一个字段 <code>author</code> 指向发布者）：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={
    &quot;author&quot;: {
      &quot;$select&quot;: {
        &quot;query&quot;: { 
          &quot;className&quot;:&quot;_Followee&quot;,
           &quot;where&quot;: {
             &quot;user&quot;:{
               &quot;__type&quot;: &quot;Pointer&quot;,
               &quot;className&quot;: &quot;_User&quot;,
               &quot;objectId&quot;: &quot;55a39634e4b0ed48f0c1845c&quot; 
             }
           }
        }, 
        &quot;key&quot;:&quot;followee&quot; 
      }
    }
  }&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p><code>order</code> 参数指定一个字段的排序方式，前面加一个负号表示逆序。返回 Post 记录并按发布时间升序排列：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;order=createdAt&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>降序排列：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;order=-createdAt&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>对多个字段进行排序，要使用逗号分隔的列表。将 Post 以 createdAt 升序和 pubUser 降序进行排序：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;order=createdAt,-pubUser&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>你可以用 <code>limit</code> 和 <code>skip</code> 来做分页。<code>limit</code> 的默认值是 100，任何 1 到 1000 之间的值都是可选的，在 1 到 1000 范围之外的都强制转成默认的 100。比如为了获取排序在 400 到 600 之间的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;limit=200&#39; \
  --data-urlencode &#39;skip=400&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>你可以限定返回的字段通过传入 <code>keys</code> 参数和一个逗号分隔列表。为了返回对象只包含 <code>pubUser</code> 和 <code>content</code> 字段（还有特殊的内置字段比如 objectId、createdAt 和 updatedAt）：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;keys=pubUser,content&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p><code>keys</code> 还支持反向选择，也就是不返回某些字段，字段名前面加个减号即可，比如我不想查询返回 <code>author</code>：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;keys=-author&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>所有以上这些参数都可以和其他的组合进行使用。</p>
<h3 id="-">正则查询</h3>
<p>获取标题以大写「WTO」开头的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;where={&quot;title&quot;:{&quot;$regex&quot;:&quot;^WTO.*&quot;,&quot;$options&quot;:&quot;i&quot;}}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p><a name="regex-options"></a>我们使用以下数据来演示如何使用 <code>$options</code> 匹配 <strong>title</strong> 字段值：</p>
<pre><code>{ &quot;_id&quot; : 100, &quot;title&quot; : &quot;Single line description.&quot; },
{ &quot;_id&quot; : 101, &quot;title&quot; : &quot;First line\nSecond line&quot; },
{ &quot;_id&quot; : 102, &quot;title&quot; : &quot;Many spaces before     line&quot; },
{ &quot;_id&quot; : 103, &quot;title&quot; : &quot;Multiple\nline description&quot; },
{ &quot;_id&quot; : 103, &quot;title&quot; : &quot;abc123&quot; }
</code></pre><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>i</code></td>
<td><strong>忽略大小写</strong></td>
<td><code>{&quot;$regex&quot;:&quot;single&quot;, &quot;$options&quot;:&quot;i&quot;}</code> 将匹配<br><br><pre><code>{ &quot;_id&quot; : 100, &quot;title&quot; : &quot;Single line description.&quot; }</code></pre></td>
</tr>
<tr>
<td><code>m</code></td>
<td><strong>多行匹配</strong><br>比如文本中包含了换行符 <code>\n</code></td>
<td><code>{&quot;$regex&quot;:&quot;^S&quot;, &quot;$options&quot;:&quot;m&quot;}</code>（以大写字母 S 开头）将匹配 <br><br><pre><code>{ &quot;_id&quot; : 100, &quot;title&quot; : &quot;Single line description.&quot; },<br>{ &quot;_id&quot; : 101, &quot;title&quot; : &quot;First line\nSecond line&quot; }</code></pre></td>
</tr>
<tr>
<td><code>x</code></td>
<td><strong>忽略空白字符</strong><br>包括空格、tab、<code>\n</code>、<code>#</code> 注释等，<br>但对 vertical tab（ASCII 码为 11）无效。</td>
<td><code>{&quot;$regex&quot;:&quot;abc #category code\n123 #item number&quot;, &quot;$options&quot;:&quot;x&quot;}</code>（# 后面为注释）将匹配 <br><br><pre><code>{ &quot;_id&quot; : 103, &quot;title&quot; : &quot;abc123&quot; }</code></pre></td>
</tr>
<tr>
<td><code>s</code></td>
<td><strong>允许 <code>.</code> 匹配任意字符和换行</strong></td>
<td><code>{&quot;$regex&quot;:&quot;m.*line&quot;, &quot;$options&quot;:&quot;si&quot;}</code> 将匹配 <br><br><pre><code>{ &quot;_id&quot; : 102, &quot;title&quot; : &quot;Many spaces before     line&quot; },<br>{ &quot;_id&quot; : 103, &quot;title&quot; : &quot;Multiple\nline description&quot; }</code></pre></td>
</tr>
</tbody>
</table>
<p>以上参数可以组合使用，如 <code>&quot;$options&quot;:&quot;sixm&quot;</code>。</p>
<h3 id="-">数组查询</h3>
<p>如果 key 的值是数组类型，查找 key 值中有 2 的对象：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;arrayKey&quot;:2}&#39; \
  https://{{v2Domain}}/1.1/classes/TestObject
</code></pre>
<p>查找 key 值中有 2 或 3 或 4 的对象：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;arrayKey&quot;:{&quot;$in&quot;:[2,3,4]}}&#39; \
  https://{{v2Domain}}/1.1/classes/TestObject
</code></pre>
<p>使用 <code>$all</code> 操作符来找到 key 值中<strong>同时</strong>有 2 和 3 和 4 的对象：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;arrayKey&quot;:{&quot;$all&quot;:[2,3,4]}}&#39; \
  https://{{v2Domain}}/1.1/classes/TestObject
</code></pre>
<h3 id="-">关系查询</h3>
<p>有几种方式来查询对象之间的关系数据。如果你想获取对象，而这个对象的一个字段对应了另一个对象，你可以用一个 <code>where</code> 查询，自己构造一个 Pointer，和其他数据类型一样。例如，每条微博都会有很多人评论，我们可以让每一个 Comment 将它对应的 Post 对象保存到 post 字段上，这样你可以取得一条微博下所有 Comment：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;post&quot;:{&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;Post&quot;,&quot;objectId&quot;:&quot;558e20cbe4b060308e3eb36c&quot;}}&#39; \
  https://{{v2Domain}}/1.1/classes/Comment
</code></pre>
<p>如果你想获取对象，这个对象的一个字段指向的对象需要另一个查询来指定，你可以使用 <code>$inQuery</code> 操作符。注意 <code>limit</code> 的默认值是 100 且最大值是 1000，这个限制同样适用于内部的查询，所以对于较大的数据集你可能需要细心地构建查询来获得期望的结果。</p>
<p>如上面的例子，假设每条微博还有一个 <code>image</code> 的字段，用来存储配图，你可以这样列出带图片的微博的评论数据：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;post&quot;:{&quot;$inQuery&quot;:{&quot;where&quot;:{&quot;image&quot;:{&quot;$exists&quot;:true}},&quot;className&quot;:&quot;Post&quot;}}}&#39; \
  https://{{v2Domain}}/1.1/classes/Comment
</code></pre>
<p>如果你想获取作为其父对象的关系成员的对象，你可以使用 <code>$relatedTo</code> 操作符。例如对于微博这种社交类应用来讲，每一条微博都可以被不同的用户点赞，我们可以设计 Post 类下面有一个 key 是 Relation 类型，叫做 <code>likes</code>，存储了喜欢这个 Post 的所有 User。</p>
  <div class="callout callout-danger">
  <p>Relation 类型已被弃用。请使用 <a href="relation-guide.html#使用中间表实现多对多关系_推荐_">中间表</a> 来完成对关联数据的查询、排序等复杂操作。</p>
</div>


<p>你可以通过下面的方式找到喜欢某条 Post 的所有用户（<strong>请注意，新创建应用的 <code>_User</code> 表的查询权限默认是关闭的，你可以通过 class 权限设置打开，请参考 <a href="data_security.html#Class_级别的_ACL">数据与安全 - Class 级别的权限</a>。</strong>）：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;$relatedTo&quot;:{&quot;object&quot;:{&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;Post&quot;,&quot;objectId&quot;:&quot;558e20cbe4b060308e3eb36c&quot;},&quot;key&quot;:&quot;likes&quot;}}&#39; \
  https://{{v2Domain}}/1.1/users
</code></pre>
<p>有时候，你可能需要在一个查询之中返回多种类型，你可以通过传入字段到 <code>include</code> 参数中。比如，我们想获得最近的 10 篇评论，而你想同时得到它们关联的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;order=-createdAt&#39; \
  --data-urlencode &#39;limit=10&#39; \
  --data-urlencode &#39;include=post&#39; \
  https://{{v2Domain}}/1.1/classes/Comment
</code></pre>
<p>不是作为一个 Pointer 表示，<code>post</code> 字段现在已经被展开为一个完整的对象：<code>__type</code> 被设置为 Object 而 <code>className</code> 同样也被提供了。例如，一个指向 Post 的 Pointer 可能被展示为：</p>
<pre><code class="lang-json">{
  &quot;__type&quot;: &quot;Pointer&quot;,
  &quot;className&quot;: &quot;Post&quot;,
  &quot;objectId&quot;: &quot;51e3a359e4b015ead4d95ddc&quot;
}
</code></pre>
<p>当一个查询使用 <code>include</code> 参数来包含进去来取代 pointer 之后，可以看到 pointer 被展开为：</p>
<pre><code class="lang-json">{
  &quot;__type&quot;: &quot;Object&quot;,
  &quot;className&quot;: &quot;Post&quot;,
  &quot;objectId&quot;: &quot;51e3a359e4b015ead4d95ddc&quot;,
  &quot;createdAt&quot;: &quot;2015-06-29T09:31:20.371Z&quot;,
  &quot;updatedAt&quot;: &quot;2015-06-29T09:31:20.371Z&quot;,
  &quot;desc&quot;: &quot;Post 的其他字段也会一同被包含进来。&quot;
}
</code></pre>
<p>你可以同样做多层的 <code>include</code>，这时要使用点号（.）。如果你要 include 一个 Comment 对应的 Post 对应的 <code>author</code>：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;order=-createdAt&#39; \
  --data-urlencode &#39;limit=10&#39; \
  --data-urlencode &#39;include=post.author&#39; \
  https://{{v2Domain}}/1.1/classes/Comment
</code></pre>
<p>如果你要构建一个查询，这个查询要 include 多个类，此时用逗号分隔列表即可。</p>
<h3 id="-">对象计数</h3>
<p>如果你在使用 <code>limit</code>，或者如果返回的结果很多，你可能想要知道到底有多少对象应该返回，而不用把它们全部获得以后再计数，此时你可以使用 <code>count</code> 参数。举个例子，如果你仅仅是关心一个某个用户发布了多少条微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;pubUser&quot;:&quot;LeanCloud官方客服&quot;}&#39; \
  --data-urlencode &#39;count=1&#39; \
  --data-urlencode &#39;limit=0&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>因为这个 request 请求了 <code>count</code> 而且把 <code>limit</code> 设为了 0，返回的值里面只有计数，没有 <code>results</code>：</p>
<pre><code class="lang-json">{
  &quot;results&quot;: [

  ],
  &quot;count&quot;: 7
}
</code></pre>
<p>如果有一个非 0 的 <code>limit</code> 的话，则既会返回 <code>results</code> 也会返回 <code>count</code>。</p>
<h3 id="-">复合查询</h3>
<p><code>$or</code> 操作符用于查询<strong>符合任意一种条件</strong>的对象，它的值为一个 JSON 数组。例如，查询企业账号和个人账号的微博：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={&quot;$or&quot;:[{&quot;pubUserCertificate&quot;:{&quot;$gt&quot;:2}},{&quot;pubUserCertificate&quot;:{&quot;$lt&quot;:3}}]}&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>任何在查询上的其他约束都会对返回的对象生效，所以你可以用 <code>$or</code> 对其他的查询添加约束。</p>
<p><code>$and</code> 操作符用于查询<strong>符合全部条件</strong>的对象，它的值为一个 JSON 数组。例如查找存在 price 字段且 price != 199 的对象：</p>
<pre><code>--data-urlencode &#39;where={&quot;$and&quot;:[{&quot;price&quot;: {&quot;$ne&quot;:199}},{&quot;price&quot;:{&quot;$exists&quot;:true}}]}&#39; \
</code></pre>  <div class="callout callout-danger">
  <p>在组合查询的子查询中不支持使用 limit、skip、order、include 等非过滤型的约束。</p>
</div>


<h3 id="-cql-">使用 CQL 查询</h3>
<p>我们还提供类 SQL 语法的 CQL 查询语言，查询应用内数据，例如：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;cql=select * from Post limit 0,100 order by pubUser&#39; \
  https://{{v2Domain}}/1.1/cloudQuery
</code></pre>
<p>更多请参考 <a href="./cql_guide.html">CQL 详细指南</a>。</p>
<p>CQL 还支持占位符查询，<code>where</code> 和 <code>limit</code> 子句的条件参数可以使用问号替换，然后通过 <code>pvalues</code> 数组传入：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;cql=select * from Post where pubUser=? limit ?,? order by createdAt&#39; \
   --data-urlencode &#39;pvalues=[&quot;dennis&quot;, 0, 100]&#39;
  https://{{v2Domain}}/1.1/cloudQuery
</code></pre>
<h4 id="-">子查询的局限</h4>
<p>使用子查询可能会遇到查不到记录或查到的记录不全的情况。例如：</p>
<pre><code class="lang-sql">-- 找出积分高于 80、region 为 cn 的玩家记录
SELECT * 
FROM   player 
WHERE  NAME IN (SELECT NAME 
                FROM   gamescore 
                WHERE  score &gt; 80) 
       AND region = &#39;cn&#39;
</code></pre>
<p>LeanCloud 云端使用的并非关系型数据库，无法做到真正的联表查询，所以实际的处理方式是：先执行内嵌/子查询（和普通查询一样，limit 默认为 100，最大  1000），然后将子查询的结果填入主查询的对应位置，再执行主查询。</p>
<p>如果子查询匹配到了 100 条以上的记录（性别等区分度低的字段重复值往往较多），且主查询有其他查询条件（<code>region = &#39;cn&#39;</code>），那么可能会出现没有结果或结果不全的情况，其本质上是子查询查出的 100 条记录没有满足主查询的其他条件。</p>
<p>我们建议采用以下方案进行改进：</p>
<ul>
<li>确保子查询的结果在 100 条以下，如果在 100 - 1000 条的话请在子查询末尾添加 limit 1000。</li>
<li>将需要查询的字段冗余到主查询所在的表上；例如将 score 冗余到 Player 表上，或者将 region 添加到 GameScore 上然后只查 GameScore 表。</li>
<li>进行多次查询，每次在子查询上添加 skip 来遍历所有记录（注意 skip 的值较大时可能会引发性能问题，因此不是很推荐）。</li>
</ul>
<h2 id="-">用户</h2>
<p>不仅在移动应用上，还在其他系统中，很多应用都有一个统一的登录流程。通过 REST API 访问用户的账户让你可以在 LeanCloud 上简单实现这一功能。</p>
<p>通常来说，<strong>用户</strong>（类名 <code>_User</code>）这个类的功能与其他的对象是相同的，比如都没有限制模式（Schema free）。User 对象和其他对象不同的是一个用户必须有用户名（username）和密码（password），密码会被自动地加密和存储。LeanCloud 强制要求 username 和 email 这两个字段必须是没有重复的。</p>
<h3 id="-">注册</h3>
<p>注册一个新用户与创建一个新的普通对象之间的不同点在于 username 和 password 字段都是必需的。password 字段会以和其他的字段不一样的方式处理，它在储存时会被加密而且永远不会被返回给任何来自客户端的请求。</p>
<p>你可以让 LeanCloud 自动验证邮件地址，做法是进入 <a href="/app.html?appid={{appid}}#/permission">控制台 &gt; <strong>设置</strong> &gt; <strong>应用选项</strong></a>，勾选 <strong>用户账号</strong> 下的 <strong>用户注册时，发送验证邮件</strong>。</p>
<p>这项设置启用了的话，所有填写了 email 的用户在注册时都会产生一个 email 验证地址，并发回到用户邮箱，用户打开邮箱点击了验证链接之后，用户表里 <code>emailVerified</code> 属性值会被设为 true。你可以在 <code>emailVerified</code> 字段上查看用户的 email 是否已经通过验证。</p>
<p>为了注册一个新的用户，需要向 user 路径发送一个 POST 请求，你可以加入一个新的字段，例如，创建一个新的用户有一个电话号码:</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;username&quot;:&quot;hjiang&quot;,&quot;password&quot;:&quot;f32@ds*@&amp;dsa&quot;,&quot;phone&quot;:&quot;18612340000&quot;}&#39; \
  https://{{v2Domain}}/1.1/users
</code></pre>
<p>当创建成功时，HTTP返回为 201 Created，Location 头包含了新用户的 URL：</p>
<pre><code class="lang-sh">Status: 201 Created
Location: https://{{v2Domain}}/1.1/users/55a47496e4b05001a7732c5f
</code></pre>
<p>返回的主体是一个 JSON 对象，包含 objectId、createdAt 时间戳表示创建对象时间，sessionToken 可以被用来认证这名用户随后的请求：</p>
<pre><code>{
  &quot;sessionToken&quot;:&quot;qmdj8pdidnmyzp0c7yqil91oc&quot;,
  &quot;createdAt&quot;:&quot;2015-07-14T02:31:50.100Z&quot;,
  &quot;objectId&quot;:&quot;55a47496e4b05001a7732c5f&quot;
}
</code></pre><h3 id="-">登录</h3>
<p>在你允许用户注册之后，在以后你需要让他们用自己的用户名和密码登录。为了做到这一点，发送一个 POST 请求到 /1.1/login，加上 username 和 password 作为 body。</p>
<pre><code class="lang-sh">curl -X POST \
-H &quot;Content-Type: application/json&quot; \
-H &quot;X-LC-Id: {{appid}}&quot; \
-H &quot;X-LC-Key: {{appkey}}&quot; \
-d &#39;{&quot;username&quot;:&quot;hjiang&quot;,&quot;password&quot;:&quot;f32@ds*@&amp;dsa&quot;}&#39; \
https://{{v2Domain}}/1.1/login
</code></pre>
<p>返回的主体是一个 JSON 对象包括所有除了 password 以外的自定义字段。它同样包含了 createdAt、updateAt、objectId 和 sessionToken 字段。</p>
<pre><code class="lang-json">{
  &quot;sessionToken&quot;:&quot;qmdj8pdidnmyzp0c7yqil91oc&quot;,
  &quot;updatedAt&quot;:&quot;2015-07-14T02:31:50.100Z&quot;,
  &quot;phone&quot;:&quot;18612340000&quot;,
  &quot;objectId&quot;:&quot;55a47496e4b05001a7732c5f&quot;,
  &quot;username&quot;:&quot;hjiang&quot;,
  &quot;createdAt&quot;:&quot;2015-07-14T02:31:50.100Z&quot;,
  &quot;emailVerified&quot;:false,
  &quot;mobilePhoneVerified&quot;:false
}
</code></pre>
<p>可以将 sessionToken 理解为用户的登录凭证，每个用户的 sessionToken 在同一个应用内都是唯一的， 类似于 Cookie 的概念。</p>
<p>正常情况下，用户的 sessionToken 是固定不变的，但在以下情况下会发生改变：</p>
<ul>
<li>用户调用了忘记密码功能，重设了密码。</li>
<li>用户在控制台的 <a href="/app.html?appid={{appid}}#/permission">应用选项</a> 中勾选了 <strong>密码修改后，强制客户端重新登录</strong>，那么在修改密码后 sessionToken 也将强制更换。</li>
<li>调用 <a href="#重置登录_sessionToken"><code>refreshSessionToken</code></a> 主动重置。</li>
</ul>
<p>在 sessionToken 变化后，已有的登录如果调用到用户相关权限受限的 API，将返回 403 权限错误。</p>
<h3 id="-">已登录的用户信息</h3>
<p>用户成功注册或登录后，服务器会返回 sessionToken 并保存在本地，后续请求可以通过传递 sessionToken 来获取该用户信息（如访问权限等）。更多说明请参考 <a href="leanstorage_guide-js.html#SessionToken">存储 &middot; sessionToken</a>。</p>
<pre><code>curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  https://{{v2Domain}}/1.1/users/me
</code></pre><p>返回的 JSON 数据与 <a href="#登录"><code>/login</code></a> 登录请求所返回的相同。</p>
<h3 id="-sessiontoken">重置登录 sessionToken</h3>
<p>可以主动重置用户的 sessionToken：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  https://{{v2Domain}}/1.1/users/57e3bcca67f35600577c3063/refreshSessionToken
</code></pre>
<p>调用这个 API 要求传入登录返回的 <code>X-LC-Session</code> 作为认证，或者使用 Master Key。</p>
<p>重置成功将返回新的 sessionToken 及用户信息：</p>
<pre><code class="lang-json">{
 &quot;sessionToken&quot;:&quot;5frlikqlwzx1nh3wzsdtfr4q7&quot;,
 &quot;updatedAt&quot;:&quot;2016-10-20T03:10:57.926Z&quot;,
 &quot;objectId&quot;:&quot;57e3bcca67f35600577c3063&quot;,
 &quot;username&quot;:&quot;leancloud&quot;,
 &quot;createdAt&quot;:&quot;2016-09-22T11:13:14.842Z&quot;,
 &quot;emailVerified&quot;:false,
 &quot;mobilePhoneVerified&quot;:false
}
</code></pre>
<h4 id="-">账户锁定</h4>
<p>输入错误的密码或验证码会导致用户登录失败。如果在 15 分钟内，同一个用户登录失败的次数大于 6 次，该用户账户即被云端暂时锁定，此时云端会返回错误码 <code>{&quot;code&quot;:219,&quot;error&quot;:&quot;登录失败次数超过限制，请稍候再试，或者通过忘记密码重设密码。&quot;}</code>，开发者可在客户端进行必要提示。</p>
<p>锁定将在最后一次错误登录的 15 分钟之后由云端自动解除，开发者无法通过 SDK 或 REST API 进行干预。在锁定期间，即使用户输入了正确的验证信息也不允许登录。这个限制在 SDK 和云引擎中都有效。</p>
<h3 id="-">使用手机号码注册或登录</h3>
<p>请参考 <a href="rest_sms_api.html#使用手机号码注册或登录">短信服务 REST API 详解 &middot; 使用手机号码注册或登录</a>。</p>
<h3 id="-email">验证 Email</h3>
<p>设置 email 验证是 app 设置中的一个选项，通过这个标识，应用层可以对提供真实 email 的用户更好的功能或者体验。Email 验证会在 User 对象中加入 <code>emailVerified</code> 字段，当一个用户的 email 被新设置或者修改过的话，<code>emailVerified</code> 会被重置为 false。LeanCloud 后台会往用户填写的邮箱发送一个验证链接，用户点击这个链接可以让 <code>emailVerified</code> 被设置为 true。</p>
<p>emailVerified 字段有 3 种状态可以参考：</p>
<ol>
<li><strong>true</strong>：用户已经点击了发送到邮箱的验证地址，邮箱被验证为真实有效。LeanCloud 保证在新创建用户的时候 emailVerified 一定为 false。</li>
<li><strong>false</strong>：User 对象最后一次被更新的时候，用户并没有确认过他的 email 地址。如果你看到 emailVerified 为 false 的话，你可以考虑刷新 User 对象或者再次请求验证用户邮箱。</li>
<li><strong>null</strong>：User对象在 email 验证没有打开的时候就已经创建了，或者 User 没有 email。</li>
</ol>
<p>关于自定义邮件模板和验证链接请看博客文章<a href="https://blog.leancloud.cn/607/">《自定义应用内用户重设密码和邮箱验证页面》</a>。</p>
<h3 id="-email">请求验证 Email</h3>
<p>发送给用户的邮箱验证邮件在一周内失效，你可以通过调用 <code>/1.1/requestEmailVerify</code> 来强制重新发送：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;email&quot;:&quot;hang@leancloud.rocks&quot;}&#39; \
  https://{{v2Domain}}/1.1/requestEmailVerify
</code></pre>
<h3 id="-">请求密码重设</h3>
<p>在用户将 email 与他们的账户关联起来之后，你可以通过邮件来重设密码。操作方法为，发送一个 POST 请求到 <code>/1.1/requestPasswordReset</code>，同时在 request 的 body 部分带上 email 字段。</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;email&quot;:&quot;hang@leancloud.rocks&quot;}&#39; \
  https://{{v2Domain}}/1.1/requestPasswordReset
</code></pre>
<p>如果成功的话，返回的值是一个 JSON 对象。</p>
<p>关于自定义邮件模板和验证链接请看这篇博客文章<a href="https://blog.leancloud.cn/607/">《自定义应用内用户重设密码和邮箱验证页面》</a>。</p>
<h3 id="-">手机号码验证</h3>
<p>请参考 <a href="rest_sms_api.html#用户账户与手机号码验证">短信服务 REST API 详解 - 用户账户与手机号码验证</a>。</p>
<h3 id="-">获取用户</h3>
<p>你可以发送一个 GET 请求到 URL 以获取用户的账户信息，返回的内容就是当创建用户时返回的内容。比如，为了获取上面创建的用户:</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/users/55a47496e4b05001a7732c5f
</code></pre>
<p>返回的 body 是一个 JSON 对象，包含所有用户提供的字段，除了密码以外，也包括了 createdAt、 updatedAt 和 objectId 字段.</p>
<pre><code class="lang-json">{
  &quot;updatedAt&quot;:&quot;2015-07-14T02:31:50.100Z&quot;,
  &quot;phone&quot;:&quot;18612340000&quot;,
  &quot;objectId&quot;:&quot;55a47496e4b05001a7732c5f&quot;,
  &quot;username&quot;:&quot;hjiang&quot;,
  &quot;createdAt&quot;:&quot;2015-07-14T02:31:50.100Z&quot;,
  &quot;emailVerified&quot;:false,
  &quot;mobilePhoneVerified&quot;:false
}
</code></pre>
<h3 id="-">更新用户</h3>
<p>在通常的情况下，没有人会允许别人来改动他们自己的数据。为了做好权限认证，确保只有用户自己可以修改个人数据，在更新用户信息的时候，必须在 HTTP 头部加入一个 <code>X-LC-Session</code> 项来请求更新，这个 session token 在注册和登录时会返回。</p>
<p>为了改动一个用户已经有的数据，需要对这个用户的 URL 发送一个 PUT 请求。任何你没有指定的 key 都会保持不动，所以你可以只改动用户数据中的一部分。username 和 password 也是可以改动的，但是新的 username 不能和既有数据重复。</p>
<p>比如，如果我们想对 「hjiang」 的手机号码做出一些改动:</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;phone&quot;:&quot;18600001234&quot;}&#39; \
  https://{{v2Domain}}/1.1/users/55a47496e4b05001a7732c5f
</code></pre>
<p>返回的 body 是一个 JSON 对象，只有一个 <code>updatedAt</code> 字段表明更新发生的时间.</p>
<pre><code class="lang-json">{
  &quot;updatedAt&quot;: &quot;2015-07-14T02:35:50.100Z&quot;
}
</code></pre>
<h3 id="-">安全地修改用户密码</h3>
<p>修改密码，可以直接使用上面的<code>PUT /1.1/users/:objectId</code>的 API，但是很多开发者会希望让用户输入一次旧密码做一次认证，旧密码正确才可以修改为新密码，因此我们提供了一个单独的 API <code>PUT /1.1/users/:objectId/updatePassword</code> 来安全地更新密码：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;old_password&quot;:&quot;the_old_password&quot;, &quot;new_password&quot;:&quot;the_new_password&quot;}&#39; \
  https://{{v2Domain}}/1.1/users/55a47496e4b05001a7732c5f/updatePassword
</code></pre>
<ul>
<li><strong>old_password</strong>：用户的老密码</li>
<li><strong>new_password</strong>：用户的新密码</li>
</ul>
<p>注意：仍然需要传入 X-LC-Session，也就是登录用户才可以修改自己的密码。</p>
<h3 id="-">查询</h3>
<p><strong>请注意，新创建应用的 <code>_User</code> 表的查询权限默认是关闭的，你可以通过 class 权限设置打开，请参考 <a href="data_security.html#Class_级别的_ACL">数据与安全 - Class 级别的权限</a>。</strong></p>
<p>你可以一次获取多个用户，只要向用户的根 URL 发送一个 GET 请求。没有任何 URL 参数的话，可以简单地列出所有用户：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/users
</code></pre>
<p>返回的值是一个 JSON 对象包括一个 <code>results</code> 字段，值是包含了所有对象的一个 JSON 数组。</p>
<pre><code class="lang-json">{
  &quot;results&quot;:[
    {
      &quot;updatedAt&quot;:&quot;2015-07-14T02:31:50.100Z&quot;,
      &quot;phone&quot;:&quot;18612340000&quot;,
      &quot;objectId&quot;:&quot;55a47496e4b05001a7732c5f&quot;,
      &quot;username&quot;:&quot;hjiang&quot;,
      &quot;createdAt&quot;:&quot;2015-07-14T02:31:50.100Z&quot;,
      &quot;emailVerified&quot;:false,
      &quot;mobilePhoneVerified&quot;:false
    }
  ]
}
</code></pre>
<p>所有的对普通对象的查询选项都适用于对用户对象的查询，所以可以查看 <a href="#查询">查询</a> 部分来获取详细信息。</p>
<h3 id="-">删除用户</h3>
<p>为了在 LeanCloud 上删除一个用户，可以向它的 URL 上发送一个 DELETE 请求。同样的，你必须提供一个 X-LC-Session 在 HTTP 头上以便认证。例如：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  https://{{v2Domain}}/1.1/users/55a47496e4b05001a7732c5f
</code></pre>
<h3 id="-">连接用户账户和第三方平台</h3>
<p>LeanCloud 允许你连接你的用户到其他服务，比如新浪微博和腾讯微博，这样就允许你的用户直接用他们现有的账号 id 来登录你的 App。通过 <code>signup</code> 或者更新的 endpoint，并使用 <code>authData</code> 字段来提供你希望连接的服务的授权信息就可以做到。一旦关联了某个服务，<code>authData</code> 将被存储到你的用户信息里。如需重新获取该内容，请参考 <a href="获取_authData">获取 authData</a>。</p>
<p><code>authData</code> 是一个普通的 JSON 对象，它所要求的 key 根据 service 不同而不同，具体要求见下面。每种情况下，你都需要自己负责完成整个授权过程(一般是通过 OAuth 协议，1.0 或者 2.0) 来获取授权信息，提供给连接 API。</p>
<p><a href="http://weibo.com/">新浪微博</a> 的 authData 内容：</p>
<pre><code class="lang-json">{
  &quot;authData&quot;: {
    &quot;weibo&quot;: {
      &quot;uid&quot;: &quot;123456789&quot;,
      &quot;access_token&quot;: &quot;2.00vs3XtCI5FevCff4981adb5jj1lXE&quot;,
      &quot;expiration_in&quot;: &quot;36000&quot;
    }
  }
}
</code></pre>
<p><a href="http://t.qq.com/">腾讯微博</a> 的 authData 内容：</p>
<pre><code class="lang-json">{
  &quot;authData&quot;: {
    &quot;qq&quot;: {
      &quot;openid&quot;: &quot;0395BA18A5CD6255E5BA185E7BEBA242&quot;,
      &quot;access_token&quot;: &quot;12345678-SaMpLeTuo3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU&quot;,
      &quot;expires_in&quot;: 1382686496
    }
  }
}
</code></pre>
<p><a href="http://open.weixin.qq.com/">微信</a> 的 authData 内容：</p>
<pre><code class="lang-json">{
  &quot;authData&quot;: {
    &quot;weixin&quot;: {
      &quot;openid&quot;: &quot;0395BA18A5CD6255E5BA185E7BEBA242&quot;,
      &quot;access_token&quot;: &quot;12345678-SaMpLeTuo3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU&quot;,
      &quot;expires_in&quot;: 1382686496
    }
  }
}
</code></pre>
<p>匿名用户(Anonymous user)的 authData 内容：</p>
<pre><code class="lang-json">{
  &quot;anonymous&quot;: {
    &quot;id&quot;: &quot;random UUID with lowercase hexadecimal digits&quot;
  }
}
</code></pre>
<p>其他任意第三方平台（其他第三方将不支持校验 access token 选项）：</p>
<pre><code class="lang-json">  {
     &quot;第三方平台名称，例如facebook&quot;:
     {
       &quot;uid&quot;: &quot;在第三方平台上的唯一用户id字符串&quot;,
       &quot;access_token&quot;: &quot;在第三方平台的 access token&quot;,
        ……其他可选属性
     }
  }
</code></pre>
<p>要保证一个第三方账号只绑定到一个 LeanCloud 应用内用户上，就需要为 <code>_User</code> 表中的 <code>authData.第三方平台名称.uid</code> 建立唯一索引；另外当 <code>_User</code> 表的记录数量超过了 1 万条，用户也无法自行创建该索引。这两种操作都需要提交工单或联系 <a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#x73;&#117;&#112;&#x70;&#x6f;&#x72;&#x74;&#x40;&#x6c;&#101;&#97;&#x6e;&#x63;&#x6c;&#x6f;&#x75;&#100;&#46;&#114;&#111;&#x63;&#107;&#x73;">&#x73;&#117;&#112;&#x70;&#x6f;&#x72;&#x74;&#x40;&#x6c;&#101;&#97;&#x6e;&#x63;&#x6c;&#x6f;&#x75;&#100;&#46;&#114;&#111;&#x63;&#107;&#x73;</a> 来创建。</p>
<h4 id="-authdata">获取 authData</h4>
<p>authData 的数据<u>默认为不可查询</u>，也就是说它既不包含在当前登录用户的数据中，也无法在 query 中以 include 或 fetch 来获取。要更改这一默认行为，需要进入 <a href="/dashboard/data.html?appid={{appid}}#/_User">应用控制台 &gt; 存储 &gt; _User 表</a>，点击 authData 字段右侧的箭头，选择 <strong>编辑</strong>，关掉「列属性」里的「客户端不可见」选项才能获取到。</p>
<h4 id="-">注册和登录</h4>
<p>使用一个连接服务来注册用户并登录，同样使用 POST 请求 users，只是需要提供 <code>authData</code> 字段。例如，使用新浪微博账户注册或者登录用户：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
     &quot;authData&quot;: {
       &quot;qq&quot;: {
         &quot;openid&quot;: &quot;0395BA18A5CD6255E5BA185E7BEBA242&quot;,
         &quot;access_token&quot;: &quot;12345678-SaMpLeTuo3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU&quot;,
         &quot;expires_in&quot;: 1382686496
         }
    }
    }&#39; \
  https://{{v2Domain}}/1.1/users
</code></pre>
<p>LeanCloud 会校验提供的 <code>authData</code> 是否有效，并检查是否已经有一个用户连接了这个 <code>authData</code> 服务。如果已经有用户存在并连接了同一个 <code>authData</code>，那么返回 200 OK 和详细信息（包括用户的 <code>sessionToken</code>）：</p>
<pre><code class="lang-sh">Status: 200 OK
Location: https://{{v2Domain}}/1.1/users/75a4800fe4b05001a7745c41
</code></pre>
<p>应答的 body 类似：</p>
<pre><code class="lang-json">{
  &quot;username&quot;: &quot;LeanCloud&quot;,
  &quot;createdAt&quot;: &quot;2015-06-28T23:49:36.353Z&quot;,
  &quot;updatedAt&quot;: &quot;2015-06-28T23:49:36.353Z&quot;,
  &quot;objectId&quot;: &quot;75a4800fe4b05001a7745c41&quot;,
  &quot;sessionToken&quot;: &quot;anythingstringforsessiontoken&quot;,
  &quot;authData&quot;: {
    &quot;qq&quot;: {
      &quot;openid&quot;: &quot;0395BA18A5CD6255E5BA185E7BEBA242&quot;,
      &quot;access_token&quot;: &quot;12345678-SaMpLeTuo3m2avZxh5cjJmIrAfx4ZYyamdofM7IjU&quot;,
      &quot;expires_in&quot;: 1382686496
    }
  }
}
</code></pre>
<p>如果用户还没有连接到这个账号，则你会收到 201 Created 的应答状态码，标识新的用户已经被创建：</p>
<pre><code class="lang-sh">Status: 201 Created
Location: https://{{v2Domain}}/1.1/users/55a4800fe4b05001a7745c41
</code></pre>
<p>应答内容包括 objectId、createdAt、sessionToken 以及一个自动生成的随机 username，例如：</p>
<pre><code class="lang-json">{
  &quot;username&quot;:&quot;ec9m07bo32cko6soqtvn6bko5&quot;,
  &quot;sessionToken&quot;:&quot;tfrvbzmdf609nu9204v5f0tuj&quot;,
  &quot;createdAt&quot;:&quot;2015-07-14T03:20:47.733Z&quot;,
  &quot;objectId&quot;:&quot;55a4800fe4b05001a7745c41&quot;
}
</code></pre>
<h4 id="-">连接</h4>
<p>连接一个现有的用户到新浪微博或者腾讯微博账号，可以向 user endpoint 发送一个附带 <code>authData</code> 字段的 PUT 请求来实现。例如，连接一个用户到新浪微博账号发起的请求类似这样：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;authData&quot;: {
          &quot;weibo&quot;: {
            &quot;uid&quot;: &quot;123456789&quot;,
            &quot;access_token&quot;: &quot;2.00vs3XtCI5FevCff4981adb5jj1lXE&quot;,
            &quot;expiration_in&quot;: &quot;36000&quot;
          }
        }
      }&#39; \
  https://{{v2Domain}}/1.1/users/55a47496e4b05001a7732c5f
</code></pre>
<p>完成连接后，你可以使用匹配的 <code>authData</code> 来认证他们。</p>
<h4 id="-">断开连接</h4>
<p>断开一个现有用户到某个服务，可以发送一个PUT请求设置 <code>authData</code> 中对应的服务为 null 来做到。例如，取消新浪微博关联：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;authData&quot;: {
      &quot;weibo&quot; : null
    }
      }&#39; \
  https://{{v2Domain}}/1.1/users/55a47496e4b05001a7732c5f
</code></pre>
<h3 id="-">安全</h3>
<p>当你用 REST API key 来访问 LeanCloud 时，访问可能被 ACL 所限制，就像 iOS 和 Android SDK 上所做的一样。你仍然可以通过 REST API 来读和修改，只需要通过 <code>ACL</code> 的 key 来访问一个对象。</p>
<p>ACL 按 JSON 对象格式来表示，JSON 对象的 key 是 objectId 或者一个特别的 key（<code>*</code>，表示公共访问权限）。ACL 的值是权限对象，这个 JSON 对象的 key 即是权限名，而这些 key 的值总是 true。</p>
<p>举个例子，如果你想让一个 id 为 55a47496e4b05001a7732c5f 的用户有读和写一个对象的权限，而且这个对象应该可以被公共读取，符合的 ACL 应该是:</p>
<pre><code class="lang-json">{
  &quot;55a47496e4b05001a7732c5f&quot;: {
    &quot;read&quot;: true,
    &quot;write&quot;: true
  },
  &quot;*&quot;: {
    &quot;read&quot;: true
  }
}
</code></pre>
<h2 id="-">角色</h2>
<p>当你的 app 的规模和用户基数成长时，你可能发现你需要比 ACL 模型(针对每个用户)更加粗粒度的访问控制你的数据的方法。为了适应这种需求，LeanCloud 支持一种基于角色的权限控制方式。角色系统提供一种逻辑方法让你通过权限的方式来访问你的数据，角色是一种有名称的对象，包含了用户和其他角色。任何授予一个角色的权限隐含着授予它包含着的其他的角色相应的权限。</p>
<p>例如，在你的 app 中管理着一些内容，你可能有一些类似于「主持人」的角色可以修改和删除其他用户创建的新的内容，你可能还有一些「管理员」有着与「主持人」相同的权限，但是还可以修改 app 的其他全局性设置。通过给予用户这些角色，你可以保证新的用户可以做主持人或者管理员，不需要手动地授予每个资源的权限给各个用户。</p>
<p>我们提供一个特殊的角色（Role）类来表示这些用户组，为了设置权限用。角色有一些和其他对象不太一样的特殊字段。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>角色的名字，这个值是必须的，而且只允许被设置一次，只要这个角色被创建了的话。角色的名字必须由字母、空格、减号或者下划线这些字符构成。这个名字可以用来标明角色而不需要它的 objectId。</td>
</tr>
<tr>
<td>users</td>
<td>一个指向一系列用户的关系，这些用户会继承角色的权限。</td>
</tr>
<tr>
<td>roles</td>
<td>一个指向一系列子角色的关系，这些子关系会继承父角色所有的权限。</td>
</tr>
</tbody>
</table>
<p>通常来说，为了保持这些角色安全，你的移动 app 不应该为角色的创建和管理负责。作为替代，角色应该是通过一个不同的网页上的界面来管理，或者手工被管理员所管理。我们的 REST API 允许你不需要一个移动设备就能管理你的角色。</p>
<h3 id="-">创建角色</h3>
<p>创建一个新的角色与其他的对象不同的是 name 字段是必须的。角色必须指定一个 ACL，这个 ACL 必须尽量的约束严格一些，这样可以防止错误的用户修改角色。</p>
<p>创建一个新角色，发送一个 POST 请求到 roles 根路径：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;name&quot;: &quot;Manager&quot;,
        &quot;ACL&quot;: {
          &quot;*&quot;: {
            &quot;read&quot;: true
          }
        }
      }&#39; \
  https://{{v2Domain}}/1.1/roles
</code></pre>
<p>其返回值类似于：</p>
<pre><code class="lang-json">{
  &quot;createdAt&quot;:&quot;2015-07-14T03:34:41.074Z&quot;,
  &quot;objectId&quot;:&quot;55a48351e4b05001a774a89f&quot;
}
</code></pre>
<p>你可以通过加入已有的对象到 roles 和 users 关系中来创建一个有子角色和用户的角色:</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;name&quot;: &quot;CLevel&quot;,
        &quot;ACL&quot;: {
          &quot;*&quot;: {
            &quot;read&quot;: true
          }
        },
        &quot;roles&quot;: {
          &quot;__op&quot;: &quot;AddRelation&quot;,
          &quot;objects&quot;: [
            {
              &quot;__type&quot;: &quot;Pointer&quot;,
              &quot;className&quot;: &quot;_Role&quot;,
              &quot;objectId&quot;: &quot;55a48351e4b05001a774a89f&quot;
            }
          ]
        },
        &quot;users&quot;: {
          &quot;__op&quot;: &quot;AddRelation&quot;,
          &quot;objects&quot;: [
            {
              &quot;__type&quot;: &quot;Pointer&quot;,
              &quot;className&quot;: &quot;_User&quot;,
              &quot;objectId&quot;: &quot;55a47496e4b05001a7732c5f&quot;
            }
          ]
        }
      }&#39; \
  https://{{v2Domain}}/1.1/roles
</code></pre>
<p>当创建成功时，HTTP 返回是 <strong>201 Created</strong> 而 Location header 包含了新的对象的 URL：</p>
<pre><code class="lang-sh">Status: 201 Created
Location: https://{{v2Domain}}/1.1/roles/55a483f0e4b05001a774b837
</code></pre>
<h3 id="-">获取角色</h3>
<p>你可以同样通过发送一个 GET 请求到 Location header 中返回的 URL 来获取这个对象，比如我们想要获取上面创建的对象：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/roles/55a483f0e4b05001a774b837
</code></pre>
<p>响应的 body 是一个 JSON 对象包含角色的所有字段：</p>
<pre><code class="lang-json">{
  &quot;name&quot;:&quot;CLevel&quot;,
  &quot;createdAt&quot;:&quot;2015-07-14T03:37:20.992Z&quot;,
  &quot;updatedAt&quot;:&quot;2015-07-14T03:37:20.994Z&quot;,
  &quot;objectId&quot;:&quot;55a483f0e4b05001a774b837&quot;,
  &quot;users&quot;:{
    &quot;__type&quot;:&quot;Relation&quot;,
    &quot;className&quot;:&quot;_User&quot;
  },
  &quot;roles&quot;:{
    &quot;__type&quot;:&quot;Relation&quot;,
    &quot;className&quot;:&quot;_Role&quot;
  }
}
</code></pre>
<p>注意 users 和 roles 关系无法在 JSON 中见到，你需要相应地用 <code>$relatedTo</code> 操作符来查询角色中的子角色和用户。</p>
<h3 id="-">更新角色</h3>
<p>更新一个角色通常可以像更新其他对象一样使用，但是 name 字段是不可以更改的。加入和删除 users 和 roles 可以通过使用<code>AddRelation</code> 和 <code>RemoveRelation</code>操作来进行。</p>
<p>举例来说，我们对 Manager 角色加入 1 个用户：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;users&quot;: {
          &quot;__op&quot;: &quot;AddRelation&quot;,
          &quot;objects&quot;: [
            {
              &quot;__type&quot;: &quot;Pointer&quot;,
              &quot;className&quot;: &quot;_User&quot;,
              &quot;objectId&quot;: &quot;55a4800fe4b05001a7745c41&quot;
            }
          ]
        }
      }&#39; \
  https://{{v2Domain}}/1.1/roles/55a48351e4b05001a774a89f
</code></pre>
<p>相似的，我们可以删除一个 Manager 的子角色：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;roles&quot;: {
          &quot;__op&quot;: &quot;RemoveRelation&quot;,
          &quot;objects&quot;: [
            {
              &quot;__type&quot;: &quot;Pointer&quot;,
              &quot;className&quot;: &quot;_Role&quot;,
              &quot;objectId&quot;: &quot;55a483f0e4b05001a774b837&quot;
            }
          ]
        }
      }&#39; \
  https://{{v2Domain}}/1.1/roles/55a48351e4b05001a774a89f
</code></pre>
<h3 id="-">删除对象</h3>
<p>为了从 LeanCloud 上删除一个角色，只需要发送 DELETE 请求到它的 URL 就可以了。</p>
<p>我们需要传入 X-LC-Session 来通过一个有权限的用户账号来访问这个角色对象，例如：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;X-LC-Session: qmdj8pdidnmyzp0c7yqil91oc&quot; \
  https://{{v2Domain}}/1.1/roles/55a483f0e4b05001a774b837
</code></pre>
<h3 id="-">安全性</h3>
<p>当你通过 REST API key 访问 LeanCloud 的时候，访问同样可能被 ACL 所限制，就像 iOS 和 Android SDK 上一样。你仍然可以通过 REST API 来读和修改 ACL，只用通过访问「ACL」键就可以了。</p>
<p>除了用户级的权限设置以外，你可以通过设置角色级的权限来限制对 LeanCloud 对象的访问。取代了指定一个 objectId 带一个权限的方式，你可以设定一个角色的权限为它的名字在前面加上 <code>role:</code> 前缀作为 key。你可以同时使用用户级的权限和角色级的权限来提供精细的用户访问控制。</p>
<p>比如，为了限制一个对象可以被在 Staff 里的任何人读到，而且可以被它的创建者和任何有 Manager 角色的人所修改，你应该向下面这样设置 ACL：</p>
<pre><code class="lang-json">{
  &quot;55a4800fe4b05001a7745c41&quot;: {
    &quot;write&quot;: true
  },
  &quot;role:Staff&quot;: {
    &quot;read&quot;: true
  },
  &quot;role:Manager&quot;: {
    &quot;write&quot;: true
  }
}
</code></pre>
<p>你不必为创建的用户和 Manager 指定读的权限，如果这个用户和 Manager 本身就是 Staff 的子角色和用户，因为它们都会继承授予 Staff 的权限。</p>
<h3 id="-">角色继承</h3>
<p>就像上面所说的一样，一个角色可以包含另一个，可以为 2 个角色建立一个「父子」关系。这个关系的结果就是任何被授予父角色的权限隐含地被授予子角色。</p>
<p>这样的关系类型通常在用户管理的内容类的 app 上比较常见，比如论坛。有一些少数的用户是「管理员」，有最高级的权限来调整程序的设置、创建新的论坛、设定全局的消息等等。</p>
<p>另一类用户是「版主」，他们有责任保证用户生成的内容是合适的。任何有管理员权限的人都应该有版主的权利。为了建立这个关系，你应该把「Administartors」的角色设置为「Moderators」 的子角色，具体来说就是把 Administrators 这个角色加入 Moderators 对象的 roles 关系之中：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;roles&quot;: {
          &quot;__op&quot;: &quot;AddRelation&quot;,
          &quot;objects&quot;: [
            {
              &quot;__type&quot;: &quot;Pointer&quot;,
              &quot;className&quot;: &quot;_Role&quot;,
              &quot;objectId&quot;: &quot;&lt;AdministratorsRoleObjectId&gt;&quot;
            }
          ]
        }
      }&#39; \
  https://{{v2Domain}}/1.1/roles/&lt;ModeratorsRoleObjectId&gt;
</code></pre>
<h2 id="-">文件</h2>
<p>对于文件上传，我们推荐使用各个客户端的 SDK 进行操作，或者使用<a href="./leanengine_cli.html">命令行工具</a>。</p>
<p><strong>通过 REST API 上传文件受到三个限制</strong>：</p>
<ul>
<li>上传最大文件大小有 10 M 的限制</li>
<li>每个应用每秒最多上传 1 个文件</li>
<li>每个应用每分钟最多上传 30 个文件</li>
</ul>
<p><strong>而使用 SDK 或者命令行上传没有这些限制</strong>。</p>
<h3 id="-">上传文件</h3>
  <div class="callout callout-danger">
  <p>北美和华东节点不支持通过 REST API 上传文件，请使用 SDK 提供的文件相关接口上传文件。</p>
</div>


<p>上传文件到  LeanCloud  通过 POST 请求，注意必须指定文件的 content-type，例如上传一个文本文件 hello.txt 包含一行字符串：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: text/plain&quot; \
  -d &#39;Hello, World!&#39; \
  https://{{v2Domain}}/1.1/files/hello.txt
</code></pre>
<p>文件上传成功后，返回 <strong>201 Created</strong> 的应答和创建的文件对象（可以在 _File 表看到）：</p>
<pre><code class="lang-json">{  &quot;size&quot;:13,
   &quot;bucket&quot;:&quot;1qdney6b&quot;,
   &quot;url&quot;:&quot;http://ac-1qdney6b.qiniudn.com/3zLG4o0d27MsCQ0qHGRg4JUKbaXU2fiE35HdhC8j.txt&quot;,
   &quot;name&quot;:&quot;hello.txt&quot;,
   &quot;createdAt&quot;:&quot;2014-10-14T05:55:57.455Z&quot;,
   &quot;objectId&quot;:&quot;543cbaede4b07db196f50f3c&quot;
}
</code></pre>
<p>其中 <code>url</code> 就是文件下载链接，<code>objectId</code> 是文件的对象 id，<code>name</code> 就是上传的文件名称。</p>
<p>也可以尝试上传一张图片，假设当前目录有一个文件 test.png：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: image/png&quot; \
  --data-binary &#39;@test.png&#39;  \
  https://{{v2Domain}}/1.1/files/test.png
</code></pre>
<h3 id="-">关联文件到对象</h3>
<p>一个文件上传后，你可以关联该文件到某个 AVObject 对象上：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
   -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;name&quot;: &quot;hjiang&quot;,
        &quot;picture&quot;: {
          &quot;id&quot;: &quot;543cbaede4b07db196f50f3c&quot;,
          &quot;__type&quot;: &quot;File&quot;
        }
      }&#39; \
  https://{{v2Domain}}/1.1/classes/Staff
</code></pre>
<p>其中 <code>id</code> 就是文件对象的 objectId。</p>
<h3 id="-">删除文件</h3>
<p>知道文件对象 ObjectId 的情况下，可以通过 DELETE 删除文件：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/files/543cbaede4b07db196f50f3c
</code></pre>
<h2 id="push-">Push 通知</h2>
<p>请查看我们的 <a href="./push_guide.html#使用_REST_API_推送消息">消息推送开发指南 &middot; 使用 REST API 推送消息</a>。</p>
<h2 id="-">安装数据</h2>
<h3 id="-">上传安装数据</h3>
<p>一个安装对象表示了一个你的在手机上被安装的 app，这些对象被用来保存订阅数据的，这些数据是一个或多个通知通道订阅的。安装数据除了一些特殊字段以外都可以是模式可变的。这些字段都有特殊的类型和验证需求。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>badge</td>
<td>数字，表示最新的 iOS 的安装已知的 application badge。</td>
</tr>
<tr>
<td>channels</td>
<td>数组，可选，表示这个安装对象的订阅频道列表设备订阅的频道。<strong>每个 channel 名称只能包含 26 个英文字母和数字。</strong></td>
</tr>
<tr>
<td>deviceToken</td>
<td>由 Apple 生成的字符串标志，在 deviceType 为 iOS 上的设备是必须的，而且自对象生成开始就不能改动，对于一个 app 来说也是不可重复的。</td>
</tr>
<tr>
<td>deviceType</td>
<td>必须被设置为 &quot;ios&quot;、&quot;android&quot;、&quot;wp&quot;、&quot;web&quot;中的一种，而且自这个对象生成以后就不能变化。</td>
</tr>
<tr>
<td>installationId</td>
<td>由 LeanCloud 生成的字符串标志，而且如果 deviceType 是 android 的话是一个必选字段，如果是 iOS 的话则可选。它只要对象被生成了就不能发生改变，而且对一个 app 来说是不可重复的。</td>
</tr>
<tr>
<td>timeZone</td>
<td>字符串，表示安装的这个设备的系统时区。</td>
</tr>
</tbody>
</table>
<p>大部分时间，安装数据是被客户端中有关 push 的方法所修改的。举个例子，从客户端 SDK 中调用  <code>subscribeToChannel</code> 或者 <code>unsubscribeFromChannel</code>，如果现在还没有安装对象的或者没有更新安装对象的话会创建一个对象，而从客户端 SDK 中调用 <code>getSubscribedChanneles</code> 会从安装对象中读取订阅数据。</p>
<p>REST 的方法可以被用来模仿这些操作。比如，如果你有一个 iOS 的 device token 你可以注册它来向设备推送通知，只需要创建一个有需要的 channels 的安装对象就可以了。你同样可以做一些不能通过客户端 SDK 进行的操作，就比如说查询所有的安装来找到一个 channel 的订阅者的集合。</p>
<p>创建一个安装对象和普通的对象差不多，但是特殊的几个安装字段必须通过认证。举个例子，如果你有一个由 Apple Push Notification 提供的 device token，而且想订阅一个广播频道，你可以如下发送请求：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;deviceType&quot;: &quot;ios&quot;,
        &quot;deviceToken&quot;: &quot;abcdefghijklmnopqrstuvwzxyrandomuuidforyourdevice012345678988&quot;,
        &quot;channels&quot;: [
          &quot;&quot;
        ]
      }&#39; \
  https://{{v2Domain}}/1.1/installations
</code></pre>
<p>当创建成功后，HTTP的返回值为 <strong>201 Created</strong>，Location header 包括了新的安装的 URL：</p>
<pre><code class="lang-sh">Status: 201 Created
Location: https://{{v2Domain}}/1.1/installations/51ff1808e4b074ac5c34d7fd
</code></pre>
<p>返回的 body 是一个 JSON 对象，包括了 objectId 和 createdAt 这个创建对象的时间戳。</p>
<pre><code class="lang-json">{
  &quot;createdAt&quot;: &quot;2012-04-28T17:41:09.106Z&quot;,
  &quot;objectId&quot;: &quot;51ff1808e4b074ac5c34d7fd&quot;
}
</code></pre>
<h3 id="-">获取安装对象</h3>
<p>你可以通过 GET 方法请求创建的时候 Location 表示的 URL 来获取 Installation 对象。比如，获取上面的被创建的对象：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/installations/51ff1808e4b074ac5c34d7fd
</code></pre>
<p>返回的 JSON 对象所有用户提供的字段，加上 createdAt、updatedAt 和 objectId 字段：</p>
<pre><code class="lang-json">{
  &quot;deviceType&quot;: &quot;ios&quot;,
  &quot;deviceToken&quot;: &quot;abcdefghijklmnopqrstuvwzxyrandomuuidforyourdevice012345678988&quot;,
  &quot;channels&quot;: [
    &quot;&quot;
  ],
  &quot;createdAt&quot;: &quot;2012-04-28T17:41:09.106Z&quot;,
  &quot;updatedAt&quot;: &quot;2012-04-28T17:41:09.106Z&quot;,
  &quot;objectId&quot;: &quot;51ff1808e4b074ac5c34d7fd&quot;
}
</code></pre>
<h3 id="-">更新安装对象</h3>
<p>安装对象可以向相应的 URL 发送 PUT 请求来更新。例如，为了让设备订阅一个名字为「foo」的推送频道：</p>
<pre><code class="lang-sh">curl -X PUT \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
        &quot;deviceType&quot;: &quot;ios&quot;,
        &quot;deviceToken&quot;: &quot;abcdefghijklmnopqrstuvwzxyrandomuuidforyourdevice012345678988&quot;,
        &quot;channels&quot;: [
          &quot;&quot;,
          &quot;foo&quot;
        ]
      }&#39; \
  https://{{v2Domain}}/1.1/installations/51ff1808e4b074ac5c34d7fd
</code></pre>
<h3 id="-">查询安装对象</h3>
<p>你可以一次通过 GET 请求到 installations 的根 URL 来获取多个安装对象。这项功能在 SDK 中不可用。</p>
<p>没有任何 URL 参数的话，一个 GET 请求会列出所有安装：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/installations
</code></pre>
<p>返回的 JSON 对象的 results 字段包含了所有的结果：</p>
<pre><code class="lang-json">{
  &quot;results&quot;: [
    {
      &quot;deviceType&quot;: &quot;ios&quot;,
      &quot;deviceToken&quot;: &quot;abcdefghijklmnopqrstuvwzxyrandomuuidforyourdevice012345678988&quot;,
      &quot;channels&quot;: [
        &quot;&quot;
      ],
      &quot;createdAt&quot;: &quot;2012-04-28T17:41:09.106Z&quot;,
      &quot;updatedAt&quot;: &quot;2012-04-28T17:41:09.106Z&quot;,
      &quot;objectId&quot;: &quot;51ff1808e4b074ac5c34d7fd&quot;
    },
    {
      &quot;deviceType&quot;: &quot;ios&quot;,
      &quot;deviceToken&quot;: &quot;876543210fedcba9876543210fedcba9876543210fedcba9876543210fedcba9&quot;,
      &quot;channels&quot;: [
        &quot;&quot;
      ],
      &quot;createdAt&quot;: &quot;2012-04-30T01:52:57.975Z&quot;,
      &quot;updatedAt&quot;: &quot;2012-04-30T01:52:57.975Z&quot;,
      &quot;objectId&quot;: &quot;51fcb74ee4b074ac5c34cf85&quot;
    }
  ]
}
</code></pre>
<p>所有对普通的对象的查询都对 installatin 对象起作用，所以可以查看之前的查询部分以获取详细信息。通过做 channels 的数组查询，你可以查找一个订阅了给定的推送频道的所有设备.</p>
<h3 id="-">删除安装对象</h3>
<p>为了从 AVOSCloud 中删除一个安装对象，可以发送 DELETE 请求到相应的 URL。这个功能在客户端 SDK 也不可用。举例：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/installations/51fcb74ee4b074ac5c34cf85
</code></pre>
<h2 id="-schema">数据 Schema</h2>
<p>为了方便开发者使用、自行研发一些代码生成工具或者内部使用的管理平台。我们提供了获取数据 Class Schema 的开放 API，基于安全考虑，强制要求使用 Master Key 才可以访问。</p>
<p>查询一个应用下面所有 Class 的 Schema:</p>
<pre><code class="lang-sh">curl -X GET \
   -H &quot;X-LC-Id: {{appid}}&quot; \
   -H &quot;X-LC-Key: {{masterkey}},master&quot; \
   https://{{v2Domain}}/1.1/schemas
</code></pre>
<p>返回的 JSON 数据包含了每个 Class 对应的 Schema:</p>
<pre><code class="lang-json">{
  &quot;_User&quot;:{
    &quot;username&quot;     : {&quot;type&quot;:&quot;String&quot;},
    &quot;password&quot;     : {&quot;type&quot;:&quot;String&quot;},
    &quot;objectId&quot;     : {&quot;type&quot;:&quot;String&quot;},
    &quot;emailVerified&quot;: {&quot;type&quot;:&quot;Boolean&quot;},
    &quot;email&quot;        : {&quot;type&quot;:&quot;String&quot;},
    &quot;createdAt&quot;    : {&quot;type&quot;:&quot;Date&quot;},
    &quot;updatedAt&quot;    : {&quot;type&quot;:&quot;Date&quot;},
    &quot;authData&quot;     : {&quot;type&quot;:&quot;Object&quot;}
  }
  ……其他 class……
}
</code></pre>
<p>也可以单独获取某个 Class 的 Schema:</p>
<pre><code class="lang-sh">curl -X GET \
   -H &quot;X-LC-Id: {{appid}}&quot; \
   -H &quot;X-LC-Key: {{masterkey}},master&quot; \
   https://{{v2Domain}}/1.1/schemas/_User
</code></pre>
<h2 id="-">云函数</h2>
<p>请查看我们的 <a href="leanengine-rest-api.html">云引擎 REST API 使用指南</a>。</p>
<h2 id="-">地理查询</h2>
<p>假如在发布微博的时候，我们也支持用户加上当时的位置信息（新增一个 <code>location</code> 字段），如果想看看指定的地点附近发生的事情，可以通过 GeoPoint 数据类型加上在查询中使用 <code>$nearSphere</code> 做到。获取离当前用户最近的 10 条微博应该看起来像下面这个样子:</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;limit=10&#39; \
  --data-urlencode &#39;where={
        &quot;location&quot;: {
          &quot;$nearSphere&quot;: {
            &quot;__type&quot;: &quot;GeoPoint&quot;,
            &quot;latitude&quot;: 39.9,
            &quot;longitude&quot;: 116.4
          }
        }
      }&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>这会按照距离纬度 39.9、经度 116.4（当前用户所在位置）的远近排序返回一系列结果，第一个就是最近的对象。(注意：<strong>如果指定了 order 参数的话，它会覆盖按距离排序。</strong>）</p>
<p>为了限定搜索的最大距离，需要加入 <code>$maxDistanceInMiles</code> 和 <code>$maxDistanceInKilometers</code>或者 <code>$maxDistanceInRadians</code> 参数来限定。比如要找的半径在 10 英里内的话：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={
        &quot;location&quot;: {
          &quot;$nearSphere&quot;: {
            &quot;__type&quot;: &quot;GeoPoint&quot;,
            &quot;latitude&quot;: 39.9,
            &quot;longitude&quot;: 116.4
          },
          &quot;$maxDistanceInMiles&quot;: 10.0
        }
      }&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<p>同样做查询寻找在一个特定的范围里面的对象也是可以的，为了找到在一个矩形的区域里的对象，按下面的格式加入一个约束 <code>{&quot;$within&quot;: {&quot;$box&quot;: [southwestGeoPoint, northeastGeoPoint]}}</code>。</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -G \
  --data-urlencode &#39;where={
        &quot;location&quot;: {
          &quot;$within&quot;: {
            &quot;$box&quot;: [
              {
                &quot;__type&quot;: &quot;GeoPoint&quot;,
                &quot;latitude&quot;: 39.97,
                &quot;longitude&quot;: 116.33
              },
              {
                &quot;__type&quot;: &quot;GeoPoint&quot;,
                &quot;latitude&quot;: 39.99,
                &quot;longitude&quot;: 116.37
              }
            ]
          }
        }
      }&#39; \
  https://{{v2Domain}}/1.1/classes/Post
</code></pre>
<h3 id="-">警告</h3>
<p>这是有一些问题是值得留心的:</p>
<ol>
<li>每一个 AVObject 类只能包含一个 AVGeoPoint 对象的键值。</li>
<li>Points 不应该等于或者超出它的界. 纬度不应该是 -90.0 或者 90.0，经度不应该是 -180.0 或者 180.0。试图在 GeoPoint 上使用超出范围内的经度和纬度会导致问题.</li>
</ol>
<h2 id="-api">用户反馈组件 API</h2>
<p>提交一条新的用户反馈：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
         &quot;status&quot;  : &quot;open&quot;,
         &quot;content&quot; : &quot;反馈的文字内容&quot;,
         &quot;contact&quot; : &quot;联系方式、QQ 或者邮箱手机等&quot;
       }&#39; \
  https://{{v2Domain}}/1.1/feedback
</code></pre>
<p>提交后的用户反馈在可以在 <a href="/dashboard/devcomponent.html?appid={{appid}}#/component/feedback">控制台 &gt;（选择应用）&gt; 组件 &gt; 用户反馈</a> 里看到。</p>
<p>获取所有的反馈：</p>
<pre><code>curl -X GET \
-H &quot;X-LC-Id:&quot; \
-H &quot;X-LC-Key:&quot; \
-H &quot;Content-Type: application/json&quot; \
https://{{v2Domain}}/1.1/feedback
</code></pre><p>获取一条反馈里面的信息：</p>
<pre><code>curl -X GET \
-H &quot;X-LC-Id:&quot; \
-H &quot;X-LC-Key:&quot; \
-H &quot;Content-Type: application/json&quot; \
https://{{v2Domain}}/1.1/feedback/&lt;:feedback_objectId&gt;/threads
</code></pre><p>将 <code>&lt;:feedback_objectId&gt;</code> 替换为 feedback 的 objectId（可以从上述的「获取所有的反馈」这个查询中得到 objectId）。 </p>
<p>客服为一条已经存在的反馈增加一条回复：</p>
<pre><code>curl -X POST \
-H &quot;X-LC-Id:&quot; \
-H &quot;X-LC-Key:&quot;\
 -H &quot;Content-Type: application/json&quot; \
-d &#39;{&quot;type&quot;:&quot;dev&quot;,&quot;content&quot;:&quot;感谢您的反馈！我们正在修复您所述的问题，修复后再通知您。&quot;, &quot;attachment&quot;:&quot;&quot;}&#39; \ 
https://{{v2Domain}}/1.1/feedback/&lt;:feedback_objectId&gt;/threads
</code></pre><p>用户为一条已经存在的反馈增加一条回复：</p>
<pre><code>curl -X POST \
-H &quot;X-LC-Id:&quot; \
-H &quot;X-LC-Key:&quot;\
 -H &quot;Content-Type: application/json&quot; \
-d &#39;{&quot;type&quot;:&quot;user&quot;,&quot;content&quot;:&quot;我刚才又试了下，现在没问题了！耶~&quot;, &quot;attachment&quot;:&quot;&quot;}&#39; \ 
https://{{v2Domain}}/1.1/feedback/&lt;:feedback_objectId&gt;/threads
</code></pre><h2 id="-api">短信验证 API</h2>
<p>请参考 <a href="rest_sms_api.html">短信服务 REST API 详解</a>。</p>
<h2 id="-api">实时通信 API</h2>
<p>请参考 <a href="./realtime_rest_api.html">实时通信 REST API</a>。</p>
<h2 id="-api">统计数据 API</h2>
<h3 id="-api">数据查询 API</h3>
<p>统计 API 可以获取一个应用的统计数据。因为统计数据的隐私敏感性，统计数据查询 API 必须使用 master key 的签名方式鉴权。</p>
<p>获取某个应用的基本信息，包括各平台的应用版本，应用发布渠道：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Sign: {{sign_masterkey}}&quot; \
  https://{{v2Domain}}/1.1/stats/appinfo
</code></pre>
<p>注意：上面示例直接使用了更加安全的 <a href="#更安全的鉴权方式">X-LC-Sign 鉴权方式</a>，避免以明文来传递 Key。</p>
<p>返回的 JSON 数据：</p>
<pre><code class="lang-json">{
  &quot;iOS&quot;: {
      &quot;versions&quot;: [&quot;2.3.10&quot;,&quot;2.3&quot;,&quot;2.4&quot;,&quot;2.5&quot;,&quot;2.6&quot;,&quot;2.7&quot;,&quot;2.8&quot;,&quot;2.6.1&quot;],
      &quot;channels&quot;: [&quot;App Store&quot;]
  },
  &quot;Android&quot;: {
      &quot;versions&quot;: [&quot;1.7.2.1&quot;,&quot;1.4.0&quot;,&quot;1.5.0&quot;,&quot;1.6.0&quot;,&quot;1.5.1&quot;,&quot;1.7.0&quot;,&quot;1.6.1&quot;,&quot;1.8.0&quot;,&quot;1.7.1&quot;,&quot;1.8.1&quot;,&quot;1.7.2&quot;,&quot;1.8.2&quot;],
      &quot;channels&quot;: []
  }
}
</code></pre>
<p>获取某个应用的具体统计数据</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  &quot;https://{{v2Domain}}/1.1/stats/appmetrics?platform=iOS&amp;start=20140301&amp;end=20140315&amp;metrics=active_user&quot;
</code></pre>
<p>具体支持的参数：</p>
<table>
  <tr><th>参数名</th><th>含义</th></tr>
  <tr><td>start</td><td>开始日期（yyyyMMdd）</td></tr>
  <tr><td>end</td><td>结束日期（yyyyMMdd）</td></tr>
  <tr><td>metrics</td><td>统计数据项</td></tr>
  <tr><td>platform</td><td>应用平台：iOS、Android，可选，默认是全部。</td></tr>
  <tr><td>appversion</td><td>选择应用版本，可选，默认是全部。一次取多个版本数据半角逗号（,）分隔，如：1.0,2.0,2.5</td></tr>
  <tr><td>channel</td><td>选择发布渠道，可选，默认是全部。一次取多个渠道数据请用半角逗号（,）分隔，如：Xiaomi,Meizu</td></tr>
  <tr><td>conv_id</td><td>选择对话 ID，可选，只在查询实时通信某个对话相关的统计信息时使用</td></tr>
</table>

<p>metrics 参数可选项解释：</p>
<table>
  <tr><th>参数值</th><th>含义</th></tr>
  <tr><td>accumulate_user</td><td>累计用户数</td></tr>
  <tr><td>new_user</td><td>新增用户数</td></tr>
  <tr><td>active_user</td><td>活跃用户数</td></tr>
  <tr><td>session</td><td>启动次数</td></tr>
  <tr><td>new_user_hour</td><td>新增用户数（按小时查看）</td></tr>
  <tr><td>active_user_hour</td><td>活跃用户数（按小时查看）</td></tr>
  <tr><td>session_hour</td><td>启动次数（按小时查看）</td></tr>
  <tr><td>wau</td><td>周活跃用户数</td></tr>
  <tr><td>mau</td><td>月活跃用户数</td></tr>
  <tr><td>avg_user_time</td><td>日平均用户使用时长</td></tr>
  <tr><td>avg_session_time</td><td>日次均使用时长</td></tr>
  <tr><td>avg_page_count</td><td>日均访问页面数</td></tr>
  <tr><td>retention_n</td><td>n 天后的存留用户数（n 可取值：1-7、14、30 如 retention_1）</td></tr>
  <tr><td>push_login</td><td>推送用户数</td></tr>
  <tr><td>push_ack</td><td>推送到达数</td></tr>
  <tr><td>push_session</td><td>聊天用户数</td></tr>
  <tr><td>push_direct</td><td>聊天消息数</td></tr>
  <tr><td>active_user_locations</td><td>活跃用户所在地</td></tr>
  <tr><td>new_user_locations</td><td>新用户所在地</td></tr>
  <tr><td>device_os</td><td>设备系统版本</td></tr>
  <tr><td>device_model</td><td>设备型号</td></tr>
  <tr><td>device_network_access</td><td>设备网络接入方式</td></tr>
  <tr><td>device_network_carrier</td><td>设备网络运营商</td></tr>
  <tr><td>device_resolution</td><td>设备分辨率</td></tr>
  <tr><td>page_visit</td><td>页面访问量</td></tr>
  <tr><td>page_duration</td><td>页面停留时间</td></tr>
  <tr><td>active_user_freq_histo</td><td>活跃用户使用次数分布</td></tr>
  <tr><td>new_user_freq_histo</td><td>新用户使用次数分布</td></tr>
  <tr><td>active_user_time_histo</td><td>活跃用户使用时长分布</td></tr>
  <tr><td>new_user_time_histo</td><td>新用户使用时长分布</td></tr>
  <tr><td>session_time_histo</td><td>单次启动时长分布</td></tr>
  <tr><td>event_count</td><td>自定义事件次数，请求参数需增加 event 参数。</td></tr>
  <tr><td>event_user</td><td>自定义事件用户数，请求参数需增加 event 参数。</td></tr>
  <tr><td>event_duration</td><td>自定义事件时长，请求参数需增加 event 参数。</td></tr>
  <tr><td>event_label_count</td><td>自定义事件标签分布，请求参数需增加 event， event_label 参数。</td></tr>
  <tr><td>rtm_tr_sender</td><td>单日某暂态对话内有发出过消息的独立用户数，请求参数需增加 conv_id 参数。</td></tr>
  <tr><td>rtm_tr_msg_down</td><td>单日某暂态对话下行消息总数，请求参数需增加 conv_id 参数。</td></tr>
  <tr><td>rtm_tr_msg_up</td><td>单日某暂态对话的上行消息总数，请求参数需增加 conv_id 参数。</td></tr>
  <tr><td>rtm_tr_conv_m</td><td>单日加入某暂态对话的独立用户数，请求参数需增加 conv_id 参数。</td></tr>
</table>

<p>返回的json数据</p>
<pre><code class="lang-json">{
  &quot;data&quot;: {
    &quot;2014-03-01&quot;: 270,
    &quot;2014-03-02&quot;: 275,
    &quot;2014-03-03&quot;: 238,
    &quot;2014-03-04&quot;: 259,
    &quot;2014-03-05&quot;: 246,
    &quot;2014-03-06&quot;: 306,
    &quot;2014-03-07&quot;: 362,
    &quot;2014-03-08&quot;: 347,
    &quot;2014-03-09&quot;: 381,
    &quot;2014-03-10&quot;: 255,
    &quot;2014-03-11&quot;: 233,
    &quot;2014-03-12&quot;: 232,
    &quot;2014-03-13&quot;: 227,
    &quot;2014-03-14&quot;: 215,
    &quot;2014-03-15&quot;: 222
  },
  &quot;metrics&quot;: &quot;new_user&quot;
}
</code></pre>
<p>获取某个应用的实时统计数据：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  &quot;https://{{v2Domain}}/1.1/stats/rtmetrics?platform=iOS&amp;metrics=current_active&quot;
</code></pre>
<p>具体支持的参数：</p>
<table>
  <tr><th>参数名</th><th>含义</th></tr>
  <tr><td>metrics</td><td>统计数据项</td></tr>
  <tr><td>platform</td><td>应用平台：iOS、Android，可选，默认是全部。</td></tr>
</table>

<p>metrics参数可选项解释：</p>
<table>
  <tr><th>参数值</th><th>含义</th></tr>
  <tr><td>current_active</td><td>活跃用户数</td></tr>
  <tr><td>30min_active</td><td>近 30 分钟的活跃用户数</td></tr>
  <tr><td>pages</td><td>用户停留页面</td></tr>
  <tr><td>events</td><td>用户触发事件</td></tr>
  <tr><td>locations</td><td>用户所在地</td></tr>
</table>

<p>返回数据</p>
<pre><code class="lang-json">{data:97, metrics:&quot;current_active&quot;}

{data:[1,3,5,..], metrics:&quot;30min_active&quot;}

{data:[{name:&quot;pageA&quot;, count:3}, {name:&quot;pageB&quot;,count:2}, ...], metrics:&quot;pages&quot;}

{data:[{name:&quot;eventA&quot;, count:3}, {name:&quot;eventB&quot;,count:2}, ...], metrics:&quot;events&quot;}

{data:[{location:&quot;上海&quot;, count:3}, {location:&quot;江苏&quot;, count:2}, ...], metrics:&quot;locations&quot;}
</code></pre>
<p>批量获取：</p>
<p>当需要批量获取统计数据时，可以将多个 metrics 值用半角逗号拼接传入，返回结果将是一个数组，结果值和参数值次序对应，例如：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  &quot;https://{{v2Domain}}/1.1/stats/appmetrics?platform=iOS&amp;start=20140301&amp;end=20140315&amp;metrics=new_user,retention_1&quot;
</code></pre>
<p>将返回</p>
<pre><code class="lang-json">[
  {&quot;data&quot;:
    {&quot;2014-03-01&quot;:371,
     &quot;2014-03-02&quot;:493,
     &quot;2014-03-03&quot;:400,
     &quot;2014-03-04&quot;:407,
     &quot;2014-03-05&quot;:383,
     &quot;2014-03-06&quot;:377,
     &quot;2014-03-07&quot;:416,
     &quot;2014-03-08&quot;:425,
     &quot;2014-03-09&quot;:434,
     &quot;2014-03-10&quot;:364,
     &quot;2014-03-11&quot;:434,
     &quot;2014-03-12&quot;:416,
     &quot;2014-03-13&quot;:400,
     &quot;2014-03-14&quot;:394},
    &quot;metrics&quot;:&quot;active_user&quot;,
  {&quot;data&quot;:
    {&quot;2014-03-01&quot;:10,
     &quot;2014-03-02&quot;:5,
     &quot;2014-03-03&quot;:10,
     &quot;2014-03-04&quot;:4,
     &quot;2014-03-05&quot;:6,
     &quot;2014-03-06&quot;:7,
     &quot;2014-03-07&quot;:6,
     &quot;2014-03-08&quot;:6,
     &quot;2014-03-09&quot;:4,
     &quot;2014-03-10&quot;:6,
     &quot;2014-03-11&quot;:6,
     &quot;2014-03-12&quot;:7,
     &quot;2014-03-13&quot;:3,
     &quot;2014-03-14&quot;:7},
     &quot;metrics&quot;:&quot;retention_1&quot;}]
</code></pre>
<p>获取统计在线参数，可以获取发送策略，是否开启的设置情况，和自定义的在线配置参数。</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  https://{{v2Domain}}/1.1/statistics/apps/{{appid}}/sendPolicy
</code></pre>
<p>返回结果：</p>
<pre><code class="lang-json">{
  &quot;policy&quot;:6, // 发送策略
  &quot;enable&quot;:true, // 是否开启
  &quot;parameters&quot;:{ // 自定义在线参数
    &quot;showBeauty&quot;:&quot;1&quot;
  }
}
</code></pre>
<h3 id="-api">统计数据收集 API</h3>
<p>格式概览如下：</p>
<pre><code>curl -i -X POST \
-H &quot;Content-Type: application/json&quot; \
-H &quot;X-LC-Id: {{appid}}&quot; \
-H &quot;X-LC-Key: {{appkey}}&quot; \
-d \
&#39;{
  &quot;client&quot;: {
    &quot;id&quot;:&quot;vdkGm4dtRNmhQ5gqUTFBiA&quot;,
    &quot;platform&quot;: &quot;iOS&quot;,
    &quot;app_version&quot;: &quot;1.0&quot;,
    &quot;app_channel&quot;: &quot;App Store&quot;
  },
  &quot;session&quot;: {
    &quot;id&quot;:&quot;Q5tYi4BTQ5i3Xuycgr7l&quot;
  },
  &quot;events&quot;: [
    {
      &quot;event&quot;: &quot;_page&quot;,
      &quot;duration&quot;: 2000,
      &quot;tag&quot;: &quot;BookDetail&quot;
    },
    {
      &quot;event&quot;: &quot;buy-item&quot;,
      &quot;attributes&quot;: {&quot;item-category&quot;: &quot;book&quot;}
    },
    {
      &quot;event&quot;: &quot;_session.close&quot;,
      &quot;duration&quot;: 10000
    }
  ]
 }&#39; \
https://{{v2Domain}}/1.1/stats/open/collect
</code></pre><p>统计发送的数据格式包括 3 个节点。</p>
<h4 id="client-">client 节点</h4>
<p>包括了用户设备和应用的相关信息，这个节点是必选节点。有了这个节点的数据就可以统计出每天的新增、活跃和累计用户，以及用户留存率、流失率等关键数据。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>约束</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>必选</td>
<td>用户的唯一 id，这是由  SDK 从系统中获取的设备 ID（系统将根据这个 id 来区分新增用户、活跃用户、累计用户等用户相关数据）</td>
</tr>
<tr>
<td>platform</td>
<td>可选</td>
<td>应用的平台（例如 iOS、Android 等）</td>
</tr>
<tr>
<td>app_version</td>
<td>可选</td>
<td>应用的版本</td>
</tr>
<tr>
<td>app_channel</td>
<td>可选</td>
<td>应用的发布渠道</td>
</tr>
<tr>
<td>os_version</td>
<td>可选</td>
<td>系统版本</td>
</tr>
<tr>
<td>device_brand</td>
<td>可选</td>
<td>设备品牌</td>
</tr>
<tr>
<td>device_model</td>
<td>可选</td>
<td>设备型号</td>
</tr>
<tr>
<td>device_resolution</td>
<td>可选</td>
<td>设备分辨率</td>
</tr>
<tr>
<td>network_access</td>
<td>可选</td>
<td>网络类型</td>
</tr>
<tr>
<td>network_carrier</td>
<td>可选</td>
<td>移动网络运营商</td>
</tr>
</tbody>
</table>
<h4 id="session-">session 节点</h4>
<p>包含了用户一次启动的数据信息，这个节点是可选节点。有了这个节点的数据，可以统计出用户每天使用应用的频率相关的数据。</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>约束</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>必选</td>
<td>应用一次使用就产生唯一的一个 id</td>
</tr>
</tbody>
</table>
<h4 id="events-">events 节点</h4>
<p>包含了自定义事件和预定义事件，是一个数组，其中每个元素的结构为：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>约束</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>event</td>
<td>必选</td>
<td>事件名称</td>
</tr>
<tr>
<td>attributes</td>
<td>可选</td>
<td>事件属性：包含一个 key-value 的字典。</td>
</tr>
<tr>
<td>duration</td>
<td>可选</td>
<td>事件持续时长</td>
</tr>
<tr>
<td>tag</td>
<td>可选</td>
<td>事件属性的简写方式，等同于属性里面添加：<code>{event: tag}</code> 这个元素。</td>
</tr>
</tbody>
</table>
<h4 id="-">预定义的事件</h4>
<h5 id="-">页面访问</h5>
<pre><code>{
  &quot;event&quot;: &quot;_page&quot;, // 必须为 _page 表示一次页面访问
  &quot;duration&quot;: 100000, // 页面停留时间，单位毫秒
  &quot;tag&quot;: &quot;HomePage&quot; // 页面名称
}
</code></pre><h5 id="session-">session 结束</h5>
<pre><code>{
  &quot;event&quot;: &quot;_session.close&quot;, //必须为 _session.close 表示一次使用结束
  &quot;duration&quot;: 60000 // 使用时长，单位毫秒
}
</code></pre><h2 id="-api">事件流 API</h2>
<p>请参考 <a href="./status_system.html#REST_API">事件流 REST API</a>。</p>
<h2 id="-api">应用内搜索 API</h2>
<p>请参考 <a href="./app_search_guide.html#搜索_api">搜索 API</a>。</p>
<h2 id="-api">数据导出 API</h2>
<p>你可以通过请求 <code>/exportData</code> 来导出应用数据：</p>
<pre><code>curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{}&#39; \
  https://{{v2Domain}}/1.1/exportData
</code></pre><p><code>exportData</code> 要求使用 master key 来授权。</p>
<p>你还可以指定导出数据的起始时间：</p>
<pre><code>curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;from_date&quot;:&quot;2015-09-20&quot;, &quot;to_date&quot;:&quot;2015-09-25&quot;}&#39; \
  https://{{v2Domain}}/1.1/exportData
</code></pre><p>还可以指定具体的 class 列表，使用逗号隔开：</p>
<pre><code>curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;classes&quot;:&quot;_User,GameScore,Post&quot;}&#39; \
  https://{{v2Domain}}/1.1/exportData
</code></pre><p>增加 <code>only-schema</code> 选项就可以只导出 schema:</p>
<pre><code>curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;only-schema&quot;:&quot;true&quot;}&#39; \
  https://{{v2Domain}}/1.1/exportData
</code></pre><p>导出的 Schema 文件同样可以使用数据导入功能来导入到其他应用。</p>
<p>默认导出的结果将发送到应用的创建者邮箱，你也可以指定接收邮箱：</p>
<pre><code>curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;email&quot;:&quot;username@exmaple.com&quot;}&#39; \
  https://{{v2Domain}}/1.1/exportData
</code></pre><p>调用结果将返回本次任务的 id 和状态：</p>
<pre><code class="lang-json">{
  &quot;status&quot;:&quot;running&quot;,
  &quot;id&quot;:&quot;1wugzx81LvS5R4RHsuaeMPKlJqFMFyLwYDNcx6LvCc6MEzQ2&quot;,
  &quot;app_id&quot;:&quot;{{appid}}&quot;
}
</code></pre>
<p>除了被动等待邮件之外，你还可以主动使用 id 去查询导出任务状态：</p>
<pre><code>curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  https://{{v2Domain}}/1.1/exportData/1wugzx81LvS5R4RHsuaeMPKlJqFMFyLwYDNcx6LvCc6MEzQ2
</code></pre><p>如果导出完成，将返回导出结果的下载链接：</p>
<pre><code class="lang-json">{
  &quot;status&quot;:&quot;done&quot;,
  &quot;download_url&quot;: &quot;https://download.leancloud.cn/export/example.tar.gz&quot;,
  &quot;id&quot;:&quot;1wugzx81LvS5R4RHsuaeMPKlJqFMFyLwYDNcx6LvCc6MEzQ2&quot;,
  &quot;app_id&quot;:&quot;{{appid}}&quot;
}
</code></pre>
<p>如果任务还没有完成， <code>status</code> 仍然将为 <code>running</code> 状态，<strong>请间隔一段时间后再尝试查询。</strong></p>
<h2 id="-api">其他 API</h2>
<h3 id="-">服务器时间</h3>
<p>获取服务端当前日期时间可以通过 <code>/date</code> API:</p>
<pre><code>curl -i -X GET \
    -H &quot;X-LC-Id: {{appid}}&quot; \
    -H &quot;X-LC-Key: {{appkey}}&quot; \
    https://{{v2Domain}}/1.1/date
</code></pre><p>返回 UTC 日期:</p>
<pre><code class="lang-json">{
  &quot;iso&quot;: &quot;2015-08-27T07:38:33.643Z&quot;,
  &quot;__type&quot;: &quot;Date&quot;
}
</code></pre>
<h2 id="-api">离线数据分析 API</h2>
  <div class="callout callout-danger">
  <p>该项功能仅向<strong>商业版</strong>和<strong>企业版</strong>应用开放。因此，开发版应用如果调用该 API 会收到错误响应。</p>
</div>


<h3 id="-job-api">创建分析 job API</h3>
<p>离线数据分析 API 可以获取一个应用的备份数据。因为应用数据的隐私敏感性，离线数据分析 API 必须使用 master key 的签名方式鉴权，请参考 <a href="#更安全的鉴权方式">更安全的鉴权方式</a> 一节。</p>
<p>创建分析 job。（注意：下面示例直接使用带 <code>master</code> 标识的 <code>X-LC-Key</code>，不过我们推荐你在实际使用中采用 <a href="rest_api.html#更安全的鉴权方式">新鉴权方式</a> 加密，不要明文传递 Key。）</p>
<pre><code>curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;jobConfig&quot;:{&quot;sql&quot;:&quot;select count(*) from table&quot;}}&#39; \
  https://{{v2Domain}}/1.1/bigquery/jobs
</code></pre><p>需要特别说明的是，<code>jobConfig</code> 不仅可以提供查询分析 <code>sql</code>，还可以增加其他配置项：</p>
<ul>
<li>查询结果自动另存为：</li>
</ul>
<pre><code class="lang-json">{
  &quot;jobConfig&quot;:{
    &quot;sql&quot;:&quot;select count(*) as count from table&quot;,
    &quot;saveAs&quot;:{
      &quot;className&quot;:&quot;Table1&quot;,
      &quot;limit&quot;:100
    }
  }
}
</code></pre>
<ul>
<li>设置依赖 job，也就是当前的查询可以使用前趋查询结果：</li>
</ul>
<pre><code>{
  &quot;jobConfig&quot;:{
    &quot;sql&quot;:&quot;select * from table inner join tempTable on table.id=tempTable.objectId&quot;,
    &quot;dependencyJobs&quot;:[
      {
        &quot;id&quot;:&quot;xxx&quot;,
        &quot;className&quot;:&quot;tempTable&quot;
      } // id 为依赖 job 的 jobId,  className 则为自定义的临时表名
    ]
  }
}
</code></pre><p>对应的输出：</p>
<pre><code>HTTP/1.1 200 OK
Server Tengine is not blacklisted
Server: Tengine
Date: Fri, 05 Jun 2015 02:45:22 GMT
Content-Type: application/json; charset=UTF-8
Content-Length: 100
Connection: keep-alive
Strict-Transport-Security: max-age=31536000
{&quot;id&quot;:&quot;63f3b70b8ac3fd779de5bcb765cf121e&quot;,&quot;appId&quot;:&quot;{{appid}}&quot;}
</code></pre><h3 id="-job-api">获取分析 job 结果 API</h3>
<pre><code>curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{masterkey}},master&quot; \
  -H &quot;Content-Type: application/json&quot; \
  https://{{v2Domain}}/1.1/bigquery/jobs/:jobId
</code></pre><p>对应的输出：</p>
<pre><code>HTTP/1.1 200 OK
Server Tengine is not blacklisted
Server: Tengine
Date: Fri, 05 Jun 2015 03:03:51 GMT
Content-Type: application/json; charset=UTF-8
Content-Length: 127
Connection: keep-alive
Strict-Transport-Security: max-age=31536000
{&quot;id&quot;:&quot;63f3b70b8ac3fd779de5bcb765cf121e&quot;,&quot;status&quot;:&quot;OK&quot;,&quot;results&quot;:[{&quot;_c0&quot;:6895}],&quot;totalCount&quot;:1,&quot;previewCount&quot;:1,&quot;nextAnchor&quot;:1}
</code></pre><h2 id="-">浏览器跨域和特殊方法解决方案</h2>
<p>注：直接使用 RESTful API 遇到跨域问题，请遵守 HTML5 CORS 标准即可。以下方法非推荐方式，而是内部兼容方法。</p>
<p>对于跨域操作，我们定义了如下的 text/plain 数据格式来支持用 POST 的方法实现 GET、PUT、DELETE 的操作。</p>
<h3 id="get">GET</h3>
<pre><code>  curl -i -X POST \
  -H &quot;Content-Type: text/plain&quot; \
  -d \
  &#39;{&quot;_method&quot;:&quot;GET&quot;,
    &quot;_ApplicationId&quot;:&quot;{{appid}}&quot;,
    &quot;_ApplicationKey&quot;:&quot;{{appkey}}&quot;}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre><p>对应的输出：</p>
<pre><code>HTTP/1.1 200 OK
Server: nginx
Date: Thu, 04 Dec 2014 06:34:34 GMT
Content-Type: application/json;charset=utf-8
Content-Length: 174
Connection: keep-alive
Last-Modified: Thu, 04 Dec 2014 06:34:08.498 GMT
Cache-Control: no-cache,no-store
Pragma: no-cache
Strict-Transport-Security: max-age=31536000
{
  &quot;content&quot;: &quot;每个 Java 程序员必备的 8 个开发工具&quot;,
  &quot;pubUser&quot;: &quot;LeanCloud官方客服&quot;,
  &quot;pubTimestamp&quot;: 1435541999,
  &quot;createdAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
  &quot;updatedAt&quot;: &quot;2015-06-29T01:39:35.931Z&quot;,
  &quot;objectId&quot;: &quot;558e20cbe4b060308e3eb36c&quot;
}
</code></pre><h3 id="put">PUT</h3>
<pre><code>curl -i -X POST \
  -H &quot;Content-Type: text/plain&quot; \
  -d \
  &#39;{&quot;_method&quot;:&quot;PUT&quot;,
    &quot;_ApplicationId&quot;:&quot;{{appid}}&quot;,
    &quot;_ApplicationKey&quot;:&quot;{{appkey}}&quot;,
    &quot;upvotes&quot;:99}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre><p>对应的输出：</p>
<pre><code>HTTP/1.1 200 OK
Server: nginx
Date: Thu, 04 Dec 2014 06:40:38 GMT
Content-Type: application/json;charset=utf-8
Content-Length: 78
Connection: keep-alive
Cache-Control: no-cache,no-store
Pragma: no-cache
Strict-Transport-Security: max-age=31536000

{&quot;updatedAt&quot;:&quot;2015-07-13T06:40:38.310Z&quot;,&quot;objectId&quot;:&quot;558e20cbe4b060308e3eb36c&quot;}
</code></pre><h3 id="delete">DELETE</h3>
<pre><code>curl -i -X POST \
  -H &quot;Content-Type: text/plain&quot; \
  -d \
  &#39;{&quot;_method&quot;:  &quot;DELETE&quot;,
    &quot;_ApplicationId&quot;:&quot;{{appid}}&quot;,
    &quot;_ApplicationKey&quot;:&quot;{{appkey}}&quot;}&#39; \
  https://{{v2Domain}}/1.1/classes/Post/558e20cbe4b060308e3eb36c
</code></pre><p>对应的输出是：</p>
<pre><code>HTTP/1.1 200 OK
Server: nginx
Date: Thu, 04 Dec 2014 06:15:10 GMT
Content-Type: application/json;charset=utf-8
Content-Length: 2
Connection: keep-alive
Cache-Control: no-cache,no-store
Pragma: no-cache
Strict-Transport-Security: max-age=31536000

{}
</code></pre><p>总之，就是利用 POST 传递的参数，把 _method、_ApplicationId 以及 _ApplicationKey 传递给服务端，服务端会自动把这些请求翻译成指定的方法，这样可以使得 Unity3D 以及 JavaScript 等平台（或者语言）可以绕开浏览器跨域或者方法限制。</p>


      </div>
    </div>
    <!-- .col-md-9 -->
  </div>
  <!-- .row -->

</div>
<!-- .container-fluid -->
<div id="comment-container" ng-class="{'no-comments': currentComments.length<1}">
  <div class="comment-head">
    {{allComment[version]}}
    <span class="close" ng-click="closeCommentModal()">&times;</span>
  </div>
  <div class="comment-body">
    <div class="comment-list" ng-class="{'no-login': !currentCommentUser.username}">
      <ul>
        <li ng-show="currentComments.length<1">暂无评论</li>
        <li ng-repeat="comment in currentComments">
          <div class="comment-author">{{comment.author}}</div>
          <div class="comment-timestamp">{{ comment.createdAt | date: 'yyyy-MM-dd HH:mm:ss '}}</div>
          <div class="comment-content">{{comment.content}}</div>
        </li>
      </ul>
    </div>
  </div>
  <div class="comment-compose" ng-show="currentCommentUser.username">
    <div class="form-group"> <textarea class="form-control comment-content" ng-model="commentContent"></textarea></div>
    <div class="form-meta">
      <!-- 您已登录为 <b>{{currentCommentUser.username}}</b> -->
      <button class="btn btn-sm btn-default create-comment pull-right" ng-click="createComment($event)">
        <i class="icon icon-chat-bold"></i> 评论
      </button>
    </div>
  </div>
  <div class="comment-compose no-login" ng-show="!currentCommentUser.username">
    您需要 <a class="comment-login" ng-click="loginComment()">授权</a> 后才能评论
  </div>
</div>

<script src="https://download.leancloud.cn/sdk/latest.js"></script>


<script src="custom/js/lib/contents.js"></script>
<script src="custom/js/md.js"></script>


<script type="text/javascript">
ZeroClipboard.setDefaults({
    moviePath: 'custom/js/lib/zeroclipboard/zeroclipboard.swf'
});
$(function(){
    // $('#content [version]').each(function(k,v){
    //     var version = $(v).attr('version');
    //     $(v).append('<div class="toggle-comment" ng-click="showCommentDialog(\''+version+'\''+',$event)">+ <span> {{}}</span> </div>');
    // })

    $('#content [version]').each(function(k,v){
        var version = $(v).attr('version');
        $(v).append('<div class="inline-comment-wrap" version="'+version+'" all-comment="allComment" showDialogMethod="showCommentDialog()" lc-comment> </div>');
    });

    angular.element(document).ready(function() {

      angular.bootstrap(document, ['app']);

    });
});

</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42629236-7', 'auto');
  ga('send', 'pageview');

</script>





  <footer class="footer" role="contentinfo">
  <div class="container-fluid">
    <!-- <a href="http://leancloud.cn/" class="logo font-logo pull-left">
      LeanCloud
    </a> -->

    <ul class="footer-links pull-right">
      <li class="muted">·</li>
      <li><a href="/pricing">价格</a></li>
      <li class="muted">·</li>
      <li><a href="/docs/sdk_down.html">下载</a></li>
      <!-- <li class="muted">·</li>
      <li><a href="/apps.html" target="_self">App</a></li> -->
      <li class="muted">·</li>
      <li><a href="http://leancloud.cn/docs/faq.html" target="_self">常见问题</a></li>
      <li class="muted">·</li>
      <li><a href="http://leanticket.cn" target="_self"><span class="mobile-hide">技术</span>支持</a></li>
      <!-- <li><a href="http://ticket.leancloud.cn/tickets?token={{user.session_token || 'Gs5Xw4vjyCznrP6OcgMheOWDuatVpbFPiL78eMo6JC0dENB8'}}" target="_blank"><span class="mobile-hide">用户</span>反馈</a></li> -->
      <li class="muted">·</li>
      <li><a href="https://status.leancloud.cn/"><span class="mobile-hide">健康</span>状态</a></li>
      <li class="muted">·</li>
      <li><a href="http://forum.leancloud.cn/">社区</a></li>
      <li class="muted">·</li>
      <li><a href="http://blog.leancloud.cn/">Blog</a></li>
      <li class="muted">·</li>
      <li><a href="https://github.com/leancloud/docs">文档源码</a></li>
    </ul>
  </div>
</footer>



</body>

</html>
