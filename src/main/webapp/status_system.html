<!doctype html>

<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>应用内社交模块 - LeanCloud 文档</title>
<!-- build:js custom/js/docs-all.js -->
<script src="custom/js/lib/jquery.min.js"></script>
<script src="custom/js/lib/bootstrap.min.js"></script>
<script src="custom/js/lib/bootstrap-hover-dropdown.js"></script>
<script src="custom/js/lib/pretty/prettify.js"></script>
<script src="custom/js/lib/jquery.scrollTo.min.js"></script>
<script src="custom/js/lib/angular/angular.min.js"></script>
<script src="custom/js/lib/zeroclipboard/zeroclipboard.js"></script>
<script src="custom/js/lib/markdown.min.js"></script>
<script src="custom/js/lib/md5.js"></script>

<script src="custom/js/lib/angular-gravatar.js"></script>
<script src="custom/js/prepare-dom.js"></script>
<script src="custom/js/app.js"></script>
<script src="custom/js/common.js"></script>
<script src="custom/js/demo.js"></script>
<script src="custom/js/weapp-domains.js"></script>
<!-- endbuild -->

<script type="text/javascript">
      var _vds = _vds || [];
      window._vds = _vds;
      (function(){
        _vds.push(['setAccountId', 'a268202b003f2516']);
        (function() {
          var vds = document.createElement('script');
          vds.type='text/javascript';
          vds.async = true;
          vds.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'dn-growing.qbox.me/vds.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(vds, s);
        })();
      })();
  </script>

<link rel="stylesheet" type="text/css" href="custom/css/app-docs.css?githubv1">


</head>


<body class="dashboard-init" data-offset="0" ng-cloak="" ng-controller="AppCtrl">




  <nav class="dashboard-subnav navbar navbar-default navbar-static-top" role="navigation">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#app-options" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand nav-logo font-logo" title="LeanCloud 官网">LeanCloud</a>
    </div>

    <div class="collapse navbar-collapse" id="app-options">
      <!-- <ul class="nav navbar-nav navbar-app-select">
        <li>
          <a href="/dashboard/applist.html" class="nav-logo font-logo" title="LeanCloud 控制台">LeanCloud</a>
        </li>
      </ul> -->
      <div class="navbar-app-actions-wrap">
        <ul class="nav navbar-nav navbar-app-actions">
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="index.html">
              <i class="icon icon-dashbd-icon icon-home"></i>
              <div class="name">文档首页</div>
            </a>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="sdk_down.html" title="SDK 下载">
              <i class="icon icon-dashbd-icon icon-package"></i>
              <div class="name"><span class="mobile-hide">SDK </span>下载</div>
            </a>
          </li>
          <li class="dropdown dropdown-toggle-app-name">
            <a href="demo.html" title="Demos">
              <i class="icon icon-dashbd-icon icon-magic"></i>
              <div class="name">Demos</div>
            </a>
          </li>
          <li class="dropdown dropdown-toggle-app-name">
            <a class="nav-key-6 dropdown-toggle" title="API Docs" data-toggle="dropdown">
              <i class="icon icon-dashbd-icon icon-log"></i>
              <div class="name">API 文档</div>
            </a>
            <ul class="dropdown-menu">
            <li><a href="/api-docs/android/index.html" target="_blank">Android SDK API</a></li>
<li><a href="/api-docs/iOS/index.html" target="_blank">Objective-C SDK API</a></li>
<li><a href="https://leancloud.github.io/javascript-sdk/docs/" target="_blank">JavaScript 数据存储 SDK API</a></li>
<li><a href="https://leancloud.github.io/js-realtime-sdk/docs/" target="_blank">JavaScript 实时通信 SDK API</a></li>
<li><a href="https://leancloud.readthedocs.io/">Python SDK API</a></li>
<li><a href="/api-docs/php/" target="_blank">PHP SDK API</a></li>
<li><a href="/api-docs/dotnet/Help/index.html">.NET SDK API</a></li>

            </ul>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="opencourse.html">
              <i class="icon icon-dashbd-icon icon-play"></i>
              <div class="name">公开课</div>
            </a>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a class="nav-key-6 dropdown-toggle" title="帮助" data-toggle="dropdown">
              <i class="icon icon-dashbd-icon icon-question"></i>
              <div class="name">帮助</div>
            </a>
            <ul class="dropdown-menu">
              <li><a href="https://leanticket.cn/t/leancloud">技术支持</a></li>
              <li><a href="http://forum.leancloud.cn">社区</a></li>
              <li><a href="http://blog.leancloud.cn/">Blog</a></li>
              <li role="presentation" class="divider"></li>
              <li><a href="/dashboard/apionline/index.html">在线 API 工具</a></li>
              <li role="presentation" class="divider"></li>
              <!-- <li><a href="/apps.html">LeanCloud App</a></li> -->
              <li><a href="/pricing">价格</a></li>
              <!-- <li><a href="#" data-toggle="modal" data-target="#modal-shortcuts">快捷键</a></li> -->
            </ul>
          </li>
        </ul>
        <!-- hide search input on the home page -->
        
          <form role="search" action="/search.html" method="get">
            <div class="app-search">
              <input name="q" type="text" class="form-control" placeholder="搜索文档&hellip;">
            </div>
          </form>
        
      </div>

      <ul class="nav navbar-nav navbar-user-actions navbar-right" ng-cloak="">

        <li class="dropdown" ng-show="user.username">
          <a role="button" class="dropdown-toggle user-name" data-toggle="dropdown">
            <span class="user-gravatar">
              <img gravatar-src="user.email" gravatar-size="64">
            </span>
            <span class="user-name-text">{{user.username}}</span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/settings.html">账号设置</a></li>
            <li><a href="/applist.html">控制台</a></li>
            
            <li><a href="/settings.html#/setting/team">团队管理</a></li>
            
            <li><a href="/bill.html#/bill/general">财务</a></li>
            <!-- <li><a href="settings.html#/setting/invite">邀请好友</a></li> -->
            <li ng-show="user.username" style=""><a ng-click="signout()">登出</a></li>
          </ul>
        </li>
        <li ng-hide="user.username">
          <a href="/login.html#/signin">登录</a>
        </li>
        <li ng-hide="user.username">
          <a href="/login.html#/signup">注册</a>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div>
  <!-- .container-fluid -->
</nav>



<header class="doc-subnav" role="banner">
  <div class="container-fluid">
    <nav class="" role="navigation">
      <ul class="nav navbar-nav">
        
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">功能概览</a>
          <ul class="dropdown-menu">
            <li><a href="storage_overview.html">数据存储服务总览</a></li>
            <li><a href="leanengine_overview.html">云引擎总览</a></li>
            <li><a href="push_guide.html">消息推送服务总览</a></li>
            <li><a href="realtime_v2.html">实时通信服务总览</a></li>
            <li><a href="dashboard_guide.html">控制台使用指南</a></li>
            <li><a href="data_security.html">数据安全</a></li>
            <li><a href="error_code.html">错误码详解</a></li>
            <li><a href="faq.html">常见问题</a></li>
            <li><a href="tool_tips.html">常见功能提示</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Objective-C</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-objc.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-objc.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-objc.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="ios_push_guide.html">消息推送开发指南</a></li>
            <li><a href="ios_push_cert.html">iOS 推送证书设置指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-objc.html">实时通信开发指南</a></li>
            <li><a href="chatkit-ios.html">ChatKit 使用指南</a></li>
            <li><a href="livekit-ios.html">LiveKit 使用指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            <li><a href="ios_statistics.html">统计分析开发指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="ios_crashreporting_guide.html">崩溃报告使用指南</a></li>
            <li><a href="ios-macos-faq.html">FAQ</a></li>
            <li><a href="/api-docs/iOS/index.html" target="_blank">SDK API</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Swift</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-swift.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-swift.html">数据存储开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Android</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-android.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-android.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-android.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="android_push_guide.html">消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-android.html">实时通信开发指南</a></li>
            <li><a href="chatkit-android.html">ChatKit 使用指南</a></li>
            <li><a href="livekit-android.html">LiveKit 使用指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            <li><a href="android_statistics.html">统计分析开发指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="android_faq.html">FAQ</a></li>
            <li><a href="/api-docs/android/index.html" target="_blank">SDK API</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">JavaScript</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-js.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-js.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-js.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="weapp.html">微信小程序开发指南</a></li>
            <li><a href="leanstorage_guide-js.html#Push_通知">消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-js.html">实时通信开发指南</a></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="js_analytics.html">统计分析开发指南</a></li>
            <!-- <li><a href="js_faq.html">FAQ</a></li> -->
            <li role="separator" class="divider"></li>
            <li><a href="https://leancloud.github.io/javascript-sdk/docs/" target="_blank">数据存储 SDK API</a></li>
            <li><a href="https://leancloud.github.io/js-realtime-sdk/docs/" target="_blank">实时通信 SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-node.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-node.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">.NET / Unity3D</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-dotnet.html">.NET SDK 安装指南</a></li>
            <li><a href="dotnet_guide.html">.NET 数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="analytics-guide.html">.NET 统计开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="unity_guide.html">Unity3D 数据存储开发指南</a></li>
            <li><a href="realtime-unity.html">Unity3D 实时通信开发指南</a></li>
            <li><a href="analytics-guide.html">Unity3D 统计开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="dotnet_push_guide.html">WP8.0 消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <!-- <li><a href="dotnet_faq.html">FAQ</a></li> -->
            <li><a href="/api-docs/dotnet/Help/index.html" target="_blank">.NET SDK API</a></li>
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Python</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-python.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-python.html">数据存储开发指南</a></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="im-servermgmt-guide-python.html">实时通讯服务端管理开发指南</a></li>
            <li><a href="https://leancloud.readthedocs.io/" target="_blank">SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-python.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-python.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">PHP</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-php.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-php.html">数据存储开发指南</a></li>
            <li><a href="/api-docs/php/" target="_blank">SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-php.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-php.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Java</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-java.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-java.html">数据存储开发指南</a></li>
            <li><a href="sms-guide.html">短信 SMS 服务使用指南</a></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-java.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-java.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">REST API</a>
          <ul class="dropdown-menu">
            <li><a href="rest_api.html">数据存储 API</a></li>
            <li><a href="leanengine-rest-api.html">云引擎 API</a></li>
            <li><a href="rest_api.html#Push_通知">消息推送 API</a></li>
            <li><a href="realtime_rest_api.html">实时通信 API</a></li>
            
            <li><a href="rest_sms_api.html">短信验证 API</a></li>
            
            <li><a href="rest_api.html#统计数据_API">数据统计 API</a></li>
            <li><a href="status_system.html#REST_API">应用内社交 API</a></li>
            <li><a href="app_search_guide.html#搜索_API">应用内搜索 API</a></li>
            <li><a href="cql_guide.html">CQL 查询语言详解</a></li>
            <!--<li><a href="oauth2_provider.html">开放平台接入</a></li>-->
            <!-- <li><a href="rest_faq.html">FAQ</a></li> -->
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">云引擎</a>
          <ul class="dropdown-menu">
          <li><a href="leanengine_overview.html">云引擎总览</a></li>
          <li><a href="leanengine_quickstart.html">云引擎快速入门</a></li>
          <li><a href="leanengine_plan.html">云引擎运行方案</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Node.js</li>
          <li><a href="leanengine_webhosting_guide-node.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-node.html">云函数开发指南</a></li>
          <li class="dropdown-header">Python</li>
          <li><a href="leanengine_webhosting_guide-python.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-python.html">云函数开发指南</a></li>
          <li class="dropdown-header">PHP</li>
          <li><a href="leanengine_webhosting_guide-php.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-php.html">云函数开发指南</a></li>
          <li class="dropdown-header">Java</li>
          <li><a href="leanengine_webhosting_guide-java.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-java.html">云函数开发指南</a></li>
          <li role="separator" class="divider"></li>
          <li><a href="leanengine_examples.html">云引擎项目示例</a></li>
          <li><a href="leanengine_cli.html">命令行工具 CLI</a></li>
          <li><a href="acl_guide_leanengine.html">在云引擎中管理 ACL</a></li>
          <li><a href="push-guide-leanengine.html">在云引擎中使用 Push 推送服务</a></li>
          <li><a href="leanengine_faq.html">FAQ</a></li>
          <li><a href="leancache_guide.html">LeanCache 使用指南</a></li>
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">更多</a>
          <ul class="dropdown-menu">
            
            <li><a href="status_system.html">应用内社交使用指南</a></li>
            <li><a href="sns.html">第三方平台账号登录 SNS 开发指南</a></li>
            <li><a href="feedback.html">用户反馈开发指南</a></li>
            
            <li><a href="app_search_guide.html">应用内搜索和 DeepLink 开发指南</a></li>
            <li><a href="app_data_share.html">应用之间数据共享（Class 绑定）</a></li>
            <!-- <li><a href="user_groups.html">用户群分析指南</a></li> -->
            
            <li><a href="leaninsight_guide.html">离线数据分析使用指南</a></li>
            
            <li class="divider"></li>
            <li><a href="kb-network-connectivity-diagnosis.html">网络连通性诊断流程</a></li>
            <li class="divider"></li>
            <li><a href="tutorials.html">教程</a></li>
           <li><a href="demo.html">Demo</a></li>
          </ul>
        </li>
      </ul>
      <!-- <ul class="nav navbar-nav navbar-right">
        <li>
          <form action="/search.html" method="get" target="_blank" class="search-form">
            <input name="q" class="search-input" placeholder="搜索&hellip;">
          </form>
        </li>
      </ul> -->
    </nav>
  </div>
</header>


<div class="container-fluid">

  <div class="row">

    <div class="sidebar-gruntfile-trigger  col-sm-3" id="left-nav">

      <div class="sidebar-affix-shadow sidebar-hover-off">

        <div class="sidebar-wrapper" id="toc-wrapper">

        </div>
        <!-- .sidebar-wrapper -->

      </div>
      <!-- .sidebar-affix-shadow -->

    </div>
    <!-- .col-md-3 -->

    <div class="col-sm-9 sidebar-gruntfile-trigger">
      <div class="doc-content with-comment" id="content">
        <div class="docs-meta">
          <span class="icon icon-github"></span><a href="https://github.com/leancloud/docs#贡献">编辑文档</a>
        <span class="doc-mdate" data-toggle="tooltip" title="2017年5月9日下午5点51分">更新于 <time datetime="2017-05-09T17:51:22+08:00">2017-05-09</time></span></div>
        <h1 id="-">应用内社交模块</h1>
<p>应用内社交，又称「事件流」，在应用开发中出现的场景非常多，包括用户间关注（好友）、朋友圈（时间线）、状态、互动（点赞）、私信等常用功能。</p>
<h2 id="-">基本概念</h2>
<h3 id="status">Status</h3>
<p>Status 是指一条广义上的「状态」，它不仅可以表示某个用户更新了状态，还可以表示任意的一个事件，比如某人发布了一篇文章，某个图片被赞等等。在控制台中对应的表名称为 <code>_Status</code>。该表只有在开发者使用了相应的 API 成功发送了一条状态之后才会出现在 Class 列表中。</p>
<p>需要注意，<strong>存入 <code>_Status</code> 表中的数据无法修改，任何对已存在记录的更新操作都会报错。</strong>就像微博、微信朋友圈之类的系统不允许对已发布的内容进行修改一样，我们对 <code>_Status</code> 表中的记录也应用了同样的逻辑，即如需修改，只能删除老记录，添加新记录。</p>
<p>如果业务的确要求状态的内容可以更改，请将可变的内容/字段放入自建的表中维护，并通过 <code>_Status</code> 表记录的 objectId 来建立关联。</p>
<h3 id="follower-followee">Follower/Followee</h3>
<p>分别表示用户的粉丝和用户的关注，在控制台中对应着两张表 <code>_Follower</code> 和 <code>_Followee</code>。</p>
<h3 id="-">特别提示</h3>
<p>发了一条状态，并不代表会自动发送了一条推送消息，开发者可以自由控制是否使用推送。更多信息请参考 <a href="./push_guide.html">消息推送开发指南</a>。</p>
<h2 id="javascript-sdk">JavaScript SDK</h2>
<h3 id="-">用户关系</h3>
<p>AV.User 新增两个方法 <code>follow</code> 和 <code>unfollow</code> 来建立用户关系，你可以关注某个用户：</p>
<pre><code class="lang-javascript">AV.User.current().follow(&#39;52f9be45e4b035debf88b6e2&#39;).then(function(){
  //关注成功
}, function(err){
  //关注失败
  console.dir(err);
});
</code></pre>
<p><code>follow</code> 方法接收一个 AV.User 对象或者 User 对象的 objectId（通过 user.id 拿到）。</p>
<p>取消关注使用 <code>unfollow</code> 方法：</p>
<pre><code class="lang-javascript">AV.User.current().unfollow(&#39;52f9be45e4b035debf88b6e2&#39;).then(function(){
  //取消关注成功
}, function(err){
  //取消关注失败
  console.dir(err);
});
</code></pre>
<p>关注后，可以查询自己关注的用户列表，使用 <code>AV.User#followeeQuery</code> 得到一个 <code>AV.Query</code>对象来查询关注的用户列表：</p>
<pre><code class="lang-javascript">var query = AV.User.current().followeeQuery();
query.include(&#39;followee&#39;);
query.find().then(function(followees){
  //关注的用户列表 followees
});
</code></pre>
<p>followee 是一个 Pointer 类型，通过 <code>include</code> 将它的所有信息查询包括进来，否则只会返回用户的 id。当查询计数的时候（使用 <code>AV.Query#count</code> 方法）不建议 <code>include</code>。</p>
<p>查询自己的粉丝（他人关注了我，他人就是我的粉丝），可以通过 <code>followerQuery</code> 方法：</p>
<pre><code class="lang-javascript">var query = AV.User.current().followerQuery();
query.include(&#39;follower&#39;);
query.find().then(function(followers){
  //粉丝列表 followers
});
</code></pre>
<p><code>followerQuery</code> 和 <code>followeeQuery</code> 返回的 AV.Query 对象可以象普通的 <a href="https://leancloud.github.io/javascript-sdk/docs/AV.Query.html">AV.Query</a> 对象那样使用，它们本质上都是查询数据管理平台中的 <code>_Follower</code> 和 <code>_Followee</code>表，你可以添加 order、skip、limit 以及其他 where 条件等信息。</p>
<h3 id="-">状态</h3>
<p>关注了用户之后（也就是成为他的粉丝），你就会接收到该用户发送给他的粉丝的状态信息。例如，我喜欢了某个视频，我可以发送这条信息「我喜欢了视频 xxxx」给我的粉丝。我的粉丝就可以在他们的收件箱（inbox）里收到这条状态信息。</p>
<h4 id="-">发布状态</h4>
<p>当前登录用户发送一条状态给关注他的粉丝：</p>
<pre><code class="lang-javascript">var status = new AV.Status(&#39;视频url&#39;, &#39;我喜欢了视频xxxx.&#39;);
status.set(&#39;sound&#39;, &#39;sound.wmv&#39;);
AV.Status.sendStatusToFollowers(status).then(function(status){
  //发布状态成功，返回状态信息
  console.dir(status);
}, function(err){
  //发布失败
  console.dir(err);
});
</code></pre>
<p>发布状态成功，粉丝的收件箱不一定马上能看到，因为发布过程是一个异步的过程，会有一定的延迟，通常这个延迟都在几秒之内。发送状态必须处于用户登录状态，使用 <code>AV.Status.sendStatusToFollowers</code> 将发送给登录用户的粉丝。</p>
<p>AV.Status 对象包含下列属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>对象的objectId</td>
</tr>
<tr>
<td>messageId</td>
<td>状态在某个用户收件箱的消息编号，发件箱返回的 status 则没有此属性，messageId 可用于 <a href="#查询收件箱">收件箱的分页查询</a>。</td>
</tr>
<tr>
<td>inboxType</td>
<td>收件箱类型，默认是 timeline 收件箱，也就是 default。SDK 默认提供 private(私信)，default 表示 timeline，你也可以自定义。</td>
</tr>
<tr>
<td>data</td>
<td>状态属性，一个 JSON 对象，可通过 get 和 set 方法获取和设置。</td>
</tr>
<tr>
<td>createdAt</td>
<td>消息的创建时间</td>
</tr>
</tbody>
</table>
<p>其中 data.source 属性是保留属性，默认指向状态的发布者。</p>
<h4 id="-">发送私信给某个用户</h4>
<p>我还可以发送一条私信给单独某个用户：</p>
<pre><code class="lang-javascript">var status = new AV.Status(null, &#39;机密消息&#39;);
AV.Status.sendPrivateStatus(status,&#39;52f9be45e4b035debf88b6e2&#39;).
  then(function(status){
    //发送成功
    console.dir(status);
  }, function(err){
    //发布失败
    console.dir(err);
});
</code></pre>
<p><code>AV.Status.sendPrivateStatus</code> 的第二个参数指定私信接收的用户或者用户的 objectId。</p>
<h4 id="-">发送给自定义收件箱</h4>
<p>通过 <code>send</code> 方法还可以自定义 inboxType：</p>
<pre><code class="lang-javascript">var query = ... //一个 AV.Query 对象，定义接收者。
var status = new AV.Status(null, &#39;我读了《clojure 编程乐趣》&#39;);
//定义一个 book 收件箱
status.inboxType = &#39;book&#39;;
status.query = query;
status.send().then(function(status){
  //发送成功
});
</code></pre>
<h4 id="-">查询收件箱</h4>
<p>查询我的 timeline 收件箱，可以通过 <code>AV.Status.inboxQuery</code> 方法：</p>
<pre><code class="lang-javascript">var query = AV.Status.inboxQuery(AV.User.current());
query.find().then(function(statuses){
  //查询成功，返回状态列表，每个对象都是 AV.Status
}, function(err){
  //查询失败
  console.dir(err);
});
</code></pre>
<p>收件箱返回的 status 列表，每个 status 都有 messageId 属性，表示这条 status 在这个收件箱里的唯一编号，<code>AV.InboxQuery</code> 有两个方法用于限制 messageId 的范围：</p>
<ul>
<li><strong>sinceId</strong>：设定查询返回的 status 的 messageId 必须<strong>大于</strong>传入的 messageId。</li>
<li><strong>maxId</strong>：限定查询返回的 status 的 messageId 必须小于等于传入的 messageId。</li>
</ul>
<p>通过 sinceId 和 maxId 可以实现分页查询：</p>
<p>查询本次查询之后新增的 status（向后翻页刷新）:</p>
<pre><code class="lang-javascript">//假设 messageId 是上次查询返回的 status 的最大 messageId 编号
var messageId = ...
var query = AV.Status.inboxQuery(AV.User.current());
query.sinceId(messageId);
//查询从上次查询返回结果之后的更新 status
query.find().then(function(statuses){
  //查询成功，返回状态列表，每个对象都是 AV.Status
}, function(err){
  //查询失败
  console.dir(err);
});
</code></pre>
<p>查询本次查询的前一页（也就是更老的 status，向前翻页）：</p>
<pre><code class="lang-javascript">//假设 messageId 是上次查询返回的 status 的最大 messageId 编号
var messageId = ...
var query = AV.Status.inboxQuery(AV.User.current());
query.maxId(messageId);
</code></pre>
<p><code>AV.Status.inboxQuery</code> 还可以指定收件箱的类型，默认是查询 timeline 收件箱，也可以查询私信收件箱：</p>
<pre><code class="lang-javascript">var query = AV.Status.inboxQuery(AV.User.current(), &#39;private&#39;);
</code></pre>
<h4 id="-">查询收件箱未读状态数目</h4>
<p>使用 <code>AV.Status.countUnreadStatuses</code> 可以查询某个收件箱的未读状态数目和总数目：</p>
<pre><code class="lang-javascript">AV.Status.countUnreadStatuses(AV.User.current()).then(function(result){
  console.dir(result);
  var total = result.total;
  var unread  = result.unread;
}, function(err){
    //查询失败
});
</code></pre>
<p>同样的，你可以这样查询当前登录用户未读私信的未读数目和总数目：</p>
<pre><code class="lang-javascript">AV.Status.countUnreadStatuses(AV.User.current(),&#39;private&#39;).then(function(result){
  console.dir(result);
  var total = result.total;
  var unread  = result.unread;
}, function(err){
    //查询失败
});
</code></pre>
<h4 id="-">查询发件箱</h4>
<p>查询我发出去的状态信息，可以通过 <code>statusQuery</code> 方法：</p>
<pre><code class="lang-javascript">var query = AV.Status.statusQuery(AV.User.current());
query.find().then(function(statuses){
  //查询成功，返回状态列表，每个对象都是 AV.Object
}, function(err){
  //查询失败
  console.dir(err);
});
</code></pre>
<p><code>AV.Status.statusQuery</code> 返回的是一个普通的 AV.Query 对象，本质上是查询数据管理平台的 <code>_Status</code> 表。你可以自主添加更多查询条件。</p>
<h2 id="ios-sdk">iOS SDK</h2>
<p>请先 <a href="sdk_down.html">下载应用内社交模块</a>。</p>
<h3 id="-">好友关系</h3>
<h4 id="-">关注/取消关注</h4>
<p>当前登录用户可以关注某人：</p>
<pre><code>NSString *userObjectId = @&quot;XXXXXX&quot;;
//关注
[[AVUser currentUser] follow:userObjectId andCallback:^(BOOL succeeded, NSError *error) {
}];
//取消关注
[[AVUser currentUser] unfollow:userObjectId andCallback:^(BOOL succeeded, NSError *error) {
}];
</code></pre><p>如果在 <a href="/app.html?appid={{appid}}#/permission">控制台 &gt; <strong>设置</strong> &gt; <strong>应用选项</strong> &gt; <strong>其他</strong></a> 勾选了 <strong>应用内社交模块，关注用户时自动反向关注</strong>，那么在当前用户关注某个人，那个人也会自动关注当前用户。</p>
<p>从 2.6.7 版本开始，我们允许在 follow 的时候同时传入一个 attribute 列表，用于设置关系的属性，这些属性都将在 <code>_Follower</code> 和 <code>_Followee</code> 表同时存在：</p>
<pre><code class="lang-objc">   NSDictionary * attrs = ……
   [[AVUser currentUser] follow:userObjectId userDictionary:attrs andCallback:^(BOOL succeeded, NSError *error) {
        //处理结果
    }];
</code></pre>
<h4 id="-">获取粉丝/关注列表</h4>
<p>有两个特殊的 <code>AVQuery</code>：</p>
<pre><code class="lang-objc">//粉丝列表查询
AVQuery *query= [AVUser followerQuery:@&quot;USER_OBJECT_ID&quot;];

//关注列表查询
AVQuery *query= [AVUser followeeQuery:@&quot;USER_OBJECT_ID&quot;];
</code></pre>
<p><code>followerQuery</code> 和 <code>followeeQuery</code> 返回的 AVQuery 可以增加其他查询条件，只要在 <code>_Followee</code> 和 <code>_Follower</code> 表里存在的属性都可以作为查询或者排序条件。</p>
<p>默认的查询得到的 AVUser 对象仅仅有 ObjectId 数据，如果需要<strong>整个 AVUser 对象所有属性，则需要调用 include 方法</strong>。例如：</p>
<pre><code class="lang-objc">AVQuery *query= [AVUser followeeQuery:@&quot;USER_OBJECT_ID&quot;];
[query includeKey:@&quot;followee&quot;];
</code></pre>
<p>分别获得某个用户的粉丝和关注，我们也可以同时取得这两种：</p>
<pre><code class="lang-objc">[[AVUser currentUser] getFollowersAndFollowees:^(NSDictionary *dict, NSError *error) {
    NSArray *followers=dict[@&quot;followers&quot;];
    NSArray *followees=dict[@&quot;followees&quot;];
}];
</code></pre>
<h3 id="-">状态</h3>
<h4 id="-">发布状态</h4>
<p>发布一条时间线状态，即发一条我的粉丝可以看到的状态：</p>
<pre><code class="lang-objc">AVStatus *status=[[AVStatus alloc] init];

status.data=@{@&quot;text&quot;:@&quot;data type change&quot;};

[AVUser logInWithUsername:@&quot;travis&quot; password:@&quot;123456&quot;];
[AVStatus sendStatusToFollowers:status andCallback:^(BOOL succeeded, NSError *error) {
    NSLog(@&quot;============ Send %@&quot;, [status debugDescription]);
}];
</code></pre>
<p>其中 <code>status.data</code> 可以任意指定 NSDictionary 数据。注意，这个字典中的 <strong>source  为系统保留字段</strong>，不可使用。</p>
<h4 id="-">发私信</h4>
<p>给某个用户发私信也非常简单：</p>
<pre><code class="lang-objc">AVStatus *status=[[AVStatus alloc] init];
status.data=@{@&quot;text&quot;:@&quot;this is a private message&quot;};

NSString *userObjectId=@&quot;XXXXXXXXXXXXX&quot;;

[AVStatus sendPrivateStatus:status toUserWithID:userObjectId andCallback:^(BOOL succeeded, NSError *error) {
    NSLog(@&quot;============ Send %@&quot;, [status debugDescription]);
}];
</code></pre>
<h4 id="-">自定义状态</h4>
<p>除了上面常见两种场景，自定义状态可以通过设置<strong>受众群体和发送者</strong>来实现更加灵活的功能。</p>
<pre><code class="lang-objc">AVStatus *status=[[AVStatus alloc] init];
[status setData:@{@&quot;text&quot;:@&quot;we have new website, take a look!&quot;,@&quot;link&quot;:@&quot;http://leancloud.cn&quot;}];

status.type=@&quot;system&quot;;

AVQuery *query=[AVUser query];
[query whereKey:@&quot;age&quot; equalTo:@(20)];
[status setQuery:query];

[status sendInBackgroundWithBlock:^(BOOL succeeded, NSError *error) {

}];
</code></pre>
<p>上面是系统广播的基本实现. 因为指定了一个 AVUser 查询，所以会发送给所有 <code>age=20</code> 的用户，指定了 <code>type</code> 是 system 或者任意字符串，则所有用户会在查询这个类型的状态中看到这一条。</p>
<h4 id="-">获取状态</h4>
<p>下面代码会获取用户时间线上的 50 条状态：</p>
<pre><code class="lang-objc">AVStatusQuery *query=[AVStatus inboxQuery:kAVStatusTypeTimeline];

//限制50条
query.limit=50;

//限制 1397 这个 messageId 上次查询的最大 messageId，如果不设置，默认为最新的
query.maxId=1397;

//需要同时附带发送者的数据
[query includeKey:@&quot;source&quot;];

[query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
    //获得 AVStatus 数组
}];
</code></pre>
<p>同理，可以获得用户的私信，只要把参数改为 <code>kAVStatusTypePrivateMessage</code>。返回的 AVStatus 对象有一个 messageId 属性，用于唯一表示这条 Status 在这个 inbox 里的标示符。可以用这个 id 结合 query 做分页查询。</p>
<p>AVStatusQuery 可以设置 sinceId 和 maxId：</p>
<ul>
<li><strong>sinceId</strong>：设定查询返回的 status 的 messageId 必须<strong>大于</strong>传入的 messageId。</li>
<li><strong>maxId</strong>：限定查询返回的 status 的 messageId 必须小于等于传入的 messageId。</li>
</ul>
<p>使用这两个 Id 就可以做分页查询。AVStatusQuery 查询<strong>不支持 skip</strong>。</p>
<p>获取收件箱的未读 status 数目（从上次访问收件箱最新 status 到现在的未读 status 数目）可以使用 <code>[AVStatus getUnreadStatusesCountWithType:andCallback]</code> 方法。</p>
<p>下面的代码是某个用户发送出去的状态。<strong>查询发送出去的状态，是无法用 <code>messageId(sinceId,maxId)</code> 来做分片查询的</strong>。因为 messageId 只是相对于某个用户的 Inbox 才有意义， 同时返回的状态中也没有 messageId 的数据。</p>
<pre><code class="lang-objc">AVStatusQuery *query=[AVStatus statusQuery];

//设置查询某个用户，默认是查询当前用户
[query whereKey:@&quot;source&quot; equalTo:&lt;AVUser&gt;];

//限制条数
query.limit=20;

//设置消息类型
query.inboxType=kAVStatusTypeTimeline;

[query findObjectsInBackgroundWithBlock:^(NSArray *objects, NSError *error) {
    //获得 AVStatus 数组
}];
</code></pre>
<h2 id="android-sdk">Android SDK</h2>
<p>请先 <a href="sdk_down.html">下载应用内社交模块</a>。</p>
<h3 id="-">好友关系</h3>
<h4 id="-">关注和取消关注</h4>
<p>登录的用户可以关注其他用户，成为他们的粉丝，例如：</p>
<pre><code class="lang-java">//关注
AVUser.getCurrentUser().followInBackground(userObjectId, new FollowCallback() {
        @Override
        public void done(AVObject object, AVException e) {
            if (e == null) {
                Log.i(TAG, &quot;follow succeeded.&quot;);
            } else if (e.getCode() == AVException.DUPLICATE_VALUE) {
                Log.w(TAG, &quot;Already followed.&quot;);
            }
        }
    });

//取消关注
AVUser.getCurrentUser().unfollowInBackground(&quot;the user object id&quot;, new FollowCallback() {
        @Override
        public void done(AVObject object, AVException e) {
            if (e == null) {
                Log.i(TAG, &quot;unfollow succeeded.&quot;);
            } else {
                Log.w(TAG, &quot;unfollow failed.&quot;);
            }
        }
    });
</code></pre>
<p>如果在 <a href="/app.html?appid={{appid}}#/permission">控制台 &gt; <strong>设置</strong> &gt; <strong>应用选项</strong> &gt; <strong>其他</strong></a> 勾选了 <strong>应用内社交模块，关注用户时自动反向关注</strong>，那么在当前用户关注某个人，那个人也会自动关注当前用户。</p>
<p>从 2.6.7 版本开始，我们允许在 follow 的时候同时传入一个 attribute 列表，用于设置关系的属性，这些属性都将在 <code>_Follower</code> 和 <code>_Followee</code> 表同时存在：</p>
<pre><code class="lang-java">Map&lt;String, Object&gt; attributes = ......
AVUser.getCurrentUser().followInBackground(&quot;target user objectId&quot;, attributes, new FollowCallback{
            @Override
            public void done(AVObject object, AVException e) {
                  //处理结果
            }
});
</code></pre>
<h4 id="-">获取粉丝和关注列表</h4>
<p>你可以使用 <code>followerQuery</code> 或 <code>followeeQuery</code> 来查询你的粉丝或关注列表，这样可以设置更多的查询条件，比如：</p>
<pre><code class="lang-java">// 其中 userA 是 AVUser 对象，你也可以使用 AVUser 的子类化对象进行查询
// vhaxun 粉丝
AVQuery&lt;AVUser&gt; followerQuery = userA.followerQuery(AVUser.class);
// AVQuery&lt;AVUser&gt; followerQuery = AVUser.followerQuery(userA.getObjectId(),AVUser.class); 也可以使用这个静态方法来获取非登录用户的好友关系
followerQuery.findInBackground(new FindCallback&lt;AVUser&gt;() {
    @Override
    public void done(List&lt;AVUser&gt; avObjects, AVException avException) {
        // avObjects 包含了 userA 的粉丝列表
    }
});

//查询关注者
AVQuery&lt;AVUser&gt; followeeQuery = AVUser.followeeQuery(userB.getObjectId(), AVUser.class);
//AVQuery&lt;AVUser&gt; followeeQuery = userB.followeeQuery(AVUser.class);
followeeQuery.findInBackground(new FindCallback&lt;AVUser&gt;() {
    @Override
    public void done(List&lt;AVUser&gt; avObjects, AVException avException) {
        //avObjects 就是用户的关注用户列表

    }
});
</code></pre>
<p>通过 AVQuery，你也可以增加 <code>skip</code> 或者 <code>limit</code> 操作来分页查询，比如：</p>
<pre><code class="lang-java">    AVQuery&lt;AVUser&gt; followerSkipQuery = AVUser.followerQuery(userA.getObjectId(), AVUser.class);
    followerSkipQuery.setLimit(50);
    followerSkipQuery.skip(100);
    followerSkipQuery.findInBackground(new FindCallback&lt;AVUser&gt;() {
        @Override
        public void done(List&lt;AVUser&gt; avObjects, AVException avException) {
            // avObjects.size() == 1
        }
    });
}
</code></pre>
<p>你也可以查找某个特定的粉丝，比如：</p>
<pre><code class="lang-java">AVQuery&lt;AVUser&gt; followerNameQuery = userA.followerQuery(userA.getObjectId(), AVUser.class);
followerNameQuery.whereEqualTo(&quot;follower&quot;, userC);
followerNameQuery.findInBackground(new FindCallback&lt;AVUser&gt;() {
    @Override
    public void done(List&lt;AVUser&gt; avObjects, AVException avException) {
        // avObjects 中应当只包含 userC
    }
});
</code></pre>
<p>总之 <code>followerQuery</code> 和 <code>followeeQuery</code> 返回的 AVQuery 可以增加其他查询条件，只要在 <code>_Followee</code> 和 <code>_Follower</code> 表里存在的属性都可以作为查询或者排序条件。</p>
<p>默认的得到的 AVUser 对象仅仅有 ObjectId 数据，如果需要整个 AVUser 对象所有属性，则需要调用 include方法。例如：</p>
<pre><code class="lang-java">AVQuery&lt;AVUser&gt; followerNameQuery = AVUser.followerQuery(userA.getObjectId(), AVUser.class);
followerNameQuery.include(&quot;follower&quot;);

AVQuery&lt;AVUser&gt; followeeNameQuery = AVUser.followeeQuery(userA.getObjectId(), AVUser.class);
followerNameQuery.include(&quot;followee&quot;);
</code></pre>
<h5 id="-">一次性获取粉丝和关注列表</h5>
<pre><code class="lang-java">    AVFriendshipQuery query = AVUser.friendshipQuery(userId, SubUser.class);
    query.include(&quot;followee&quot;);
    query.include(&quot;follower&quot;);
    query.getInBackground(new AVFriendshipCallback() {
      @Override
      public void done(AVFriendship friendship, AVException e) {
        List&lt;SubUser&gt; followers = friendship.getFollowers(); //获取粉丝
        List&lt;SubUser&gt; followees = friendship.getFollowees(); //获取关注列表
        AVUser user = friendship.getUser(); //获取用户对象本身
      }
    });
</code></pre>
<h3 id="-">状态</h3>
<h4 id="-">发布状态</h4>
<p>发布一条时间线状态，即发一条我的粉丝可以看到的状态。</p>
<pre><code class="lang-java">AVStatus status= new AVStatus();
// 或者你也可以使用静态方法
// AVStatus status = AVStatus.createStatus(&quot;my image&quot;, &quot;my message&quot;);
status.setImageUrl(&quot;myImageUrl&quot;);
status.setMessage(&quot;myMessage&quot;);
// 或者你也可以使用方法
// setData(Map&lt;String, Object&gt; data)

AVUser.logIn(&quot;myUserName&quot;, &quot;myPassword&quot;);
AVStatus.sendStatusToFollowersInBackgroud(status, new SaveCallback() {
    @Override
    public void done(AVException avException) {
        Log.i(TAG, &quot;Send status finished.&quot;);
    }
});
</code></pre>
<p>其中 <code>status.setData</code> 可以任意指定 <code>Map&lt;String, Object&gt;</code> 数据（map 中的 source 字段为系统保留字段，不可使用）。</p>
<h4 id="-">发私信</h4>
<p>给某个用户发私信也非常简单：</p>
<pre><code class="lang-java">AVStatus status = AVStatus.createStatus(&quot;test image&quot;, &quot;test message&quot;);
AVStatus.sendPrivateStatusInBackgroud(status, &quot;user object id&quot;, new SaveCallback() {
    @Override
    public void done(AVException avException) {
        Log.i(TAG, &quot;Send private status finished.&quot;);
    }
});
</code></pre>
<h4 id="-status">自定义 Status</h4>
<p>除了上面常见两种场景，自定义 Status 可以通过设置<strong>受众群体和发送者</strong>来实现更加灵活的功能。</p>
<pre><code class="lang-java">Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();
data.put(&quot;text&quot;, &quot;we have new website, take a look!&quot;);
data.put(&quot;link&quot;, &quot;http://leancloud.cn&quot;);
AVStatus status = AVStatus.createStatusWithData(data);
status.setInboxType(&quot;system&quot;);

    status.sendInBackgroundWithBlock(new SaveCallback() {
        @Override
        public void done(AVException e) {
            Log.i(TAG, &quot;Send finished&quot;);

        }
    });
</code></pre>
<p>上面是系统广播的基本实现。因为指定了一个无条件的 AVUser 查询，所以会发送给所有的用户，指定了 <code>inboxType</code> 是 system 或者任意字符串，则所有用户会在查询这个类型的状态中看到这一条。SDK 包含了两种预定类型：</p>
<ul>
<li><code>AVStatus.INBOX_TYPE.TIMELINE</code></li>
<li><code>AVStatus.INBOX_TYPE.PRIVATE</code></li>
</ul>
<h4 id="-">获取收件箱状态</h4>
<p>获取用户收件箱内时间线上的 50 条状态：</p>
<pre><code class="lang-java">AVStatusQuery&lt;AVStatus&gt; inboxQuery = AVStatus.inboxQuery(AVStatus.class, userB,AVStatus.INBOX_TYPE.TIMELINE.toString());
inboxQuery.setLimit(50);  //设置最多返回 50 条状态
inboxQuery.setSinceId(0);  //查询返回的 status 的 messageId 必须大于 sinceId，默认为 0
inboxQuery.findInBackground(new InboxStatusFindCallback(){
  @Override
  public void done(final List&lt;AVStatus&gt; avObjects, final AVException avException) {

  }
});
</code></pre>
<p>同理，可以获得用户收件箱的私信，只要把   <code>type</code> 参数改为 <code>AVStatus.INBOX_TYPE.PRIVATE.toString()</code> 即可。</p>
<p>AVStatus 有一个 messageId 属性，用于标示这条 status 在 inbox 里的唯一位置。使用这个 <code>messageId</code> 结合 <code>AVStatusQuery</code> 可以做分页查询，AVStatusQuery 可以设置 <code>sinceId</code> 和 <code>maxId</code>：</p>
<ul>
<li><strong>sinceId</strong>：设定查询返回的 status 的 messageId 必须<strong>大于</strong>传入的 messageId。</li>
<li><strong>maxId</strong>：限定查询返回的 status 的 messageId 必须小于等于传入的 messageId。</li>
</ul>
<p>使用这两个 Id 就可以做分页查询。AVStatusQuery 查询<strong>不支持 skip</strong>。</p>
<p>从 v2.6.7 版本开始，<code>InboxStatusFindCallback</code> 提供 <code>isEnd()</code> 方法，用来<strong>在查询后</strong>检查收件箱查询是否已经到了最早的一页数据。</p>
<h4 id="-">获取收件箱的计数</h4>
<p>使用 <code>AVStatus.getUnreadStatusesCountInBackground</code>方法可以查询收件箱的未读 status 数目和总 status 数目：</p>
<pre><code class="lang-java">AVStatus.getUnreadStatusesCountInBackground(AVStatus.INBOX_TYPE.TIMELINE.toString(), new CountCallback() {
        public void done(int count, AVException e) {
            if (e == null) {
                //count就是未读status数目
            } else {
                //有错误发生。
            }
        }
    });
</code></pre>
<h4 id="-">重置收件箱未读消息数</h4>
<p>如果想将某个收件箱（比如 private）的未读消息数设置为 0，也就是通常看到的将全部消息设为「已读」的功能，可以调用如下函数：</p>
<pre><code class="lang-java">AVStatus.resetUnreadStatusesCount(&quot;private&quot;, new AVCallback() {
  @Override
  protected void internalDone0(Object o, AVException exception) {
    if (exception == null) {
      // 重置成功
    } else {
      // 重置失败，具体失败原因在 exception 中
    }
  }
});
</code></pre>
<h4 id="-">查询发件箱状态</h4>
<p>查询当前用户发件箱内已经发送的 50 条状态：</p>
<pre><code class="lang-java">AVStatusQuery&lt;AVStatus&gt; query = AVStatus.statusQuery(AVStatus.class,AVUser.getCurrentUser());
query.setLimit(50);    //设置最多返回 50 条状态
query.setSinceId(0);   //查询返回的 status 的 messageId 必须大于 sinceId，默认为 0
//query.setInboxType(AVStatus.INBOX_TYPE.TIMELINE.toString()); 此处可以通过这个方法来添加查询的状态条件，当然这里你也可以用你自己定义的状态类型，因为这里接受的其实是一个字符串类型。
query.findInBackground(new FindCallback&lt;AVStatus&gt;(){
  @Override
  public void done(final List&lt;AVStatus&gt; avObjects,final AVException avException) {

  }
});
</code></pre>
<h2 id="rest-api">REST API</h2>
<p>本节介绍应用内社交的 REST API。</p>
<h3 id="-api">用户关系 API</h3>
<p>使用这里的 API 来建立用户关系，你可以关注、取消关注某个用户。</p>
<ul>
<li>这里的三个查询 API 都遵循我们的 REST API 规范，支持 <code>where</code>、<code>order</code>、<code>skip</code>、<code>limit</code>、<code>count</code>、<code>include</code> 等。如果没有特殊说明，返回的结果都是 <code>{results: [数组结果]}</code>，跟其他查询 API 保持一致。</li>
<li>用户在 <code>_Follower</code> 和 <code>_Followee</code> 表中都存储为 Pointer 类型，因此如果要查询出用户信息，应该加上 include 指定字段。</li>
</ul>
<h4 id="-api">关注和取消关注用户 API</h4>
<p>通过操作 <code>/users/:user_id/friendship/:target_id</code> 资源可以关注或者取消关注某个用户，其中：</p>
<ul>
<li><code>:user_id</code> 表示发起关注动作的用户的 objectId。如果设置了 <code>X-LC-Session</code> 头，则 <code>self</code> 表示当前登录用户。</li>
<li><code>:target_id</code> 表示想要关注的目标用户的 objectId。</li>
</ul>
<p>例如，让当前用户 <code>51fa6886e4b0cc0b5a3792e9</code> 关注目标用户 <code>51e3a334e4b0b3eb44adbe1a</code>：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/friendship/51e3a334e4b0b3eb44adbe1a
</code></pre>
<p>关注后，<code>_Follower</code> 和 <code>_Followee</code> 都会多出一条记录，如果在 <a href="/app.html?appid={{appid}}#/permission">控制台 &gt; <strong>设置</strong> &gt; <strong>应用选项</strong> &gt; <strong>其他</strong></a> 中勾选了 <strong>应用内社交模块，关注用户时自动反向关注</strong>，会各多出两条记录。</p>
<p>取消关注通过：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/friendship/51e3a334e4b0b3eb44adbe1a
</code></pre>
<p>关注还可以增加一些属性：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{&quot;score&quot;: 100}&#39; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/friendship/51e3a334e4b0b3eb44adbe1a
</code></pre>
<p>那么 <code>score</code> 字段将同时出现在 <code>_Follower</code> 和 <code>_Followee</code> 表，可以作为查询或者排序条件。</p>
<h4 id="-api">查询粉丝或者关注者列表 API</h4>
<p>查询粉丝列表（也就是关注我的人），可以通过：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/followers
</code></pre>
<p>返回的用户列表是 Pointer 类型，如果想要将用户信息也返回，需要 include:</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;include=follower&#39; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/followers
</code></pre>
<p>查询关注的用户列表：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;include=followee&#39; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/followees
</code></pre>
<p>同时查询粉丝和关注的人：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;include=followee&#39; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/followersAndFollowees
</code></pre>
<p>结果返回：</p>
<pre><code class="lang-json">{followers: [粉丝列表], followees: [关注用户列表]}
</code></pre>
<p>如果指定 count=1，则返回结果里加上 followers_count 和 followees_count 表示粉丝数目和关注者数目：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;include=followee&#39; \
  --data-urlencode &#39;count=1&#39; \
  https://{{v2Domain}}/1.1/users/51fa6886e4b0cc0b5a3792e9/followersAndFollowees
</code></pre>
<h3 id="-api">状态 API</h3>
<p>再次解释下术语定义：</p>
<ul>
<li><strong>status</strong>：一条状态，包含两个预定义属性 <code>messageId</code> 和 <code>inboxType</code>，其他属性都可自定义。</li>
<li><strong>target</strong>：状态的目标接收者，也就是 inbox 的 owner。</li>
<li><strong>inbox</strong>：target 的收件箱，有 owner（所有者）和 inboxType（收件箱类型）两个属性。</li>
</ul>
<h4 id="-status-api">发布 Status API</h4>
<p>调用 API 如下：</p>
<pre><code>POST /statuses
</code></pre><p>接受的 JSON 对象参数：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>query</td>
<td>查询 target 的条件，包括下列属性：<ul><li><strong>where</strong>：查询条件，可为空 <code>{}</code>，表示查询全表。</li><li><strong>className</strong>：target 的 className</li><li><strong>keys</strong>：查询指定的列作为 inbox 的 owner 属性存储，如果不指定，默认将为整个对象作为 pointer 存储到 owner。</li></ul></td>
</tr>
<tr>
<td>data</td>
<td>status 的 数据 JSON 对象，用户自定义。如果包含 source（指向发送者的 Pointer），并且 inboxType 设为 default，该 status 会同时往发送者的 inbox 投递。</td>
</tr>
<tr>
<td>inboxType</td>
<td>字符串，指定接收这条 status 的 inbox 类型，可为空，默认为 <code>default</code>。</td>
</tr>
</tbody>
</table>
<p>【示例一】往 dennis 的粉丝群体发送一条状态：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -d &#39;{
         &quot;data&quot;: {
            &quot;image&quot;: &quot;paas-files.qiniudn.comwQUf3WohbJpyuXutPjKHPmkSj4gbiYMeNJmTulNo.jpg&quot;,
            &quot;message&quot;: &quot;AVOS Cloud is great!&quot;
         },
         &quot;inboxType&quot;: &quot;default&quot;,
         &quot;query&quot;: {
             &quot;className&quot;: &quot;_Follower&quot;,
             &quot;keys&quot;: &quot;follower&quot;,
             &quot;where&quot;: {
                 &quot;user&quot;: {
                     &quot;__type&quot;: &quot;Pointer&quot;,
                     &quot;className&quot;: &quot;_User&quot;,
                     &quot;objectId&quot;: &quot;dennis&#39;id&quot;
                 }
              }
         }
      }&#39; \
   https://{{v2Domain}}/1.1/statuses
</code></pre>
<p>这条状态的内容是 data 指定的，并且设定 inboxType 是 <code>default</code>：</p>
<pre><code class="lang-json">{
     &quot;image&quot;: &quot;paas-files.qiniudn.comwQUf3WohbJpyuXutPjKHPmkSj4gbiYMeNJmTulNo.jpg&quot;,
      &quot;message&quot;: &quot;LeanCloud is great!&quot;
}
</code></pre>
<p>这条状态的目标用户群体是 query 指定的查询条件，查询的是 <code>_Follower</code> 表中 dennis 的粉丝用户。</p>
<p>【示例二】dennis 向 catty 发送私信的请求类似：</p>
<pre><code class="lang-json">{
    &quot;data&quot;: {
        &quot;message&quot;: &quot;hello catty!&quot;
    },
    &quot;inboxType&quot;: &quot;private&quot;,
    &quot;query&quot;: {
        &quot;className&quot;: &quot;_User&quot;,
        &quot;where&quot;: {
            &quot;objectId&quot;: &quot;catty&#39;s id&quot;
        }
    }
}
</code></pre>
<h4 id="-api">查询发出的状态 API</h4>
<pre><code>GET /statuses
</code></pre><p>跟查询其他对象一样。知道 objectId，查询单条状态：</p>
<pre><code>GET /statuses/:status_id
</code></pre><h4 id="-api">删除状态 API</h4>
<pre><code>DELETE /statuses/:status_id
</code></pre><h4 id="-api">查询已经关注的用户的状态聚合列表 API</h4>
<p>查询我关注的用户发出来的状态聚合而成的列表，也就是查询自己的收件箱，通过：</p>
<pre><code>GET /subscribe/statuses
</code></pre><p>接收参数（参数都必须要 URL encoded）：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>owner</td>
<td>JSON 序列化后的 owner 字符串，表示 inbox 所有者。</td>
</tr>
<tr>
<td>inboxType</td>
<td>inbox 的类型，默认为 <code>default</code>，可为空。</td>
</tr>
<tr>
<td>where</td>
<td>用于过滤 status 的 where 条件，也是 JSON 序列化后的字符串。</td>
</tr>
<tr>
<td>sinceId</td>
<td>查询返回的 status 的 messageId 必须大于 sinceId，默认为 0。</td>
</tr>
<tr>
<td>maxId</td>
<td>查询返回的 status 的 messageId 必须小于等于 maxId，默认为 0。</td>
</tr>
<tr>
<td>limit</td>
<td>最多返回多少条 status，默认 100，最大 100。</td>
</tr>
<tr>
<td>count</td>
<td>默认为空，设置为 &quot;1&quot; 表示在结果中带上 status 的 count 计数。</td>
</tr>
</tbody>
</table>
<p>【示例一】查询我的主页 timeline：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis id&quot;}&#39; \
  https://{{v2Domain}}/1.1/subscribe/statuses
</code></pre>
<p>【示例二】查询我的最新私信列表：</p>
<pre><code class="lang-sh">    --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis&quot;}&#39; \
    --data-urlencode &#39;inboxType=private&#39;
</code></pre>
<p>【示例三】假设上次返回的最大 messageId 是 99，查询从 mesageId = 99 开始最新的 status：</p>
<pre><code class="lang-sh">    --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;, &quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis&quot;}&#39; \
    --data-urlencode &#39;sinceId=99&#39;
</code></pre>
<p>【示例四】查询 messageId 在 99 到 199 之间的 status：</p>
<pre><code class="lang-sh">    --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis&quot;}&#39; \
    --data-urlencode &#39;sinceId=99&#39; \
    --data-urlencode &#39;maxId=199&#39;
</code></pre>
<p>【示例五】查询最新的 status，并且 status 的 image 属性存在，也就是查询包含图片的最新 status：</p>
<pre><code class="lang-sh">    --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis&quot;}&#39; \
    --data-urlencode &#39;where={&quot;image&quot;:{&quot;$exists&quot;:true }}&#39;
</code></pre>
<h4 id="-">删除收件箱里的消息</h4>
<p>可以根据 messageId 来删除收件箱的消息：</p>
<pre><code class="lang-sh">curl -X DELETE \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis id&quot;}&#39; \
  --data-urlencode &#39;inboxType=default&#39; \
  --data-urlencode &#39;messageId=99&#39; \
  https://{{v2Domain}}/1.1/subscribe/statuses/inbox
</code></pre>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>owner</td>
<td>JSON 序列化后的 owner 字符串，表示 inbox 所有者。</td>
</tr>
<tr>
<td>inboxType</td>
<td>inbox 的类型，默认为 <code>default</code>，可为空。</td>
</tr>
<tr>
<td>messageId</td>
<td>想要删除的 status 的 messageId</td>
</tr>
</tbody>
</table>
<h4 id="-api">查询状态计数 API</h4>
<p>查询 inbox 总消息数目和未读消息数目：</p>
<pre><code>GET &quot;/subscribe/statuses/count
</code></pre><p>可指定的条件：</p>
<ul>
<li><strong>owner</strong>：JSON 序列化后的 owner 字符串，表示 inbox 所有者。</li>
<li><strong>inboxType</strong>：inbox 类型，默认为 <code>default</code>，可为空。</li>
</ul>
<p>【示例一】查询我的未读消息数目：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
  --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis&quot;}&#39; \
  https://{{v2Domain}}/1.1/subscribe/statuses/count
</code></pre>
<p>返回：</p>
<pre><code class="lang-json">{ &quot;total&quot;: 100, &quot;unread&quot;:20}
</code></pre>
<p>【示例二】查询私信消息数目：</p>
<pre><code class="lang-sh">curl -X GET \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
   --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis&quot;}&#39; \
   --data-urlencode &#39;inboxType=private&#39; \
   https://{{v2Domain}}/1.1/subscribe/statuses/count
</code></pre>
<h4 id="-">重置未读消息数</h4>
<p>如果想将某个收件箱的未读消息数设置为 0，也就是通常看到的将全部消息设为「已读」的功能，可以通过 <code>resetUnreadCount</code> API 来实现：</p>
<pre><code class="lang-sh">curl -X POST \
  -H &quot;X-LC-Id: {{appid}}&quot; \
  -H &quot;X-LC-Key: {{appkey}}&quot; \
  -H &quot;Content-Type: application/json&quot; \
  -G \
   --data-urlencode &#39;owner={&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;_User&quot;,&quot;objectId&quot;:&quot;dennis&quot;}&#39; \
   --data-urlencode &#39;inboxType=private&#39; \
   https://{{v2Domain}}/1.1/subscribe/statuses/resetUnreadCount
</code></pre>
<p>接收的参数与 <a href="#查询状态计数_API">查询状态计数 API</a> 是一致的。</p>


      </div>
    </div>
    <!-- .col-md-9 -->
  </div>
  <!-- .row -->

</div>
<!-- .container-fluid -->
<div id="comment-container" ng-class="{'no-comments': currentComments.length<1}">
  <div class="comment-head">
    {{allComment[version]}}
    <span class="close" ng-click="closeCommentModal()">&times;</span>
  </div>
  <div class="comment-body">
    <div class="comment-list" ng-class="{'no-login': !currentCommentUser.username}">
      <ul>
        <li ng-show="currentComments.length<1">暂无评论</li>
        <li ng-repeat="comment in currentComments">
          <div class="comment-author">{{comment.author}}</div>
          <div class="comment-timestamp">{{ comment.createdAt | date: 'yyyy-MM-dd HH:mm:ss '}}</div>
          <div class="comment-content">{{comment.content}}</div>
        </li>
      </ul>
    </div>
  </div>
  <div class="comment-compose" ng-show="currentCommentUser.username">
    <div class="form-group"> <textarea class="form-control comment-content" ng-model="commentContent"></textarea></div>
    <div class="form-meta">
      <!-- 您已登录为 <b>{{currentCommentUser.username}}</b> -->
      <button class="btn btn-sm btn-default create-comment pull-right" ng-click="createComment($event)">
        <i class="icon icon-chat-bold"></i> 评论
      </button>
    </div>
  </div>
  <div class="comment-compose no-login" ng-show="!currentCommentUser.username">
    您需要 <a class="comment-login" ng-click="loginComment()">授权</a> 后才能评论
  </div>
</div>

<script src="https://download.leancloud.cn/sdk/latest.js"></script>


<script src="custom/js/lib/contents.js"></script>
<script src="custom/js/md.js"></script>


<script type="text/javascript">
ZeroClipboard.setDefaults({
    moviePath: 'custom/js/lib/zeroclipboard/zeroclipboard.swf'
});
$(function(){
    // $('#content [version]').each(function(k,v){
    //     var version = $(v).attr('version');
    //     $(v).append('<div class="toggle-comment" ng-click="showCommentDialog(\''+version+'\''+',$event)">+ <span> {{}}</span> </div>');
    // })

    $('#content [version]').each(function(k,v){
        var version = $(v).attr('version');
        $(v).append('<div class="inline-comment-wrap" version="'+version+'" all-comment="allComment" showDialogMethod="showCommentDialog()" lc-comment> </div>');
    });

    angular.element(document).ready(function() {

      angular.bootstrap(document, ['app']);

    });
});

</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42629236-7', 'auto');
  ga('send', 'pageview');

</script>





  <footer class="footer" role="contentinfo">
  <div class="container-fluid">
    <!-- <a href="http://leancloud.cn/" class="logo font-logo pull-left">
      LeanCloud
    </a> -->

    <ul class="footer-links pull-right">
      <li class="muted">·</li>
      <li><a href="/pricing">价格</a></li>
      <li class="muted">·</li>
      <li><a href="/docs/sdk_down.html">下载</a></li>
      <!-- <li class="muted">·</li>
      <li><a href="/apps.html" target="_self">App</a></li> -->
      <li class="muted">·</li>
      <li><a href="http://leancloud.cn/docs/faq.html" target="_self">常见问题</a></li>
      <li class="muted">·</li>
      <li><a href="http://leanticket.cn" target="_self"><span class="mobile-hide">技术</span>支持</a></li>
      <!-- <li><a href="http://ticket.leancloud.cn/tickets?token={{user.session_token || 'Gs5Xw4vjyCznrP6OcgMheOWDuatVpbFPiL78eMo6JC0dENB8'}}" target="_blank"><span class="mobile-hide">用户</span>反馈</a></li> -->
      <li class="muted">·</li>
      <li><a href="https://status.leancloud.cn/"><span class="mobile-hide">健康</span>状态</a></li>
      <li class="muted">·</li>
      <li><a href="http://forum.leancloud.cn/">社区</a></li>
      <li class="muted">·</li>
      <li><a href="http://blog.leancloud.cn/">Blog</a></li>
      <li class="muted">·</li>
      <li><a href="https://github.com/leancloud/docs">文档源码</a></li>
    </ul>
  </div>
</footer>



</body>

</html>
