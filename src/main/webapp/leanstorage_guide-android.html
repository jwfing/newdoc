<!doctype html>

<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>数据存储开发指南 &middot; Android - LeanCloud 文档</title>
<!-- build:js custom/js/docs-all.js -->
<script src="custom/js/lib/jquery.min.js"></script>
<script src="custom/js/lib/bootstrap.min.js"></script>
<script src="custom/js/lib/bootstrap-hover-dropdown.js"></script>
<script src="custom/js/lib/pretty/prettify.js"></script>
<script src="custom/js/lib/jquery.scrollTo.min.js"></script>
<script src="custom/js/lib/angular/angular.min.js"></script>
<script src="custom/js/lib/zeroclipboard/zeroclipboard.js"></script>
<script src="custom/js/lib/markdown.min.js"></script>
<script src="custom/js/lib/md5.js"></script>

<script src="custom/js/lib/angular-gravatar.js"></script>
<script src="custom/js/prepare-dom.js"></script>
<script src="custom/js/app.js"></script>
<script src="custom/js/common.js"></script>
<script src="custom/js/demo.js"></script>
<script src="custom/js/weapp-domains.js"></script>
<!-- endbuild -->

<script type="text/javascript">
      var _vds = _vds || [];
      window._vds = _vds;
      (function(){
        _vds.push(['setAccountId', 'a268202b003f2516']);
        (function() {
          var vds = document.createElement('script');
          vds.type='text/javascript';
          vds.async = true;
          vds.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'dn-growing.qbox.me/vds.js';
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(vds, s);
        })();
      })();
  </script>

<link rel="stylesheet" type="text/css" href="custom/css/app-docs.css?githubv1">


</head>


<body class="dashboard-init" data-offset="0" ng-cloak="" ng-controller="AppCtrl">




  <nav class="dashboard-subnav navbar navbar-default navbar-static-top" role="navigation">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#app-options" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a href="/" class="navbar-brand nav-logo font-logo" title="LeanCloud 官网">LeanCloud</a>
    </div>

    <div class="collapse navbar-collapse" id="app-options">
      <!-- <ul class="nav navbar-nav navbar-app-select">
        <li>
          <a href="/dashboard/applist.html" class="nav-logo font-logo" title="LeanCloud 控制台">LeanCloud</a>
        </li>
      </ul> -->
      <div class="navbar-app-actions-wrap">
        <ul class="nav navbar-nav navbar-app-actions">
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="index.html">
              <i class="icon icon-dashbd-icon icon-home"></i>
              <div class="name">文档首页</div>
            </a>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="sdk_down.html" title="SDK 下载">
              <i class="icon icon-dashbd-icon icon-package"></i>
              <div class="name"><span class="mobile-hide">SDK </span>下载</div>
            </a>
          </li>
          <li class="dropdown dropdown-toggle-app-name">
            <a href="demo.html" title="Demos">
              <i class="icon icon-dashbd-icon icon-magic"></i>
              <div class="name">Demos</div>
            </a>
          </li>
          <li class="dropdown dropdown-toggle-app-name">
            <a class="nav-key-6 dropdown-toggle" title="API Docs" data-toggle="dropdown">
              <i class="icon icon-dashbd-icon icon-log"></i>
              <div class="name">API 文档</div>
            </a>
            <ul class="dropdown-menu">
            <li><a href="/api-docs/android/index.html" target="_blank">Android SDK API</a></li>
<li><a href="/api-docs/iOS/index.html" target="_blank">Objective-C SDK API</a></li>
<li><a href="https://leancloud.github.io/javascript-sdk/docs/" target="_blank">JavaScript 数据存储 SDK API</a></li>
<li><a href="https://leancloud.github.io/js-realtime-sdk/docs/" target="_blank">JavaScript 实时通信 SDK API</a></li>
<li><a href="https://leancloud.readthedocs.io/">Python SDK API</a></li>
<li><a href="/api-docs/php/" target="_blank">PHP SDK API</a></li>
<li><a href="/api-docs/dotnet/Help/index.html">.NET SDK API</a></li>

            </ul>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a href="opencourse.html">
              <i class="icon icon-dashbd-icon icon-play"></i>
              <div class="name">公开课</div>
            </a>
          </li>
          
          <li class="dropdown dropdown-toggle-app-name">
            <a class="nav-key-6 dropdown-toggle" title="帮助" data-toggle="dropdown">
              <i class="icon icon-dashbd-icon icon-question"></i>
              <div class="name">帮助</div>
            </a>
            <ul class="dropdown-menu">
              <li><a href="https://leanticket.cn/t/leancloud">技术支持</a></li>
              <li><a href="http://forum.leancloud.cn">社区</a></li>
              <li><a href="http://blog.leancloud.cn/">Blog</a></li>
              <li role="presentation" class="divider"></li>
              <li><a href="/dashboard/apionline/index.html">在线 API 工具</a></li>
              <li role="presentation" class="divider"></li>
              <!-- <li><a href="/apps.html">LeanCloud App</a></li> -->
              <li><a href="/pricing">价格</a></li>
              <!-- <li><a href="#" data-toggle="modal" data-target="#modal-shortcuts">快捷键</a></li> -->
            </ul>
          </li>
        </ul>
        <!-- hide search input on the home page -->
        
          <form role="search" action="https://newdoc.leanapp.cn/search" method="get">
            <div class="app-search">
              <input name="q" type="text" class="form-control" placeholder="搜索文档&hellip;">
            </div>
          </form>
        
      </div>

      <ul class="nav navbar-nav navbar-user-actions navbar-right" ng-cloak="">

        <li class="dropdown" ng-show="user.username">
          <a role="button" class="dropdown-toggle user-name" data-toggle="dropdown">
            <span class="user-gravatar">
              <img gravatar-src="user.email" gravatar-size="64">
            </span>
            <span class="user-name-text">{{user.username}}</span>
          </a>
          <ul class="dropdown-menu">
            <li><a href="/settings.html">账号设置</a></li>
            <li><a href="/applist.html">控制台</a></li>
            
            <li><a href="/settings.html#/setting/team">团队管理</a></li>
            
            <li><a href="/bill.html#/bill/general">财务</a></li>
            <!-- <li><a href="settings.html#/setting/invite">邀请好友</a></li> -->
            <li ng-show="user.username" style=""><a ng-click="signout()">登出</a></li>
          </ul>
        </li>
        <li ng-hide="user.username">
          <a href="/login.html#/signin">登录</a>
        </li>
        <li ng-hide="user.username">
          <a href="/login.html#/signup">注册</a>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div>
  <!-- .container-fluid -->
</nav>



<header class="doc-subnav" role="banner">
  <div class="container-fluid">
    <nav class="" role="navigation">
      <ul class="nav navbar-nav">
        
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">功能概览</a>
          <ul class="dropdown-menu">
            <li><a href="storage_overview.html">数据存储服务总览</a></li>
            <li><a href="leanengine_overview.html">云引擎总览</a></li>
            <li><a href="push_guide.html">消息推送服务总览</a></li>
            <li><a href="realtime_v2.html">实时通信服务总览</a></li>
            <li><a href="dashboard_guide.html">控制台使用指南</a></li>
            <li><a href="data_security.html">数据安全</a></li>
            <li><a href="error_code.html">错误码详解</a></li>
            <li><a href="faq.html">常见问题</a></li>
            <li><a href="tool_tips.html">常见功能提示</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Objective-C</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-objc.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-objc.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-objc.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="ios_push_guide.html">消息推送开发指南</a></li>
            <li><a href="ios_push_cert.html">iOS 推送证书设置指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-objc.html">实时通信开发指南</a></li>
            <li><a href="chatkit-ios.html">ChatKit 使用指南</a></li>
            <li><a href="livekit-ios.html">LiveKit 使用指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            <li><a href="ios_statistics.html">统计分析开发指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="ios_crashreporting_guide.html">崩溃报告使用指南</a></li>
            <li><a href="ios-macos-faq.html">FAQ</a></li>
            <li><a href="/api-docs/iOS/index.html" target="_blank">SDK API</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Swift</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-swift.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-swift.html">数据存储开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Android</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-android.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-android.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-android.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="android_push_guide.html">消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-android.html">实时通信开发指南</a></li>
            <li><a href="chatkit-android.html">ChatKit 使用指南</a></li>
            <li><a href="livekit-android.html">LiveKit 使用指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            <li><a href="android_statistics.html">统计分析开发指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="android_faq.html">FAQ</a></li>
            <li><a href="/api-docs/android/index.html" target="_blank">SDK API</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">JavaScript</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-js.html">SDK 安装指南</a></li>
            <li><a href="leanstorage-started-js.html">数据存储快速入门</a></li>
            <li><a href="leanstorage_guide-js.html">数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="weapp.html">微信小程序开发指南</a></li>
            <li><a href="leanstorage_guide-js.html#Push_通知">消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="realtime_guide-js.html">实时通信开发指南</a></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="acl-guide.html">ACL 权限管理指南</a></li>
            
            <li><a href="sms-guide.html">短信服务使用指南</a></li>
            
            <li><a href="js_analytics.html">统计分析开发指南</a></li>
            <!-- <li><a href="js_faq.html">FAQ</a></li> -->
            <li role="separator" class="divider"></li>
            <li><a href="https://leancloud.github.io/javascript-sdk/docs/" target="_blank">数据存储 SDK API</a></li>
            <li><a href="https://leancloud.github.io/js-realtime-sdk/docs/" target="_blank">实时通信 SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-node.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-node.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">.NET / Unity3D</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-dotnet.html">.NET SDK 安装指南</a></li>
            <li><a href="dotnet_guide.html">.NET 数据存储开发指南</a></li>
            <li><a href="livequery-guide.html">LiveQuery 开发指南</a></li>
            <li><a href="analytics-guide.html">.NET 统计开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="unity_guide.html">Unity3D 数据存储开发指南</a></li>
            <li><a href="realtime-unity.html">Unity3D 实时通信开发指南</a></li>
            <li><a href="analytics-guide.html">Unity3D 统计开发指南</a></li>
            <li role="separator" class="divider"></li>
            <li><a href="dotnet_push_guide.html">WP8.0 消息推送开发指南</a></li>
            <li role="separator" class="divider"></li>
            <!-- <li><a href="dotnet_faq.html">FAQ</a></li> -->
            <li><a href="/api-docs/dotnet/Help/index.html" target="_blank">.NET SDK API</a></li>
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Python</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-python.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-python.html">数据存储开发指南</a></li>
            <li><a href="relation-guide.html">数据模型设计指南</a></li>
            <li><a href="im-servermgmt-guide-python.html">实时通讯服务端管理开发指南</a></li>
            <li><a href="https://leancloud.readthedocs.io/" target="_blank">SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-python.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-python.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">PHP</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-php.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-php.html">数据存储开发指南</a></li>
            <li><a href="/api-docs/php/" target="_blank">SDK API</a></li>
            <li role="separator" class="divider"></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-php.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-php.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">Java</a>
          <ul class="dropdown-menu">
            <li><a href="sdk_setup-java.html">SDK 安装指南</a></li>
            <li><a href="leanstorage_guide-java.html">数据存储开发指南</a></li>
            <li><a href="sms-guide.html">短信 SMS 服务使用指南</a></li>
            <li class="dropdown-header">云引擎</li>
            <li><a href="leanengine_webhosting_guide-java.html">网站托管开发指南</a></li>
            <li><a href="leanengine_cloudfunction_guide-java.html">云函数开发指南</a></li>
          </ul>
        </li>
        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">REST API</a>
          <ul class="dropdown-menu">
            <li><a href="rest_api.html">数据存储 API</a></li>
            <li><a href="leanengine-rest-api.html">云引擎 API</a></li>
            <li><a href="rest_api.html#Push_通知">消息推送 API</a></li>
            <li><a href="realtime_rest_api.html">实时通信 API</a></li>
            
            <li><a href="rest_sms_api.html">短信验证 API</a></li>
            
            <li><a href="rest_api.html#统计数据_API">数据统计 API</a></li>
            <li><a href="status_system.html#REST_API">应用内社交 API</a></li>
            <li><a href="app_search_guide.html#搜索_API">应用内搜索 API</a></li>
            <li><a href="cql_guide.html">CQL 查询语言详解</a></li>
            <!--<li><a href="oauth2_provider.html">开放平台接入</a></li>-->
            <!-- <li><a href="rest_faq.html">FAQ</a></li> -->
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">云引擎</a>
          <ul class="dropdown-menu">
          <li><a href="leanengine_overview.html">云引擎总览</a></li>
          <li><a href="leanengine_quickstart.html">云引擎快速入门</a></li>
          <li><a href="leanengine_plan.html">云引擎运行方案</a></li>
          <li role="separator" class="divider"></li>
          <li class="dropdown-header">Node.js</li>
          <li><a href="leanengine_webhosting_guide-node.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-node.html">云函数开发指南</a></li>
          <li class="dropdown-header">Python</li>
          <li><a href="leanengine_webhosting_guide-python.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-python.html">云函数开发指南</a></li>
          <li class="dropdown-header">PHP</li>
          <li><a href="leanengine_webhosting_guide-php.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-php.html">云函数开发指南</a></li>
          <li class="dropdown-header">Java</li>
          <li><a href="leanengine_webhosting_guide-java.html">网站托管开发指南</a></li>
          <li><a href="leanengine_cloudfunction_guide-java.html">云函数开发指南</a></li>
          <li role="separator" class="divider"></li>
          <li><a href="leanengine_examples.html">云引擎项目示例</a></li>
          <li><a href="leanengine_cli.html">命令行工具 CLI</a></li>
          <li><a href="acl_guide_leanengine.html">在云引擎中管理 ACL</a></li>
          <li><a href="push-guide-leanengine.html">在云引擎中使用 Push 推送服务</a></li>
          <li><a href="leanengine_faq.html">FAQ</a></li>
          <li><a href="leancache_guide.html">LeanCache 使用指南</a></li>
          </ul>
        </li>

        <li class="dropdown">
          <a class="dropdown-toggle" role="button" data-toggle="dropdown" data-hover="dropdown" href="#">更多</a>
          <ul class="dropdown-menu">
            
            <li><a href="status_system.html">应用内社交使用指南</a></li>
            <li><a href="sns.html">第三方平台账号登录 SNS 开发指南</a></li>
            <li><a href="feedback.html">用户反馈开发指南</a></li>
            
            <li><a href="app_search_guide.html">应用内搜索和 DeepLink 开发指南</a></li>
            <li><a href="app_data_share.html">应用之间数据共享（Class 绑定）</a></li>
            <!-- <li><a href="user_groups.html">用户群分析指南</a></li> -->
            
            <li><a href="leaninsight_guide.html">离线数据分析使用指南</a></li>
            
            <li class="divider"></li>
            <li><a href="kb-network-connectivity-diagnosis.html">网络连通性诊断流程</a></li>
            <li class="divider"></li>
            <li><a href="tutorials.html">教程</a></li>
           <li><a href="demo.html">Demo</a></li>
          </ul>
        </li>
      </ul>
      <!-- <ul class="nav navbar-nav navbar-right">
        <li>
          <form action="/search.html" method="get" target="_blank" class="search-form">
            <input name="q" class="search-input" placeholder="搜索&hellip;">
          </form>
        </li>
      </ul> -->
    </nav>
  </div>
</header>


<div class="container-fluid">

  <div class="row">

    <div class="sidebar-gruntfile-trigger  col-sm-3" id="left-nav">

      <div class="sidebar-affix-shadow sidebar-hover-off">

        <div class="sidebar-wrapper" id="toc-wrapper">

        </div>
        <!-- .sidebar-wrapper -->

      </div>
      <!-- .sidebar-affix-shadow -->

    </div>
    <!-- .col-md-3 -->

    <div class="col-sm-9 sidebar-gruntfile-trigger">
      <div class="doc-content with-comment" id="content">
        <div class="docs-meta">
          <span class="icon icon-github"></span><a href="https://github.com/leancloud/docs#贡献">编辑文档</a>
        <span class="doc-mdate" data-toggle="tooltip" title="2017年10月25日上午10点53分">更新于 <time datetime="2017-10-25T10:53:03+08:00">2017-10-25</time></span></div>
        <h1 id="-middot-android">数据存储开发指南 &middot; Android</h1>
<p>数据存储（LeanStorage）是 LeanCloud 提供的核心功能之一，它的使用方法与传统的关系型数据库有诸多不同。下面我们将其与传统数据库的使用方法进行对比，让大家有一个初步了解。</p>
<p>下面这条 SQL 语句在绝大数的关系型数据库都可以执行，其结果是在 Todo 表里增加一条新数据：</p>
<pre><code class="lang-sql">INSERT INTO Todo (title, content) VALUES (&#39;工程师周会&#39;, &#39;每周工程师会议，周一下午 2 点&#39;)
</code></pre>
<p>使用传统的关系型数据库作为应用的数据源几乎无法避免以下步骤：</p>
<ul>
<li>插入数据之前一定要先创建一个表结构，并且随着之后需求的变化，开发者需要不停地修改数据库的表结构，维护表数据。</li>
<li>每次插入数据的时候，客户端都需要连接数据库来执行数据的增删改查（CRUD）操作。</li>
</ul>
<p>使用 LeanStorage，实现代码如下：</p>
<pre><code class="lang-java">        AVObject todo = new AVObject(&quot;Todo&quot;);
        todo.put(&quot;title&quot;, &quot;工程师周会&quot;);
        todo.put(&quot;content&quot;, &quot;每周工程师会议，周一下午2点&quot;);
        todo.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {
                    // 存储成功
                } else {
                    // 失败的话，请检查网络环境以及 SDK 配置是否正确
                }
            }
        });
</code></pre>
<p>使用 LeanStorage 的特点在于：</p>
<ul>
<li>不需要单独维护表结构。例如，为上面的 Todo 表新增一个 <code>location</code> 字段，用来表示日程安排的地点，那么刚才的代码只需做如下变动：</li>
</ul>
<pre><code class="lang-java">        AVObject todo = new AVObject(&quot;Todo&quot;);
        todo.put(&quot;title&quot;, &quot;工程师周会&quot;);
        todo.put(&quot;content&quot;, &quot;每周工程师会议，周一下午2点&quot;);
        todo.put(&quot;location&quot;, &quot;会议室&quot;);// 只要添加这一行代码，服务端就会自动添加这个字段
        todo.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {
                    // 存储成功
                } else {
                    // 失败的话，请检查网络环境以及 SDK 配置是否正确
                }
            }
        });
</code></pre>
<ul>
<li>数据可以随用随加，这是一种无模式化（Schema Free）的存储方式。</li>
<li>所有对数据的操作请求都通过 HTTPS 访问标准的 REST API 来实现。</li>
<li>我们为各个平台或者语言开发的 SDK 在底层都是调用统一的 REST API，并提供完整的接口对数据进行增删改查。</li>
</ul>
<p>LeanStorage 在结构化数据存储方面，与 DB 的区别在于：</p>
<ol>
<li>Schema Free／Not free 的差异；</li>
<li>数据接口上，LeanStorage 是面向对象的（数据操作接口都是基于 Object 的），开放的（所有移动端都可以直接访问），DB 是面向结构的，封闭的（一般在 Server 内部访问）；</li>
<li>数据之间关联的方式，DB 是主键外键模型，LeanStorage 则有自己的关系模型（Pointer、Relation 等）；</li>
</ol>
<p>LeanStorage 支持两种存储类型：</p>
<ul>
<li>对象</li>
<li>文件</li>
</ul>
<p>我们将按照顺序逐一介绍各类的使用方法。</p>
<h2 id="sdk-">SDK 安装</h2>
<p>请阅读 <a href="sdk_setup-android.html">Android 安装指南</a>。</p>
<h2 id="-">开启调试日志</h2>
<p>在应用开发阶段，你可以选择开启 SDK 的调试日志（debug log）来方便追踪问题。调试日志开启后，SDK 会把网络请求、错误消息等信息输出到 IDE 的日志窗口，或是浏览器 Console 或是 LeanCloud 控制台的 <a href="/dashboard/cloud.html?appid=#/log">云引擎日志</a> 中。</p>
<pre><code class="lang-java">// 放在 SDK 初始化语句 AVOSCloud.initialize() 后面，只需要调用一次即可
AVOSCloud.setDebugLogEnabled(true);
</code></pre>
  <div class="callout callout-danger">
  <p>在应用发布之前，请关闭调试日志，以免暴露敏感数据。</p>
</div>


<h2 id="-">对象</h2>
<p><code>AVObject</code> 是 LeanStorage 对复杂对象的封装，每个 <code>AVObject</code> 包含若干属性值对，也称键值对（key-value）。属性的值是与 JSON 格式兼容的数据。通过 REST API 保存对象需要将对象的数据通过 JSON 来编码。这个数据是无模式化的（Schema Free），这意味着你不需要提前标注每个对象上有哪些 key，你只需要随意设置 key-value 对就可以，云端会保存它。</p>
<h3 id="-">数据类型</h3>
<p><code>AVObject</code> 支持以下数据类型：</p>
<pre><code class="lang-java">        boolean bool = true;
        int number = 2015;
        String string = number + &quot; 年度音乐排行&quot;;
        Date date = new Date();

        byte[] data = &quot;短篇小说&quot;.getBytes();
        ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();
        arrayList.add(number);
        arrayList.add(string);
        HashMap&lt;Object, Object&gt; hashMap = new HashMap&lt;&gt;();
        hashMap.put(&quot;数字&quot;, number);
        hashMap.put(&quot;字符串&quot;, string);

        AVObject object = new AVObject(&quot;DataTypes&quot;);
        object.put(&quot;testBoolean&quot;, bool);
        object.put(&quot;testInteger&quot;, number);
        object.put(&quot;testDate&quot;, date);
        object.put(&quot;testData&quot;, data);
        object.put(&quot;testArrayList&quot;, arrayList);
        object.put(&quot;testHashMap&quot;, hashMap);
        object.saveInBackground();
</code></pre>
<p>此外，HashMap 和 ArrayList 支持嵌套，这样在一个 <code>AVObject</code> 中就可以使用它们来储存更多的结构化数据。</p>
<p>注意，时间类型在云端将会以 UTC 时间格式存储，但是客户端在读取之后会做转化成本地时间。</p>
<p>我们<strong>不推荐</strong>在 <code>AVObject</code> 中使用 <code>byte[]</code> 来储存大块的二进制数据，比如图片或整个文件。<strong>每个 <code>AVObject</code> 的大小都不应超过 128 KB</strong>。如果需要储存更多的数据，建议使用 <a href="#文件"><code>AVFile</code></a>。</p>
<p>若想了解更多有关 LeanStorage 如何解析处理数据的信息，请查看专题文档《<a href="./data_security.html">数据与安全</a>》。</p>
<h3 id="-">构建对象</h3>
<p>构建一个 <code>AVObject</code> 可以使用如下方式：</p>
<pre><code class="lang-java">        // 构造方法传入的参数，对应的就是控制台中的 Class Name
        AVObject todo = new AVObject(&quot;Todo&quot;);
</code></pre>
<p>每个 objectId 必须有一个 Class 类名称，这样云端才知道它的数据归属于哪张数据表。</p>
  <div class="callout callout-danger">
  <p>Class 类名称（ClassName）必须以字母开头，只能包含字母、数字和下划线。</p>
</div>


<h3 id="-">保存对象</h3>
<p>现在我们保存一个 <code>TodoFolder</code>，它可以包含多个 Todo，类似于给行程按文件夹的方式分组。我们并不需要提前去后台创建这个名为 <strong>TodoFolder</strong> 的 Class 类，而仅需要执行如下代码，云端就会自动创建这个类：</p>
<pre><code class="lang-java">        AVObject todoFolder = new AVObject(&quot;TodoFolder&quot;);// 构建对象
        todoFolder.put(&quot;name&quot;, &quot;工作&quot;);// 设置名称
        todoFolder.put(&quot;priority&quot;, 1);// 设置优先级
        todoFolder.saveInBackground();// 保存到服务端
</code></pre>
<p>创建完成后，打开 <a href="/data.html?appid={{appid}}#/">控制台 &gt; 存储</a>，点开 <strong>TodoFolder</strong> 类，就可以看到刚才添加的数据。除了 name、priority（优先级）之外，其他字段都是数据表的内置属性。</p>
<table>
<thead>
<tr>
<th>内置属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>objectId</code></td>
<td>String</td>
<td>该对象唯一的 Id 标识</td>
</tr>
<tr>
<td><code>ACL</code></td>
<td>ACL</td>
<td>该对象的权限控制，实际上是一个 JSON 对象，控制台做了展现优化。</td>
</tr>
<tr>
<td><code>createdAt</code></td>
<td>Date</td>
<td>该对象被创建的 UTC 时间</td>
</tr>
<tr>
<td><code>updatedAt</code></td>
<td>Date</td>
<td>该对象最后一次被修改的时间</td>
</tr>
</tbody>
</table>
<dl>
  <dt>属性名</dt>
  <dd>也叫键或 key，必须是由字母、数字或下划线组成的字符串。<br>自定义的属性名，<span class="callout-danger" style="background-color: transparent;">不能以双下划线 <code>__</code> 开头，也不能与以下系统保留字段和内置属性重名（不区分大小写）</span>。
  <div class="callout callout-danger monospace" style="margin-top:1em;color:#999;">
  ACL、className、createdAt、objectId、updatedAt</div></dd>
  <dt>属性值</dt>
  <dd>可以是字符串、数字、布尔值、数组或字典。</dd>
</dl>

<p>为提高代码的可读性和可维护性，建议使用驼峰式命名法（CamelCase）为类和属性来取名。类，采用大驼峰法，如 <code>CustomData</code>。属性，采用小驼峰法，如 <code>imageUrl</code>。</p>
<h4 id="-cql-">使用 CQL 语法保存对象</h4>
<p>LeanStorage 提供了类似 SQL 语法中的 Insert 方式保存一个对象，例如保存一个 TodoFolder 对象可以使用下面的代码：</p>
<pre><code class="lang-java">        // 执行 CQL 语句实现新增一个 TodoFolder 对象
        AVQuery.doCloudQueryInBackground(&quot;insert into TodoFolder(name, priority) values(&#39;工作&#39;, 1)&quot;, new CloudQueryCallback&lt;AVCloudQueryResult&gt;() {
            @Override
            public void done(AVCloudQueryResult avCloudQueryResult, AVException e) {
                // 如果 e 为空，说明保存成功
            }
        });
</code></pre>
<h4 id="-">保存选项</h4>
<p><code>AVObject</code> 对象在保存时可以设置选项来快捷完成关联操作，可用的选项属性有：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="text-nowrap">fetchWhenSave</code></td>
<td>Boolean</td>
<td>对象成功保存后，自动返回本地<strong>已改动属性</strong>在云端的最新值。用途请参考 <a href="#更新计数器">更新计数器</a>。</td>
</tr>
<tr>
<td><code>query</code></td>
<td>AVQuery</td>
<td>当 query 中的条件满足后对象才能成功保存，否则放弃保存，并返回错误码 305。<br><br>开发者原本可以通过 <code>AVQuery</code> 和 <code>AVObject</code> 分两步来实现这样的逻辑，但如此一来无法保证操作的原子性从而导致并发问题。该选项可以用来判断多用户更新同一对象数据时可能引发的冲突。</td>
</tr>
</tbody>
</table>
<p><a id="saveoption_query_example" name="saveoption_query_example"></a>【query 选项举例】用户的账务账户表 <code>Account</code> 有一个余额字段 <code>balance</code>，同时有多个请求要修改该字段值，为避免余额出现负值，只有满足 <strong>balance &gt;= 当前请求的数值</strong> 这个条件才允许修改，否则提示「余额不足，操作失败！」。</p>
<pre><code class="lang-java">    final int amount = -100;
    AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Account&quot;);
    query.getFirstInBackground(new GetCallback&lt;AVObject&gt;() {
        @Override
        public void done(final AVObject account, AVException e) {
            account.increment(&quot;balance&quot;, amount);
            AVSaveOption option = new AVSaveOption();
            option.query(new AVQuery&lt;&gt;(&quot;Account&quot;).whereGreaterThanOrEqualTo(&quot;balance&quot;, -amount));
            option.setFetchWhenSave(true);
            account.saveInBackground(option, new SaveCallback() {
                @Override
                public void done(AVException e) {
                    if (e == null) {
                        System.out.println(&quot;当前余额为：&quot; + account.get(&quot;balance&quot;));
                    } else {
                        System.out.println(&quot;余额不足，操作失败！&quot;);
                    }
                }
            });
        }
    });
</code></pre>
<h3 id="-">获取对象</h3>
<p>每个被成功保存在云端的对象会有一个唯一的 Id 标识 <code>objectId</code>，因此获取对象的最基本的方法就是根据 <code>objectId</code> 来查询：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; avQuery = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        avQuery.getInBackground(&quot;558e20cbe4b060308e3eb36c&quot;, new GetCallback&lt;AVObject&gt;() {
            @Override
            public void done(AVObject avObject, AVException e) {
                // object 就是 id 为 558e20cbe4b060308e3eb36c 的 Todo 对象实例
            }
        });
</code></pre>
<p>除了使用 <code>AVQuery</code>，还可以采用在本地构建一个 <code>AVObject</code> 的方式，通过接口和 objectId 把数据从云端拉取到本地：</p>
<pre><code class="lang-java">        // 第一参数是 className,第二个参数是 objectId
        AVObject todo = AVObject.createWithoutData(&quot;Todo&quot;, &quot;558e20cbe4b060308e3eb36c&quot;);
        todo.fetchInBackground(new GetCallback&lt;AVObject&gt;() {
            @Override
            public void done(AVObject avObject, AVException e) {
                String title = avObject.getString(&quot;title&quot;);// 读取 title
                String content = avObject.getString(&quot;content&quot;);// 读取 content
            }
        });
</code></pre>
<h4 id="-objectid">获取 objectId</h4>
<p>每一次对象存储成功之后，云端都会返回 <code>objectId</code>，它是一个全局唯一的属性。</p>
<pre><code class="lang-java">        final AVObject todo = new AVObject(&quot;Todo&quot;);
        todo.put(&quot;title&quot;, &quot;工程师周会&quot;);
        todo.put(&quot;content&quot;, &quot;每周工程师会议，周一下午2点&quot;);
        todo.put(&quot;location&quot;, &quot;会议室&quot;);// 只要添加这一行代码，服务端就会自动添加这个字段
        todo.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {
                    // 存储成功
                    Log.d(TAG, todo.getObjectId());// 保存成功之后，objectId 会自动从服务端加载到本地
                } else {
                    // 失败的话，请检查网络环境以及 SDK 配置是否正确
                }
            }
        });
</code></pre>
<h4 id="-">访问对象的属性</h4>
<p>访问 Todo 的属性的方式为：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; avQuery = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        avQuery.getInBackground(&quot;558e20cbe4b060308e3eb36c&quot;, new GetCallback&lt;AVObject&gt;() {
            @Override
            public void done(AVObject avObject, AVException e) {
                // object 就是 id 为 558e20cbe4b060308e3eb36c 的 Todo 对象实例

                int priority = avObject.getInt(&quot;priority&quot;);
                String location = avObject.getString(&quot;location&quot;);
                String title = avObject.getString(&quot;title&quot;);
                String content = avObject.getString(&quot;content&quot;);

                // 获取三个特殊属性
                String objectId = avObject.getObjectId();
                Date updatedAt = avObject.getUpdatedAt();
                Date createdAt = avObject.getCreatedAt();
            }
        });
</code></pre>
<p>请注意以上代码中访问三个特殊属性 <code>objectId</code>、<code>createdAt</code>、<code>updatedAt</code> 的方式。</p>
<p>如果访问了并不存在的属性，SDK 并不会抛出异常，而是会返回空值。</p>
<h4 id="-">默认属性</h4>
<p>默认属性是所有对象都会拥有的属性，它包括 <code>objectId</code>、<code>createdAt</code>、<code>updatedAt</code>。</p>
<dl>
  <dt><code>createdAt</code></dt>
  <dd>对象第一次保存到云端的时间戳。该时间一旦被云端创建，在之后的操作中就不会被修改。</dd>
  <dt><code>updatedAt</code></dt>
  <dd>对象最后一次被修改（或最近一次被更新）的时间。</dd>
</dl>

<p>注：应用控制台对 <code>createdAt</code> 和 <code>updatedAt</code> 做了在展示优化，它们会依据用户操作系统时区而显示为本地时间；客户端 SDK 获取到这些时间后也会将其转换为本地时间；而通过 REST API 获取到的则是原始的 UTC 时间，开发者可能需要根据情况做相应的时区转换。 </p>
<h4 id="-">同步对象</h4>
<p>多终端共享一个数据时，为了确保当前客户端拿到的对象数据是最新的，可以调用刷新接口来确保本地数据与云端的同步：</p>
<pre><code class="lang-java">        // 假如已知了 objectId 可以用如下的方式构建一个 AVObject
        AVObject anotherTodo = AVObject.createWithoutData(&quot;Todo&quot;, &quot;5656e37660b2febec4b35ed7&quot;);
        // 然后调用刷新的方法，将数据从服务端拉到本地
        anotherTodo.fetchInBackground(new GetCallback&lt;AVObject&gt;() {
            @Override
            public void done(AVObject avObject, AVException e) {
                // 调用 fetchInBackground 和 refreshInBackground 效果是一样的。
            }
        });
</code></pre>
<p>在更新对象操作后，对象本地的 <code>updatedAt</code> 字段（最后更新时间）会被刷新，直到下一次 save 或 fetch 操作，<code>updatedAt</code> 的最新值才会被同步到云端，这样做是为了减少网络流量传输。</p>
<h4 id="-">同步指定属性</h4>
<p>目前 Todo 这个类已有四个自定义属性：<code>priority</code>、<code>content</code>、<code>location</code> 和 <code>title</code>。为了节省流量，现在只想刷新 <code>priority</code> 和 <code>location</code> 可以使用如下方式：</p>
<pre><code class="lang-java">        AVObject theTodo = AVObject.createWithoutData(&quot;Todo&quot;, &quot;564d7031e4b057f4f3006ad1&quot;);
        String keys = &quot;priority,location&quot;;// 指定刷新的 key 字符串
        theTodo.fetchInBackground(keys, new GetCallback&lt;AVObject&gt;() {
            @Override
            public void done(AVObject avObject, AVException e) {
                // theTodo 的 location 和 content 属性的值就是与服务端一致的
                String priority = avObject.getString(&quot;priority&quot;);
                String location = avObject.getString(&quot;location&quot;);
            }
        });
</code></pre>
<p><strong>刷新操作会强行使用云端的属性值覆盖本地的属性</strong>。因此如果本地有属性修改，刷新操作会丢弃这些修改。</p>
<h3 id="-">更新对象</h3>
<p>LeanStorage 上的更新对象都是针对单个对象，云端会根据<u>有没有 objectId</u> 来决定是新增还是更新一个对象。</p>
<p>假如 <code>objectId</code> 已知，则可以通过如下接口从本地构建一个 <code>AVObject</code> 来更新这个对象：</p>
<pre><code class="lang-java">        // 第一参数是 className,第二个参数是 objectId
        AVObject todo = AVObject.createWithoutData(&quot;Todo&quot;, &quot;558e20cbe4b060308e3eb36c&quot;);

        // 修改 content
        todo.put(&quot;content&quot;,&quot;每周工程师会议，本周改为周三下午3点半。&quot;);
        // 保存到云端
        todo.saveInBackground();
</code></pre>
<p>更新操作是覆盖式的，云端会根据最后一次提交到服务器的有效请求来更新数据。更新是字段级别的操作，未更新的字段不会产生变动，这一点请不用担心。</p>
<h4 id="-cql-">使用 CQL 语法更新对象</h4>
<p>LeanStorage 提供了类似 SQL 语法中的 Update 方式更新一个对象，例如更新一个 TodoFolder 对象可以使用下面的代码：</p>
<pre><code class="lang-java">        // 执行 CQL 语句实现更新一个 TodoFolder 对象
        AVQuery.doCloudQueryInBackground(&quot;update TodoFolder set name=&#39;家庭&#39; where objectId=&#39;558e20cbe4b060308e3eb36c&#39;&quot;, new CloudQueryCallback&lt;AVCloudQueryResult&gt;() {
            @Override
            public void done(AVCloudQueryResult avCloudQueryResult, AVException e) {
                // 如果 e 为空，说明保存成功
            }
        });
</code></pre>
<h4 id="-">更新计数器</h4>
<p>这是原子操作（Atomic Operation）的一种。
为了存储一个整型的数据，LeanStorage 提供对任何数字字段进行原子增加（或者减少）的功能。比如一条微博，我们需要记录有多少人喜欢或者转发了它，但可能很多次喜欢都是同时发生的。如果在每个客户端都直接把它们读到的计数值增加之后再写回去，那么极容易引发冲突和覆盖，导致最终结果不准。此时就需要使用这类原子操作来实现计数器。</p>
<p>假如，现在增加一个记录查看 Todo 次数的功能，一些与他人共享的 Todo 如果不用原子操作的接口，很有可能会造成统计数据不准确，可以使用如下代码实现这个需求：</p>
<pre><code class="lang-java">        final AVObject theTodo = AVObject.createWithoutData(&quot;Todo&quot;, &quot;564d7031e4b057f4f3006ad1&quot;);
        theTodo.put(&quot;views&quot;, 0);//初始值为 0
        theTodo.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
                // 原子增加查看的次数
                theTodo.increment(&quot;views&quot;);
                theTodo.setFetchWhenSave(true);
                theTodo.saveInBackground();
                // 也可以使用 incrementKey:byAmount: 来给 Number 类型字段累加一个特定数值。
                theTodo.increment(&quot;views&quot;, 5);
                theTodo.saveInBackground();
                //saveInBackground 调用之后，如果成功的话，对象的计数器字段是当前系统最新值。
            }
        });
</code></pre>
<h4 id="-">更新数组</h4>
<p>更新数组也是原子操作。使用以下方法可以方便地维护数组类型的数据：</p>
<ul>
<li><code>add()</code><br>
将指定对象附加到数组末尾。</li>
<li><code>addUnique()</code><br>
如果数组中不包含指定对象，将该对象加入数组，对象的插入位置是随机的。</li>
<li><code>removeAll()</code><br>
从数组字段中删除指定对象的所有实例。</li>
</ul>
<p>例如，Todo 对象有一个提醒时间 <code>reminders</code> 字段，是一个数组，代表这个日程会在哪些时间点提醒用户。比如有个拖延症患者把闹钟设为早上的 7:10、7:20、7:30：</p>
<pre><code class="lang-java">    Date getDateWithDateString(String dateString) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        Date date = dateFormat.parse(dateString);
        return date;
    }

    void addReminders() {
        Date reminder1 = getDateWithDateString(&quot;2015-11-11 07:10:00&quot;);
        Date reminder2 = getDateWithDateString(&quot;2015-11-11 07:20:00&quot;);
        Date reminder3 = getDateWithDateString(&quot;2015-11-11 07:30:00&quot;);

        AVObject todo = new AVObject(&quot;Todo&quot;);
        todo.addAllUnique(&quot;reminders&quot;, Arrays.asList(reminder1, reminder2, reminder3));
        todo.saveInBackground();
    }
</code></pre>
<h3 id="-">删除对象</h3>
<p>假如某一个 Todo 完成了，用户想要删除这个 Todo 对象，可以如下操作：</p>
<pre><code class="lang-java">        todo.deleteInBackground();
</code></pre>
<div class="callout callout-danger">删除对象是一个较为敏感的操作。在控制台创建对象的时候，默认开启了权限保护，关于这部分的内容请阅读《<a href="acl-guide.html">ACL 权限管理指南</a>》。</div>

<h4 id="-cql-">使用 CQL 语法删除对象</h4>
<p>LeanStorage 提供了类似 SQL 语法中的 Delete 方式删除一个对象，例如删除一个 Todo 对象可以使用下面的代码：</p>
<pre><code class="lang-java">        // 执行 CQL 语句实现删除一个 Todo 对象
        AVQuery.doCloudQueryInBackground(&quot;delete from Todo where objectId=&#39;558e20cbe4b060308e3eb36c&#39;&quot;, new CloudQueryCallback&lt;AVCloudQueryResult&gt;() {
            @Override
            public void done(AVCloudQueryResult avCloudQueryResult, AVException e) {
                // 如果 e 为空，说明保存成功
            }
        });
</code></pre>
<h3 id="-">批量操作</h3>
<p>为了减少网络交互的次数太多带来的时间浪费，你可以在一个请求中对多个对象进行创建、更新、删除、获取。接口都在 <code>AVObject</code> 这个类下面：</p>
<pre><code class="lang-java">// 批量创建、更新
saveAll()
saveAllInBackground()

// 批量删除
deleteAll()
deleteAllInBackground()

// 批量获取
fetchall()
fetchAllInBackground()
</code></pre>
<p>批量设置 Todo 已经完成：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                ArrayList&lt;AVObject&gt; todos = (ArrayList&lt;AVObject&gt;) list;
                for (AVObject todo : list) {
                    todo.put(&quot;status&quot;, 1);
                }

                AVObject.saveAllInBackground(todos, new SaveCallback() {
                    @Override
                    public void done(AVException e) {
                        if (e != null) {
                            // 出现错误
                        } else {
                            // 保存成功
                        }
                    }
                });
            }
        });
</code></pre>
<p>不同类型的批量操作所引发不同数量的 API 调用，具体请参考 <a href="faq.html#API_调用次数的计算">API 调用次数的计算</a>。</p>
<h3 id="-">后台运行</h3>
<p>细心的开发者已经发现，在所有的示例代码中几乎都是用了异步来访问 LeanStorage 云端，形如 <code>xxxxInBackground</code> 的方法都是提供给开发者在主线程调用用以实现后台运行的方法，因此开发者在主线程可以放心的调用这种命名方式的函数。另外，需要强调的是：<strong>回调函数的代码是在主线程执行。</strong></p>
<h3 id="-">离线存储对象</h3>
<p>大多数保存功能可以立刻执行，并通知应用「保存完毕」。不过若不需要知道保存完成的时间，则可使用 saveEventually 来代替。</p>
<p>它的优点在于：如果用户目前尚未接入网络，saveEventually 会缓存设备中的数据，并在网络连接恢复后上传。如果应用在网络恢复之前就被关闭了，那么当它下一次打开时，LeanStorage 会再次尝试保存操作。</p>
<p>所有 saveEventually（或 deleteEventually）的相关调用，将按照调用的顺序依次执行。因此，多次对某一对象使用 saveEventually 是安全的。</p>
<h3 id="-">关联数据</h3>
<h4 id="-avrelation-"><code>AVRelation</code>（已弃用）</h4>
  <div class="callout callout-danger">
  <p>以下文档仅供还在使用 Relation 的开发者做参考。对关联数据进行查询、排序等复杂操作，请使用 <a href="relation-guide.html#使用中间表实现多对多关系_推荐_">中间表</a>。</p>
</div>


<p>对象可以与其他对象相联系。如前面所述，我们可以把一个 <code>AVObject</code> 的实例 A，当成另一个 <code>AVObject</code> 实例 B 的属性值保存起来。这可以解决数据之间一对一或者一对多的关系映射，就像关系型数据库中的主外键关系一样。</p>
<p>例如，一个 TodoFolder 包含多个 Todo，可以用如下代码实现：</p>
<pre><code class="lang-java">        final AVObject todoFolder = new AVObject(&quot;TodoFolder&quot;);// 构建对象
        todoFolder.put(&quot;name&quot;, &quot;工作&quot;);
        todoFolder.put(&quot;priority&quot;, 1);

        final AVObject todo1 = new AVObject(&quot;Todo&quot;);
        todo1.put(&quot;title&quot;, &quot;工程师周会&quot;);
        todo1.put(&quot;content&quot;, &quot;每周工程师会议，周一下午2点&quot;);
        todo1.put(&quot;location&quot;, &quot;会议室&quot;);

        final AVObject todo2 = new AVObject(&quot;Todo&quot;);
        todo2.put(&quot;title&quot;, &quot;维护文档&quot;);
        todo2.put(&quot;content&quot;, &quot;每天 16：00 到 18：00 定期维护文档&quot;);
        todo2.put(&quot;location&quot;, &quot;当前工位&quot;);

        final AVObject todo3 = new AVObject(&quot;Todo&quot;);
        todo3.put(&quot;title&quot;, &quot;发布 SDK&quot;);
        todo3.put(&quot;content&quot;, &quot;每周一下午 15：00&quot;);
        todo3.put(&quot;location&quot;, &quot;SA 工位&quot;);

        AVObject.saveAllInBackground(Arrays.asList(todo1, todo2, todo3), new SaveCallback() {
            @Override
            public void done(AVException e) {
                AVRelation&lt;AVObject&gt; relation = todoFolder.getRelation(&quot;containedTodos&quot;);// 新建一个 AVRelation
                relation.add(todo1);
                relation.add(todo2);
                relation.add(todo3);
                // 上述 3 行代码表示 relation 关联了 3 个 Todo 对象

                todoFolder.saveInBackground();
            }
        });
</code></pre>
<h4 id="pointer">Pointer</h4>
<p>Pointer 只是个描述并没有具象的类与之对应，它与 <code>AVRelation</code> 不一样的地方在于：<code>AVRelation</code> 是在<strong>一对多</strong>的「一」这一方（上述代码中的一指 TodoFolder）保存一个 <code>AVRelation</code> 属性，这个属性实际上保存的是对被关联数据<strong>多</strong>的这一方（上述代码中这个多指 Todo）的一个 Pointer 的集合。而反过来，LeanStorage 也支持在「多」的这一方保存一个指向「一」的这一方的 Pointer，这样也可以实现<strong>一对多</strong>的关系。</p>
<p>简单的说， Pointer 就是一个外键的指针，只是在 LeanCloud 控制台做了显示优化。</p>
<p>现在有一个新的需求：用户可以分享自己的 TodoFolder 到广场上，而其他用户看见可以给与评论，比如某玩家分享了自己想买的游戏列表（TodoFolder 包含多个游戏名字），而我们用 Comment 对象来保存其他用户的评论以及是否点赞等相关信息，代码如下：</p>
<pre><code class="lang-java">        AVObject comment = new AVObject(&quot;Comment&quot;);// 构建 Comment 对象
        comment.put(&quot;likes&quot;, 1);// 如果点了赞就是 1，而点了不喜欢则为 -1，没有做任何操作就是默认的 0
        comment.put(&quot;content&quot;, &quot;这个太赞了！楼主，我也要这些游戏，咱们团购么？&quot;);// 留言的内容

        // 假设已知了被分享的该 TodoFolder 的 objectId 是 5590cdfde4b00f7adb5860c8
        comment.put(&quot;targetTodoFolder&quot;, AVObject.createWithoutData(&quot;TodoFolder&quot;, &quot;5590cdfde4b00f7adb5860c8&quot;));
        // 以上代码就是的执行结果就会在 comment 对象上有一个名为 targetTodoFolder 属性，它是一个 Pointer 类型，指向 objectId 为 5590cdfde4b00f7adb5860c8 的 TodoFolder
</code></pre>
<h5 id="-pointer-">获取 Pointer 对象</h5>
<p>当 Todo 拥有一个字段叫做 TodoFolder 的 Pointer 类型的属性，在获取 Todo 的对象的同时，想一并把被关联的 TodoFolder 也拉取到本地：</p>
<p>更多内容可参考 <a href="relation-guide.html#Pointers_查询">关联数据查询</a>。</p>
<h4 id="-">地理位置</h4>
<p>地理位置是一个特殊的数据类型，LeanStorage 封装了 <code>AVGeoPoint</code> 来实现存储以及相关的查询。</p>
<p>首先要创建一个 <code>AVGeoPoint</code> 对象。例如，创建一个北纬 39.9 度、东经 116.4 度的 <code>AVGeoPoint</code> 对象（LeanCloud 北京办公室所在地）：</p>
<pre><code class="lang-java">        AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
</code></pre>
<p>假如，添加一条 Todo 的时候为该 Todo 添加一个地理位置信息，以表示创建时所在的位置：</p>
<pre><code class="lang-java">        todo.put(&quot;whereCreated&quot;, point);
</code></pre>
<p>同时请参考 <a href="#地理位置查询">地理位置查询</a>。</p>
<h3 id="-">序列化和反序列化</h3>
<p>在实际的开发中，把 <code>AVObject</code> 当做参数传递的时候，会涉及到复杂对象的拷贝的问题，因此 <code>AVObject</code> 也提供了序列化和反序列化的方法：</p>
<p>序列化：</p>
<pre><code class="lang-java">        AVObject todoFolder = new AVObject(&quot;TodoFolder&quot;);// 构建对象
        todoFolder.put(&quot;name&quot;, &quot;工作&quot;);// 设置名称
        todoFolder.put(&quot;priority&quot;, 1);// 设置优先级
        todoFolder.put(&quot;owner&quot;, AVUser.getCurrentUser());// 这里就是一个 Pointer 类型，指向当前登录的用户
        String serializedString = todoFolder.toString();
</code></pre>
<p>反序列化：</p>
<pre><code class="lang-java">        AVObject deserializedObject = AVObject.parseAVObject(serializedString);
        deserializedObject.saveInBackground();// 保存到服务端
</code></pre>
<h3 id="-">数据协议</h3>
<p>很多开发者在使用 LeanStorage 初期都会产生疑惑：客户端的数据类型是如何被云端识别的？
因此，我们有必要重点介绍一下 LeanStorage 的数据协议。</p>
<p>先从一个简单的日期类型入手，比如在 Android 中，默认的日期类型是 <code>Date</code>，下面会详细讲解一个
 <code>Date</code> 是如何被云端正确的按照日期格式存储的。</p>
<p>为一个普通的 <code>AVObject</code> 的设置一个 <code>Date</code> 的属性，然后调用保存的接口：</p>
<p>Android SDK 在真正调用保存接口之前，会自动的调用一次序列化的方法，将 <code>Date</code> 类型的数据，转化为如下格式的数据：</p>
<pre><code class="lang-json">{
  &quot;__type&quot;: &quot;Date&quot;,
  &quot;iso&quot;: &quot;2015-11-21T18:02:52.249Z&quot;
}
</code></pre>
<p>然后发送给云端，云端会自动进行反序列化，这样自然就知道这个数据类型是日期，然后按照传过来的有效值进行存储。因此，开发者在进阶开发的阶段，最好是能掌握 LeanStorage 的数据协议。如下表介绍的就是一些默认的数据类型被序列化之后的格式：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>序列化之后的格式</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Date</code></td>
<td><code>{&quot;__type&quot;: &quot;Date&quot;,&quot;iso&quot;: &quot;2015-11-21T18:02:52.249Z&quot;}</code></td>
</tr>
<tr>
<td><code>byte[]</code></td>
<td><code>{&quot;__type&quot;: &quot;Bytes&quot;,&quot;base64&quot;:&quot;utf-8-encoded-string}&quot;</code></td>
</tr>
<tr>
<td><code>Pointer</code></td>
<td><code>{&quot;__type&quot;:&quot;Pointer&quot;,&quot;className&quot;:&quot;Todo&quot;,&quot;objectId&quot;:&quot;55a39634e4b0ed48f0c1845c&quot;}</code></td>
</tr>
<tr>
<td><code>AVRelation</code></td>
<td><code>{&quot;__type&quot;: &quot;Relation&quot;,&quot;className&quot;: &quot;Todo&quot;}</code></td>
</tr>
</tbody>
</table>
<h2 id="-">文件</h2>
<p>文件存储也是数据存储的一种方式，图像、音频、视频、通用文件等等都是数据的载体。很多开发者也习惯把复杂对象序列化之后保存成文件，比如 JSON 或 XML 文件。文件存储在 LeanStorage 中被单独封装成一个 <code>AVFile</code> 来实现文件的上传、下载等操作。</p>
<h3 id="-">文件上传</h3>
<p>文件上传是指开发者调用接口将文件存储在云端，并且返回文件最终的 URL 的操作。</p>
<p>文件上传成功后会在系统表 <code>_File</code> 中生成一条记录，<strong>此后该记录无法被再次修改</strong>，包括 <a href="#文件元数据">metaData 字段</a> 中的数据。所以如需更新该文件的记录内容，只能重新上传文件，得到新的 id 和 URL。</p>
<p>如果 <code>_File</code> 表打开了 <a href="#删除">删除权限</a>，该记录才可以被删除。</p>
<h4 id="-">从数据流构建文件</h4>
<p><code>AVFile</code> 支持图片、视频、音乐等常见的文件类型，以及其他任何二进制数据，在构建的时候，传入对应的数据流即可：</p>
<pre><code class="lang-java">        AVFile file = new AVFile(&quot;resume.txt&quot;,&quot;Working with LeanCloud is great!&quot;.getBytes());
</code></pre>
<p>上例将文件命名为 <code>resume.txt</code>，这里需要注意两点：</p>
<ul>
<li>不必担心文件名冲突。每一个上传的文件都有惟一的 ID，所以即使上传多个文件名为 <code>resume.txt</code> 的文件也不会有问题。</li>
<li>给文件添加扩展名非常重要。云端通过扩展名来判断文件类型，以便正确处理文件。所以要将一张 PNG 图片存到 <code>AVFile</code> 中，要确保使用 <code>.png</code> 扩展名。</li>
</ul>
<h4 id="-">从本地路径构建文件</h4>
<p>大多数的客户端应用程序都会跟本地文件系统产生交互，常用的操作就是读取本地文件，如下代码可以实现使用本地文件路径构建一个 <code>AVFile</code>：</p>
<pre><code class="lang-java">        AVFile file = AVFile.withAbsoluteLocalPath(&quot;LeanCloud.png&quot;, Environment.getExternalStorageDirectory() + &quot;/LeanCloud.png&quot;);
</code></pre>
<h4 id="-">从网络路径构建文件</h4>
<p>从一个已知的 URL 构建文件也是很多应用的需求。例如，从网页上拷贝了一个图像的链接，代码如下：</p>
<pre><code class="lang-java">        AVFile file = new AVFile(&quot;test.gif&quot;, &quot;http://ww3.sinaimg.cn/bmiddle/596b0666gw1ed70eavm5tg20bq06m7wi.gif&quot;, new HashMap&lt;String, Object&gt;());
</code></pre>
<p><a href="#从本地路径构建文件">从本地路径构建文件</a> 会<u>产生实际上传的流量</u>，并且文件最后是存在云端，而 <a href="#从网络路径构建文件">从网络路径构建文件</a> 的文件实体并不存储在云端，只是会把文件的物理地址作为一个字符串保存在云端。</p>
<h4 id="-">执行上传</h4>
<p>上传的操作调用方法如下：</p>
<pre><code class="lang-java">        file.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
                Log.d(TAG, file.getUrl());//返回一个唯一的 Url 地址
            }
        });
</code></pre>
<h4 id="-">上传进度监听</h4>
<p>一般来说，上传文件都会有一个上传进度条显示用以提高用户体验：</p>
<pre><code class="lang-java">        file.saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
                // 成功或失败处理...
            }
        }, new ProgressCallback() {
            @Override
            public void done(Integer integer) {
                // 上传进度数据，integer 介于 0 和 100。
            }
        });
</code></pre>
<h3 id="-">文件下载</h3>
<p>客户端 SDK 接口可以下载文件并把它缓存起来，只要文件的 URL 不变，那么一次下载成功之后，就不会再重复下载，目的是为了减少客户端的流量。</p>
<pre><code class="lang-java">        file.getDataInBackground(new GetDataCallback() {
            @Override
            public void done(byte[] bytes, AVException e) {
                // bytes 就是文件的数据流
            }
        }, new ProgressCallback() {
            @Override
            public void done(Integer integer) {
                // 下载进度数据，integer 介于 0 和 100。
            }
        });
</code></pre>
<p>请注意代码中<strong>下载进度</strong>数据的读取。</p>
<h3 id="-">图像缩略图</h3>
<p>保存图像时，如果想在下载原图之前先得到缩略图，方法如下：</p>
<pre><code class="lang-java">        AVFile file = new AVFile(&quot;test.jpg&quot;, &quot;文件-url&quot;, new HashMap&lt;String, Object&gt;());
        file.getThumbnailUrl(true, 100, 100);
</code></pre>
<div class="callout callout-info">图片最大不超过 <strong>20 MB</strong> 才可以获取缩略图。</div>

<div class="callout callout-danger">图片缩略图只支持华北节点的应用，华东和北美节点不支持。</div>


<h3 id="-">文件元数据</h3>
<p><code>AVFile</code> 的 <code>metaData</code> 属性，可以用来保存和获取该文件对象的元数据信息。metaData 一旦保存到云端就<strong>无法再次修改</strong>。 </p>
<pre><code class="lang-java">        AVFile file = AVFile.withAbsoluteLocalPath(&quot;test.jpg&quot;, Environment.getExternalStorageDirectory() + &quot;/xxx.jpg&quot;);
        file.addMetaData(&quot;width&quot;, 100);
        file.addMetaData(&quot;height&quot;, 100);
        file.addMetaData(&quot;author&quot;, &quot;LeanCloud&quot;);
        file.saveInBackground();
</code></pre>
<h3 id="-">删除</h3>
<p>当文件较多时，要把一些不需要的文件从云端删除：</p>
<div class="callout callout-danger">默认情况下，文件的删除权限是关闭的，需要进入 <a href="/data.html?appid={{appid}}#/_File">控制台 &gt; 存储 &gt; <strong><code>_File</code></strong></a>，选择菜单 <strong>其他</strong> &gt; <strong>权限设置</strong> &gt; <strong>delete</strong> 来开启。</div>



<pre><code class="lang-java">        file.deleteInBackground(new DeleteCallback() {
            @Override
            public void done(AVException e) {

            }
        });
</code></pre>
<h3 id="cdn-">CDN 加速</h3>
<div id="accordion-cdn">
  <p>中国节点的文件存储服务自带 <a href="https://baike.baidu.com/item/CDN">CDN 加速访问</a>。
美国节点没有现成的 CDN 加速访问服务，需要用户自行配置（<a class="accordion-toggle" data-toggle="collapse" parent="#accordion-cdn" href="#collapse-cdn">步骤</a>）。</p>
  <div id="collapse-cdn" class="panel-collapse collapse">
    <p>以 CloudFront 加速服务为例，配置过程如下：</p>
    <ol>
    <li>阅读官方指南 <a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html">Getting Started with CloudFront</a>。</li>
    <li>创建一个 AWS 账户，开始使用 CloudFront 服务和付费。</li>
    <li>S3 的公共访问权限（read permission）已经被配置好，可以跳过指南中有关 S3 配置的部分（<a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.html#GettingStartedUploadContent">Step 2: Upload your content to Amazon S3 and grant object permissions</a>。</li>
    <li>CloudFront 配置中的 <strong>Origin Domain Name</strong> 请从 AVFile 的 URL 中获取，其他均可保持默认。</li>
    </ol>
  </div>
</div>





<h3 id="-">常见的文件使用场景</h3>
<h4 id="-">文件被其他对象关联</h4>
<p>解决方案：将 AVFile 当做 <code>Pointer</code> 类型关联 AVObject 对象的一个字段:</p>
<p>查询的时候需要额外的 include 一下:</p>
<h2 id="-">查询</h2>
<p><code>AVQuery</code> 是构建针对 <code>AVObject</code> 查询的基础类。每次查询默认最多返回 100 条符合条件的结果，要更改这一数值，请参考 <a href="#限定返回数量">限定结果返回数量</a>。</p>
<h3 id="-">示例数据结构</h3>
<p>熟悉本文所使用的相关数据表结构将有助于更好地理解后面的内容。</p>
<p><img src="images/todo-schema.svg" alt=""></p>
<h4 id="todo-">Todo（待办事项）</h4>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>content</code></td>
<td style="text-align:left">String</td>
<td style="text-align:left">事项的详细内容</td>
</tr>
<tr>
<td style="text-align:left"><code>images</code></td>
<td style="text-align:left">AVFile</td>
<td style="text-align:left">与事项相关的图片</td>
</tr>
<tr>
<td style="text-align:left"><code>location</code></td>
<td style="text-align:left">String</td>
<td style="text-align:left">处理该事项的地点</td>
</tr>
<tr>
<td style="text-align:left"><code>priority</code></td>
<td style="text-align:left">Number</td>
<td style="text-align:left">0 优先级最高，最迫切需要完成。</td>
</tr>
<tr>
<td style="text-align:left"><code>reminders</code></td>
<td style="text-align:left">Array</td>
<td style="text-align:left">设置提醒日期和时间</td>
</tr>
<tr>
<td style="text-align:left"><code>status</code></td>
<td style="text-align:left">Number</td>
<td style="text-align:left">0 未完成，1 已完成</td>
</tr>
<tr>
<td style="text-align:left"><code>title</code></td>
<td style="text-align:left">String</td>
<td style="text-align:left">事项的标题（简短描述）</td>
</tr>
<tr>
<td style="text-align:left"><code>views</code></td>
<td style="text-align:left">Number</td>
<td style="text-align:left">该事项被浏览过的次数</td>
</tr>
<tr>
<td style="text-align:left"><code>whereCreated</code></td>
<td style="text-align:left">AVGeoPoint</td>
<td style="text-align:left">该事项被创建时的地理定位</td>
</tr>
</tbody>
</table>
<h4 id="todofolder-">TodoFolder（待办事项的分组）</h4>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>containedTodos</code></td>
<td style="text-align:left">Relation</td>
<td style="text-align:left">所包含的 Todo，与表 <code>Todo</code> 相关联。</td>
</tr>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left">String</td>
<td style="text-align:left">分组的名称，如家庭、会议。</td>
</tr>
<tr>
<td style="text-align:left"><code>owner</code></td>
<td style="text-align:left">Pointer</td>
<td style="text-align:left">分组的所有者或创建人，指向表 <code>_User</code></td>
</tr>
<tr>
<td style="text-align:left"><code>priority</code></td>
<td style="text-align:left">Number</td>
<td style="text-align:left">该分组的优先级别，0 优先级最高。</td>
</tr>
<tr>
<td style="text-align:left"><code>tags</code></td>
<td style="text-align:left">Relation</td>
<td style="text-align:left">标签，与表 <code>Tag</code> 相关联。</td>
</tr>
</tbody>
</table>
<h4 id="comment-">Comment（待办事项分组的评论）</h4>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>content</code></td>
<td style="text-align:left">String</td>
<td style="text-align:left">评论的内容</td>
</tr>
<tr>
<td style="text-align:left"><code>likes</code></td>
<td style="text-align:left">Number</td>
<td style="text-align:left">点了赞就是 1，点了不喜欢为 -1，没有做任何操作就为 0（默认）。</td>
</tr>
<tr>
<td style="text-align:left"><code>targetTodoFolder</code></td>
<td style="text-align:left">Pointer</td>
<td style="text-align:left">相关联的待办事项分组，指向表 <code>TodoFolder</code> 的 objectId</td>
</tr>
</tbody>
</table>
<h4 id="tag-">Tag（待办事项分组的标签）</h4>
<table>
<thead>
<tr>
<th style="text-align:left">字段</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>name</code></td>
<td style="text-align:left">String</td>
<td style="text-align:left">标签的名称，如今日必做、老婆吩咐、十分重要等。</td>
</tr>
<tr>
<td style="text-align:left"><code>targetTodoFolder</code></td>
<td style="text-align:left">Pointer</td>
<td style="text-align:left">相关联的待办事项分组，指向表 <code>TodoFolder</code> 的 objectId</td>
</tr>
</tbody>
</table>
<h3 id="-">创建查询实例</h3>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
</code></pre>
<p>最基础的用法是根据 objectId 来查询对象：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; avQuery = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        avQuery.getInBackground(&quot;558e20cbe4b060308e3eb36c&quot;, new GetCallback&lt;AVObject&gt;() {
            @Override
            public void done(AVObject avObject, AVException e) {
                // object 就是 id 为 558e20cbe4b060308e3eb36c 的 Todo 对象实例
            }
        });
</code></pre>
<h3 id="-">比较查询</h3>
<table>
<thead>
<tr>
<th>逻辑操作</th>
<th>AVQuery 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>等于</td>
<td><code>equalTo</code></td>
</tr>
<tr>
<td>不等于</td>
<td><code>notEqualTo</code></td>
</tr>
<tr>
<td>大于</td>
<td><code>greaterThan</code></td>
</tr>
<tr>
<td>大于等于</td>
<td><code>greaterThanOrEqualTo</code></td>
</tr>
<tr>
<td>小于</td>
<td><code>lessThan</code></td>
</tr>
<tr>
<td>小于等于</td>
<td><code>lessThanOrEqualTo</code></td>
</tr>
</tbody>
</table>
<p>利用上述表格介绍的逻辑操作的接口，我们可以很快地构建条件查询。</p>
<p>例如，查询优先级小于 2 的所有 Todo ：</p>
<pre><code class="lang-java">        query.whereLessThan(&quot;priority&quot;, 2);
</code></pre>
<div class="callout callout-info">每次查询默认最多返回 100 条符合条件的结果，要更改这一数值，请参考 <a href="#限定返回数量">限定结果返回数量</a>。</div>

<p>以上逻辑用 SQL 语句表达为 <code>select * from Todo where priority &lt; 2</code>。LeanStorage 也支持使用这种传统的 SQL 语句查询。具体使用方法请移步至 <a href="#CQL_查询">CQL 查询</a>。</p>
<p>查询优先级大于等于 2 的 Todo：</p>
<pre><code class="lang-java">        query.whereGreaterThanOrEqualTo(&quot;priority&quot;, 2);
</code></pre>
<h4 id="-">多个查询条件</h4>
<p>当多个查询条件并存时，它们之间默认为 AND 关系，即查询只返回满足了全部条件的结果。建立 OR 关系则需要使用 <a href="#组合查询">组合查询</a>。</p>
<p>在<strong>简单查询</strong>中，如果对一个对象的<strong>同一属性</strong>设置多个条件，那么先前的条件会被覆盖，查询只返回满足最后一个条件的结果。例如要找出优先级为 0 和 1 的所有 Todo，错误写法是：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.whereEqualTo(&quot;priority&quot;, 0);
        query.whereEqualTo(&quot;priority&quot;, 1);
        // 如果这样写，第二个条件将覆盖第一个条件，查询只会返回 priority = 1 的结果
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                ...
            }
        });
</code></pre>
<p>正确作法是使用 <a href="#OR_查询">组合查询 · OR 关系</a> 来构建这种条件。</p>
<h3 id="-">字符串查询</h3>
<p><strong>前缀查询</strong>类似于 SQL 的 <code>LIKE &#39;keyword%&#39;</code> 条件。因为支持索引，所以该操作对于大数据集也很高效。</p>
<pre><code class="lang-java">        // 找出开头是「早餐」的 Todo
        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.whereStartsWith(&quot;content&quot;, &quot;早餐&quot;);
</code></pre>
<p><strong>包含查询</strong>类似于 SQL 的 <code>LIKE &#39;%keyword%&#39;</code> 条件，比如查询标题包含「李总」的 Todo：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.whereContains(&quot;title&quot;, &quot;李总&quot;);
</code></pre>
<p><strong>不包含查询</strong>可以使用<strong>正则匹配查询</strong>的方式来实现。例如，查询标题不包含「机票」的 Todo：</p>
<pre><code class="lang-java">        AVQuery<avobject> query = new AVQuery<>("Todo");
        query.whereMatches("title","^((?!机票).)*&dollar;&quot;);
</avobject></code></pre>


<div class="callout callout-info">正则匹配查询<strong>只适用于</strong>字符串类型的数据。</div>

<p>但是基于正则的模糊查询有两个缺点：</p>
<ul>
<li>当数据量逐步增大后，查询效率将越来越低。</li>
<li>没有文本相关性排序</li>
</ul>
<p>因此我们推荐使用 <a href="#应用内搜索">应用内搜索</a> 功能。它基于搜索引擎技术构建，提供更强大的搜索功能。</p>
<h3 id="-">数组查询</h3>
<p>当一个对象有一个属性是数组的时候，针对数组的元数据查询可以有多种方式。例如，在 <a href="#更新数组">数组</a> 一节中我们为 Todo 设置了 reminders 属性，它就是一个日期数组，现在我们需要查询所有在 8:30 会响起闹钟的 Todo 对象：</p>
<pre><code class="lang-java">    Date getDateWithDateString(String dateString) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        Date date = dateFormat.parse(dateString);
        return date;
    }

    void queryRemindersContains() {
        Date reminder = getDateWithDateString(&quot;2015-11-11 08:30:00&quot;);

        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);

        // equalTo: 可以找出数组中包含单个值的对象
        query.whereEqualTo(&quot;reminders&quot;, reminder);
    }
</code></pre>
<p>查询包含 8:30 和 9:30 这两个时间点响起闹钟的 Todo：</p>
<pre><code class="lang-java">    Date getDateWithDateString(String dateString) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        Date date = dateFormat.parse(dateString);
        return date;
    }

    void queryRemindersWhereEqualTo() {
        Date reminder1 = getDateWithDateString(&quot;2015-11-11 08:30:00&quot;);
        Date reminder2 = getDateWithDateString(&quot;2015-11-11 09:30:00&quot;);

        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.whereContainsAll(&quot;reminders&quot;, Arrays.asList(reminder1, reminder2));

        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {

            }
        });
    }
</code></pre>
<p>注意这里是包含关系，假如有一个 Todo 会在 8:30、9:30 和 10:30 响起闹钟，它仍然是会被查询出来的。</p>
<p>查询「全不包含」的情况：</p>
<pre><code class="lang-java">        query.whereNotContainedIn(&quot;reminders&quot;, Arrays.asList(reminder1, reminder2));
</code></pre>
<h3 id="-">空值查询</h3>
<p>假设用户可以有选择地为 Todo 上传图片来做标注，要想找出那些已有图片的 Todo：</p>
<pre><code class="lang-java">        // 存储一个带有图片的 Todo 到 LeanCloud 云端
        AVFile aTodoAttachmentImage = new AVFile(&quot;test.jpg&quot;, &quot;http://www.zgjm.org/uploads/allimg/150812/1_150812103912_1.jpg&quot;, new HashMap&lt;String, Object&gt;());
        AVObject todo = new AVObject(&quot;Todo&quot;);
        todo.put(&quot;images&quot;, aTodoAttachmentImage);
        todo.put(&quot;content&quot;, &quot;记得买过年回家的火车票！！！&quot;);
        todo.saveInBackground();

        // 使用非空值查询获取有图片的 Todo
        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.whereExists(&quot;images&quot;);
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                // list 返回的就是有图片的 Todo 集合
            }
        });

        // 使用空值查询获取没有图片的 Todo
        query.whereDoesNotExist(&quot;images&quot;);
</code></pre>
<h3 id="-">关系查询</h3>
<p>关联数据查询也可以通俗地理解为关系查询，关系查询在传统型数据库的使用中是很常见的需求，因此我们也提供了相关的接口来满足开发者针对关联数据的查询。</p>
<p>首先，我们需要明确关系的存储方式，再来确定对应的查询方式。</p>
<h4 id="pointer-">Pointer 查询</h4>
<p>基于在 <a href="#Pointer">Pointer</a> 小节介绍的存储方式：每一个 Comment 都会有一个 TodoFolder 与之对应，用以表示 Comment 属于哪个 TodoFolder。现在我已知一个 TodoFolder，想查询所有的 Comnent 对象，可以使用如下代码：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Comment&quot;);
        query.whereEqualTo(&quot;targetTodoFolder&quot;, AVObject.createWithoutData(&quot;TodoFolder&quot;, &quot;5590cdfde4b00f7adb5860c8&quot;));
</code></pre>
<h4 id="-avrelation-"><code>AVRelation</code> 查询</h4>
<p>假如用户可以给 TodoFolder 增加一个 Tag 选项，用以表示它的标签，而为了以后拓展 Tag 的属性，就新建了一个 Tag 对象，如下代码是创建 Tag 对象：</p>
<pre><code class="lang-java">        AVObject tag = new AVObject(&quot;Tag&quot;);// 构建对象
        tag.put(&quot;name&quot;, &quot;今日必做&quot;);// 设置名称
        tag.saveInBackground();
</code></pre>
<p>而 Tag 的意义在于一个 TodoFolder 可以拥有多个 Tag，比如「家庭」（TodoFolder） 拥有的 Tag 可以是：今日必做、老婆吩咐、十分重要。实现创建「家庭」这个 TodoFolder 的代码如下：</p>
<pre><code class="lang-java">        AVObject tag1 = new AVObject(&quot;Tag&quot;);// 构建对象
        tag1.put(&quot;name&quot;, &quot;今日必做&quot;);// 设置 Tag 名称

        AVObject tag2 = new AVObject(&quot;Tag&quot;);// 构建对象
        tag2.put(&quot;name&quot;, &quot;老婆吩咐&quot;);// 设置 Tag 名称

        AVObject tag3 = new AVObject(&quot;Tag&quot;);// 构建对象
        tag3.put(&quot;name&quot;, &quot;十分重要&quot;);// 设置 Tag 名称

        AVObject todoFolder = new AVObject(&quot;TodoFolder&quot;);// 构建对象
        todoFolder.put(&quot;name&quot;, &quot;家庭&quot;);// 设置 Todo 名称
        todoFolder.put(&quot;priority&quot;, 1);// 设置优先级

        AVRelation&lt;AVObject&gt; relation = todoFolder.getRelation(&quot;tags&quot;);
        relation.add(tag1);
        relation.add(tag2);
        relation.add(tag3);

        todoFolder.saveInBackground();// 保存到云端
</code></pre>
<p>查询一个 TodoFolder 的所有 Tag 的方式如下：</p>
<pre><code class="lang-java">        AVObject todoFolder = AVObject.createWithoutData(&quot;TodoFolder&quot;, &quot;5661047dddb299ad5f460166&quot;);
        AVRelation&lt;AVObject&gt; relation = todoFolder.getRelation(&quot;tags&quot;);
        AVQuery&lt;AVObject&gt; query = relation.getQuery();
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                // list 是一个 AVObject 的 List，它包含所有当前 todoFolder 的 tags
            }
        });
</code></pre>
<p>反过来，现在已知一个 Tag，要查询有多少个 TodoFolder 是拥有这个 Tag 的，可以使用如下代码查询：</p>
<pre><code class="lang-java">        AVObject tag = AVObject.createWithoutData(&quot;Tag&quot;, &quot;5661031a60b204d55d3b7b89&quot;);
        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;TodoFolder&quot;);
        query.whereEqualTo(&quot;tags&quot;, tag);
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                // list 是一个 AVObject 的 List
                // list 指的就是所有包含当前 tag 的 TodoFolder
            }
        });
</code></pre>
<p>关于关联数据的建模是一个复杂的过程，很多开发者因为在存储方式上的选择失误导致最后构建查询的时候难以下手，不但客户端代码冗余复杂，而且查询效率低，为了解决这个问题，我们专门针对关联数据的建模推出了一个详细的文档予以介绍，详情请阅读《<a href="relation-guide.html">数据模型设计指南</a>》。</p>
<h4 id="-">关联属性查询</h4>
<p>正如在 <a href="#Pointer">Pointer</a> 中保存 Comment 的 targetTodoFolder 属性一样，假如查询到了一些 Comment 对象，想要一并查询出每一条 Comment 对应的 TodoFolder 对象的时候，可以加上 include 关键字查询条件。同理，假如 TodoFolder 表里还有 pointer 型字段 targetAVUser 时，再加上一个递进的查询条件，形如 include(b.c)，即可一并查询出每一条 TodoFolder 对应的 AVUser 对象。代码如下：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; commentQuery = new AVQuery&lt;&gt;(&quot;Comment&quot;);
        commentQuery.orderByDescending(&quot;createdAt&quot;);
        commentQuery.limit(10);
        commentQuery.include(&quot;targetTodoFolder&quot;);// 关键代码，用 include 告知服务端需要返回的关联属性对应的对象的详细信息，而不仅仅是 objectId
        commentQuery.include(&quot;targetTodoFolder.targetAVUser&quot;);// 关键代码，同上，会返回 targetAVUser 对应的对象的详细信息，而不仅仅是 objectId
        commentQuery.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                // list 是最近的十条评论, 其 targetTodoFolder 字段也有相应数据
                for (AVObject comment : list) {
                    // 并不需要网络访问
                    AVObject todoFolder = comment.getAVObject(&quot;targetTodoFolder&quot;);
                    AVUser avUser = todoFolder.getAVUser(&quot;targetAVUser&quot;);
                }
            }
        });
</code></pre>
<p>此外需要格外注意的是，假设对象有一个 Array 类型的字段 <code>todoArray</code> 内部是 Pointer 类型：</p>
<pre><code>[pointer1, pointer2, pointer3]
</code></pre><p>可以用 include 方法获取数组中的 pointer 数据，例如：</p>
<pre><code>// object-c on iOS
[query includeKey:@&quot;todoArray&quot;];
// java
query.include(&quot;todoArray&quot;);
// js
query.include(&#39;todoArray&#39;);
</code></pre><p>但是 Array 类型的 include 操作只支持到第一层，不支持 <code>include(b.c)</code> 这种递进关联查询。</p>
<p><code>select</code> 也具备使用 dot 符号 <code>.</code> 来进行级联操作：</p>
<pre><code>// objective-c on iOS
[query selectKeys:@&quot;targetTodoFolder.targetAVUser.username&quot;];
// java
query.selectKeys(Arrays.asList(&quot;targetTodoFolder.targetAVUser.username&quot;));
// js
query.select([&#39;targetTodoFolder.targetAVUser.username&#39;]);
</code></pre><h4 id="-">内嵌查询</h4>
<p>查询点赞超过 20 次的 TodoFolder 的 Comment 评论（注意查询针对的是 <a href="#Comment_待办事项分组的评论_">Comment</a>），使用内嵌查询接口就可以通过一次查询来达到目的。</p>
<pre><code class="lang-java">        // 构建内嵌查询
        AVQuery&lt;AVObject&gt; innerQuery = new AVQuery&lt;&gt;(&quot;TodoFolder&quot;);
        innerQuery.whereGreaterThan(&quot;likes&quot;, 20);
        // 将内嵌查询赋予目标查询
        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Comment&quot;);
        // 执行内嵌操作
        query.whereMatchesQuery(&quot;targetTodoFolder&quot;, innerQuery);
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                // list 就是符合超过 20 个赞的 TodoFolder 这一条件的 Comment 对象集合
            }
        });

        // 注意如果要做相反的查询可以使用
        query.whereDoesNotMatchQuery(&quot;targetTodoFolder&quot;, innerQuery);
        // 如此做将查询出 likes 小于或者等于 20 的 TodoFolder 的 Comment 对象
</code></pre>
<p>与普通查询一样，内嵌查询默认也最多返回 100 条记录，想修改这一默认请参考 <a href="#限定返回数量">限定结果返回数量</a>。</p>
<p><strong>如果所有返回的记录没有匹配到外层的查询条件，那么整个查询也查不到结果</strong>。例如：</p>
<pre><code class="lang-sql">-- 找出积分高于 80、region 为 cn 的玩家记录
SELECT * 
FROM   player 
WHERE  NAME IN (SELECT NAME 
                FROM   gamescore 
                WHERE  score &gt; 80) 
       AND region = &#39;cn&#39;
</code></pre>
<p>LeanCloud 云端使用的并非关系型数据库，无法做到真正的联表查询，所以实际的处理方式是：先执行内嵌/子查询（和普通查询一样，limit 默认为 100，最大  1000），然后将子查询的结果填入主查询的对应位置，再执行主查询。</p>
<p>如果子查询匹配到了 100 条以上的记录（性别等区分度低的字段重复值往往较多），且主查询有其他查询条件（<code>region = &#39;cn&#39;</code>），那么可能会出现没有结果或结果不全的情况，其本质上是子查询查出的 100 条记录没有满足主查询的其他条件。</p>
<p>我们建议采用以下方案进行改进：</p>
<ul>
<li>确保子查询的结果在 100 条以下，如果在 100 - 1000 条的话请在子查询末尾添加 limit 1000。</li>
<li>将需要查询的字段冗余到主查询所在的表上；例如将 score 冗余到 Player 表上，或者将 region 添加到 GameScore 上然后只查 GameScore 表。</li>
<li>进行多次查询，每次在子查询上添加 <a href="#跳过数量">skip</a> 来遍历所有记录（注意 skip 的值较大时可能会引发性能问题，因此不是很推荐）。</li>
</ul>
<h3 id="-">地理位置查询</h3>
<p>地理位置查询是较为特殊的查询，一般来说，常用的业务场景是查询距离 xx 米之内的某个位置或者是某个建筑物，甚至是以手机为圆心，查找方圆多少范围内餐厅等等。LeanStorage 提供了一系列的方法来实现针对地理位置的查询。</p>
<h4 id="-">查询位置附近的对象</h4>
<p>Todo 的 <code>whereCreated</code>（创建 Todo 时的位置）是一个 <code>AVGeoPoint</code> 对象，现在已知了一个地理位置，现在要查询 <code>whereCreated</code> 靠近这个位置的 Todo 对象可以使用如下代码：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        AVGeoPoint point = new AVGeoPoint(39.9, 116.4);
        query.limit(10);
        query.whereNear(&quot;whereCreated&quot;, point);
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                List&lt;AVObject&gt; nearbyTodos = list;// 离这个位置最近的 10 个 Todo 对象
            }
        });
</code></pre>
<p>在上面的代码中，<code>nearbyTodos</code> 返回的是与 <code>point</code> 这一点按距离排序（由近到远）的对象数组。注意：<strong>如果在此之后又使用了 <code>orderByAscending</code> 或 <code>orderByDescending</code> 方法，则按距离排序会被新排序覆盖。</strong></p>
<h4 id="-">查询指定范围内的对象</h4>
<p>要查找指定距离范围内的数据，可使用 <code>whereWithinKilometers</code> 、 <code>whereWithinMiles</code> 或 <code>whereWithinRadians</code> 方法。
例如，我要查询距离指定位置，2 千米范围内的 Todo：</p>
<pre><code class="lang-java">        query.whereWithinKilometers(&quot;whereCreated&quot;, point, 2.0);
</code></pre>
<h4 id="-">注意事项</h4>
<p>使用地理位置需要注意以下方面：</p>
<ul>
<li>每个 <code>AVObject</code> 数据对象中只能有一个 <code>AVGeoPoint</code> 对象的属性。</li>
<li>地理位置的点不能超过规定的范围。纬度的范围应该是在 <code>-90.0</code> 到 <code>90.0</code> 之间，经度的范围应该是在 <code>-180.0</code> 到 <code>180.0</code> 之间。如果添加的经纬度超出了以上范围，将导致程序错误。</li>
</ul>
<h3 id="-">组合查询</h3>
<p>组合查询就是把诸多查询条件合并成一个查询，再交给 SDK 去云端查询。方式有两种：OR 和 AND。</p>
<h4 id="or-">OR 查询</h4>
<p>OR 操作表示多个查询条件符合其中任意一个即可。 例如，查询优先级是大于等于 3 或者已经完成了的 Todo：</p>
<pre><code class="lang-java">        final AVQuery&lt;AVObject&gt; priorityQuery = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        priorityQuery.whereGreaterThanOrEqualTo(&quot;priority&quot;, 3);

        final AVQuery&lt;AVObject&gt; statusQuery = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        statusQuery.whereEqualTo(&quot;status&quot;, 1);

        AVQuery&lt;AVObject&gt; query = AVQuery.or(Arrays.asList(priorityQuery, statusQuery));
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                // 返回 priority 大于等于3 或 status 等于 1 的 Todo
            }
        });
</code></pre>
<p><strong>注意：OR 查询中，子查询中不能包含地理位置相关的查询。</strong></p>
<h4 id="and-">AND 查询</h4>
<p>AND 操作将满足了所有查询条件的对象返回给客户端。例如，找到创建于 <code>2016-11-13</code> 至 <code>2016-12-02</code> 之间的 Todo：</p>
<pre><code class="lang-java">    Date getDateWithDateString(String dateString) {
        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
        Date date = dateFormat.parse(dateString);
        return date;
    }

    final AVQuery&lt;AVObject&gt; startDateQuery = new AVQuery&lt;&gt;(&quot;Todo&quot;);
    startDateQuery.whereGreaterThanOrEqualTo(&quot;createdAt&quot;, getDateWithDateString(&quot;2016-11-13&quot;));

    final AVQuery&lt;AVObject&gt; endDateQuery = new AVQuery&lt;&gt;(&quot;Todo&quot;);
    endDateQuery.whereLessThan(&quot;createdAt&quot;, getDateWithDateString(&quot;2016-12-03&quot;));

    AVQuery&lt;AVObject&gt; query = AVQuery.and(Arrays.asList(startDateQuery, endDateQuery));
    query.findInBackground(new FindCallback&lt;AVObject&gt;() {
        @Override
        public void done(List&lt;AVObject&gt; list, AVException e) {

        }
    });
</code></pre>
<p>可以对新创建的 <code>AVQuery</code> 添加额外的约束，多个约束将以 AND 运算符来联接。</p>
<h3 id="-">查询结果数量和排序</h3>
<h4 id="-">获取第一条结果</h4>
<p>例如很多应用场景下，只要获取满足条件的一个结果即可，例如获取满足条件的第一条 Todo：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.whereEqualTo(&quot;priority&quot;,0);
        query.getFirstInBackground(new GetCallback&lt;AVObject&gt;() {
            @Override
            public void done(AVObject avObject, AVException e) {
                // object 就是符合条件的第一个 AVObject
            }
        });
</code></pre>
<h4 id="-">限定返回数量</h4>
<p>为了防止查询出来的结果过大，云端默认针对查询结果有一个数量限制，即 <code>limit</code>，它的默认值是 100。比如一个查询会得到 10000 个对象，那么一次查询只会返回符合条件的 100 个结果。<code>limit</code> 允许取值范围是 1 ~ 1000。例如设置返回 10 条结果：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        Date now = new Date();
        query.whereLessThanOrEqualTo(&quot;createdAt&quot;, now);//查询今天之前创建的 Todo
        query.limit(10);// 最多返回 10 条结果
</code></pre>
<h4 id="-">跳过数量</h4>
<p>设置 skip 这个参数可以告知云端本次查询要跳过多少个结果。将 skip 与 limit 搭配使用可以实现翻页效果，这在客户端做列表展现时，特别是在数据量庞大的情况下适合使用。例如，在翻页中每页显示数量为 10，要获取第 3 页的对象：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        Date now = new Date();
        query.whereLessThanOrEqualTo(&quot;createdAt&quot;, now);//查询今天之前创建的 Todo
        query.limit(10);// 最多返回 10 条结果
        query.skip(20);// 跳过 20 条结果
</code></pre>
<p>上述方法的执行效率比较低，因此不建议广泛使用。<strong>建议选用 <code>createdAt</code> 或者 <code>updatedAt</code> 这类的时间戳进行分段查询</strong>（<a href="#AND_查询">示例</a>）。</p>
<h4 id="-">返回指定属性/字段</h4>
<p>通常列表展现的时候并不是需要展现某一个对象的所有属性，例如，Todo 这个对象列表一般展现的是 title 以及 content，在设置查询时可以告知云端需要返回的属性或字段有哪些，这样既满足需求又节省流量，还可以提高一部分的性能：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.selectKeys(Arrays.asList(&quot;title&quot;, &quot;content&quot;));
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                for (AVObject avObject : list) {
                    String title = avObject.getString(&quot;title&quot;);
                    String content = avObject.getString(&quot;content&quot;);

                    // 如果访问没有指定返回的属性（key），则会报错，在当前这段代码中访问 location 属性就会报错
                    String location = avObject.getString(&quot;location&quot;);
                }
            }
        });
</code></pre>
<p>所指定的属性或字段也支持 Pointer 类型。例如，获取 Todo 这个对象的所有者信息（owner 属性，Pointer 类型），仅展示这个所有者的 username：</p>
<pre><code class="lang-java">    query.selectKeys(Arrays.asList(&quot;owner.username&quot;));
</code></pre>
<h4 id="-">统计总数量</h4>
<p>通常用户在执行完搜索后，结果页面总会显示出诸如「搜索到符合条件的结果有 1020 条」这样的信息。例如，查询一下今天一共完成了多少条 Todo：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Todo&quot;);
        query.whereEqualTo(&quot;status&quot;, 0);
        query.countInBackground(new CountCallback() {
            @Override
            public void done(int i, AVException e) {
                if (e == null) {
                    // 查询成功，输出计数
                    Log.d(TAG, &quot;今天完成了&quot; + i + &quot;条待办事项。&quot;);
                } else {
                    // 查询失败
                }
            }
        });
</code></pre>
<h4 id="-">排序</h4>
<p>对于数字、字符串、日期类型的数据，可对其进行升序或降序排列。</p>
<pre><code class="lang-java">        // 按时间，升序排列
        query.orderByAscending(&quot;createdAt&quot;);

        // 按时间，降序排列
        query.orderByDescending(&quot;createdAt&quot;);
</code></pre>
<p>一个查询可以附加多个排序条件，如按 priority 升序、createdAt 降序排列：</p>
<pre><code class="lang-java">        query.addAscendingOrder(&quot;priority&quot;);
        query.addDescendingOrder(&quot;createdAt&quot;);
</code></pre>
<!-- #### 限定返回字段 -->
<h3 id="cql-">CQL 查询</h3>
<p>CQL 是 LeanStorage 独创的使用类似 SQL 语法来实现云端查询功能的语言，具有 SQL 开发经验的开发者可以方便地使用此接口实现查询。</p>
<p>分别找出 status = 1 的全部 Todo 结果，以及 priority = 0 的 Todo 的总数：</p>
<pre><code class="lang-java">        String cql = &quot;select * from Todo where status = 1&quot;;
        AVQuery.doCloudQueryInBackground(cql, new CloudQueryCallback&lt;AVCloudQueryResult&gt;() {
            @Override
            public void done(AVCloudQueryResult avCloudQueryResult, AVException e) {
                avCloudQueryResult.getResults();
            }
        });

        cql = &quot;select count(*) from Todo where priority = 0&quot;;
        AVQuery.doCloudQueryInBackground(cql, new CloudQueryCallback&lt;AVCloudQueryResult&gt;() {
            @Override
            public void done(AVCloudQueryResult avCloudQueryResult, AVException e) {
                avCloudQueryResult.getCount();
            }
        });

        // 请注意：如果 Todo 是 AVObject 的子类，则需要传入第三个参数 Todo.class，否则会遇到 ClassCastException 的错误
        AVQuery.doCloudQueryInBackground(cql, new CloudQueryCallback&lt;AVCloudQueryResult&gt;() {
            @Override
            public void done(AVCloudQueryResult avCloudQueryResult, AVException e) {
                Todo todo = (Todo) avCloudQueryResult.getResults().get(0);
            }
        }, Todo.class);
</code></pre>
<p>通常查询语句会使用变量参数，为此我们提供了与 Java JDBC 所使用的 PreparedStatement 占位符查询相类似的语法结构。</p>
<p>查询 status = 0、priority = 1 的 Todo：</p>
<pre><code class="lang-java">        String cql = &quot; select * from Todo where status = ? and priority = ?&quot;;
        AVQuery.doCloudQueryInBackground(cql, new CloudQueryCallback&lt;AVCloudQueryResult&gt;() {
            @Override
            public void done(AVCloudQueryResult avCloudQueryResult, AVException e) {
                if (e == null) {
                    // 操作成功
                } else {
                    e.printStackTrace();
                }
            }
        }, Arrays.asList(0, 1));
</code></pre>
<p>目前 CQL 已经支持数据的更新 update、插入 insert、删除 delete 等 SQL 语法，更多内容请参考 <a href="cql_guide.html">CQL 详细指南</a>。</p>
<h3 id="-">缓存查询</h3>
<p>缓存一些查询的结果到磁盘上，这可以让你在离线的时候，或者应用刚启动，网络请求还没有足够时间完成的时候可以展现一些数据给用户。当缓存占用了太多空间的时候，LeanStorage 会自动清空缓存。</p>
<p>默认情况下的查询不会使用缓存，除非你调用接口明确设置启用。例如，尝试从网络请求，如果网络不可用则从缓存数据中获取，可以这样设置：</p>
<pre><code class="lang-java">        AVQuery&lt;AVObject&gt; query = new AVQuery&lt;&gt;(&quot;Post&quot;);
        query.setCachePolicy(AVQuery.CachePolicy.NETWORK_ELSE_CACHE);
        query.setMaxCacheAge(24 * 3600 * 1000); //设置为一天，单位毫秒
        query.findInBackground(new FindCallback&lt;AVObject&gt;() {
            @Override
            public void done(List&lt;AVObject&gt; list, AVException e) {
                if (e == null) {
                    // 成功找到结果，先找网络再访问磁盘
                } else {
                    // 无法访问网络，本次查询结果未做缓存
                }
            }
        });
</code></pre>
<h4 id="-">缓存策略</h4>
<p>为了满足多变的需求，SDK 默认提供了以下几种缓存策略：</p>
<table>
<thead>
<tr>
<th>策略枚举</th>
<th>含义及解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IGNORE_CACHE</code></td>
<td><strong>（默认缓存策略）</strong>查询行为不从缓存加载，也不会将结果保存到缓存中。</td>
</tr>
<tr>
<td><code>CACHE_ONLY</code></td>
<td>查询行为忽略网络状况，只从缓存加载。如果没有缓存结果，该策略会产生 <code>AVException</code>。</td>
</tr>
<tr>
<td><code>CACHE_ELSE_NETWORK</code></td>
<td>查询行为首先尝试从缓存加载，若加载失败，则通过网络加载结果。如果缓存和网络获取行为均为失败，则产生 <code>AVException</code>。</td>
</tr>
<tr>
<td><code>NETWORK_ELSE_CACHE</code></td>
<td>查询行为先尝试从网络加载，若加载失败，则从缓存加载结果。如果缓存和网络获取行为均为失败，则产生 <code>AVException</code>。</td>
</tr>
<tr>
<td><code>CACHE_THEN_NETWORK</code></td>
<td>查询先从缓存加载，然后从网络加载。在这种情况下，回调函数会被调用两次，第一次是缓存中的结果，然后是从网络获取的结果。因为它会在不同的时间返回两个结果，所以该策略不能与 <code>find()</code> 同时使用。</td>
</tr>
</tbody>
</table>
<h4 id="-">缓存相关的操作</h4>
<ul>
<li><p>检查是否存在缓存查询结果：</p>
<pre><code class="lang-java">boolean isInCache = query.hasCachedResult();
</code></pre>
</li>
<li><p>删除某一查询的任何缓存结果：</p>
<pre><code class="lang-java">query.clearCachedResult();
</code></pre>
</li>
<li><p>删除查询的所有缓存结果：</p>
<pre><code class="lang-java">AVQuery.clearAllCachedResults();
</code></pre>
</li>
<li><p>设定缓存结果的最长时限：</p>
<pre><code class="lang-java">query.setMaxCacheAge(24 * 3600 * 1000); //设置为一天，单位毫秒
</code></pre>
</li>
</ul>
<p>查询缓存也适用于 <code>AVQuery</code> 的辅助方法，包括 <code>getFirst()</code> 和 <code>getInBackground()</code>。</p>
<h3 id="-">查询性能优化</h3>
<p>影响查询性能的因素很多。特别是当查询结果的数量超过 10 万，查询性能可能会显著下降或出现瓶颈。以下列举一些容易降低性能的查询方式，开发者可以据此进行有针对性的调整和优化，或尽量避免使用。</p>
<ul>
<li>不等于和不包含查询（无法使用索引）</li>
<li>通配符在前面的字符串查询（无法使用索引）</li>
<li>有条件的 count（需要扫描所有数据）</li>
<li>skip 跳过较多的行数（相当于需要先查出被跳过的那些行）</li>
<li>无索引的排序（另外除非复合索引同时覆盖了查询和排序，否则只有其中一个能使用索引）</li>
<li>无索引的查询（另外除非复合索引同时覆盖了所有条件，否则未覆盖到的条件无法使用索引，如果未覆盖的条件区分度较低将会扫描较多的数据）</li>
</ul>
<h2 id="-">用户</h2>
<p>用户系统几乎是每款应用都要加入的功能。除了基本的注册、登录和密码重置，移动端开发还会使用手机号一键登录、短信验证码登录等功能。LeanStorage 提供了一系列接口来帮助开发者快速实现各种场景下的需求。</p>
<p><code>AVUser</code> 是用来描述一个用户的特殊对象，与之相关的数据都保存在 <code>_User</code> 数据表中。</p>
<h3 id="-">用户的属性</h3>
<h4 id="-">默认属性</h4>
<p>用户名、密码、邮箱是默认提供的三个属性，访问方式如下：</p>
<pre><code class="lang-java">        String currentUsername = AVUser.getCurrentUser().getUsername();
        String currentEmail = AVUser.getCurrentUser().getEmail();

        // 请注意，以下代码无法获取密码
        String currentPassword = AVUser.getCurrentUser().getPassword();// 无 getPassword() 此方法
</code></pre>
<p>请注意代码中，密码是仅仅是在注册的时候可以设置的属性（这部分代码可参照 <a href="#用户名和密码注册">用户名和密码注册</a>），它在注册完成之后并不会保存在本地（SDK 不会以明文保存密码这种敏感数据），所以在登录之后，再访问密码这个字段是为<strong>空的</strong>。</p>
<h4 id="-">自定义属性</h4>
<p>用户对象和普通对象一样也支持添加自定义属性。例如，为当前用户添加年龄属性 <code>age</code>：</p>
<pre><code class="lang-java">        AVUser.getCurrentUser().put(&quot;age&quot;, 25);
        AVUser.getCurrentUser().saveInBackground();
</code></pre>
<h4 id="-">修改属性</h4>
<p>很多开发者会有这样的疑问：「为什么我不能修改任意一个用户的属性？」</p>
<blockquote>
<p>因为很多时候，就算是开发者也不要轻易修改用户的基本信息，例如用户的手机号、社交账号等个人信息都比较敏感，应该由用户在 App 中自行修改。所以为了保证用户的数据仅在用户自己已登录的状态下才能修改，云端对所有针对 <code>AVUser</code> 对象的数据操作都要做验证。</p>
</blockquote>
<p>例如，先为当前用户增加一个 age 属性，保存后再更改它的值：</p>
<pre><code class="lang-java">        AVUser.getCurrentUser().put(&quot;age&quot;, 25);
        AVUser.getCurrentUser().saveInBackground(new SaveCallback() {
            @Override
            public void done(AVException e) {
                AVUser.getCurrentUser().put(&quot;age&quot;, 27);
                AVUser.getCurrentUser().saveInBackground();
            }
        });
</code></pre>
<p><code>AVUser</code> 的自定义属性在使用上与 <code>AVObject</code> 没有本质区别。</p>
<h3 id="-">注册</h3>
<h4 id="-">手机号码注册</h4>
<p>一些应用为了提高首次使用的友好度，一般会允许用户浏览一些内容，直到用户发起了一些操作才会要求用户输入一个手机号，而云端会自动发送一条验证码的短信给用户的手机号，最后验证一下，完成一个用户注册并且登录的操作，例如很多团购类应用都有这种用户场景。</p>
<p>首先调用发送验证码的接口：</p>
<pre><code class="lang-java">        AVOSCloud.requestSMSCodeInBackground(&quot;13577778888&quot;, new RequestMobileCodeCallback() {
            @Override
            public void done(AVException e) {
                // 发送失败可以查看 e 里面提供的信息
            }
        });
</code></pre>
<p>然后在 UI 上给与用户输入验证码的输入框，用户点击登录的时候调用如下接口：</p>
<pre><code class="lang-java">        AVUser.signUpOrLoginByMobilePhoneInBackground(&quot;13577778888&quot;, &quot;123456&quot;, new LogInCallback&lt;AVUser&gt;() {
            @Override
            public void done(AVUser avUser, AVException e) {
                // 如果 e 为空就可以表示登录成功了，并且 user 是一个全新的用户
            }
        });
</code></pre>
<h4 id="-">用户名和密码注册</h4>
<p>采用「用户名 + 密码」注册时需要注意：密码是以明文方式通过 HTTPS 加密传输给云端，云端会以密文存储密码，并且我们的加密算法是无法通过所谓「彩虹表撞库」获取的，这一点请开发者放心。换言之，用户的密码只可能用户本人知道，开发者不论是通过控制台还是 API 都是无法获取。另外我们需要强调<u>在客户端，应用切勿再次对密码加密，这会导致重置密码等功能失效</u>。</p>
<p>例如，注册一个用户的示例代码如下（用户名 <code>Tom</code> 密码 <code>cat!@#123</code>）：</p>
<pre><code class="lang-java">        AVUser user = new AVUser();// 新建 AVUser 对象实例
        user.setUsername(&quot;Tom&quot;);// 设置用户名
        user.setPassword(&quot;cat!@#123&quot;);// 设置密码
        user.setEmail(&quot;tom@leancloud.cn&quot;);// 设置邮箱
        user.signUpInBackground(new SignUpCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {
                    // 注册成功
                } else {
                    // 失败的原因可能有多种，常见的是用户名已经存在。
                }
            }
        });
</code></pre>
<p>我们建议在可能的情况下尽量使用异步版本的方法，这样就不会影响到应用程序主 UI 线程的响应。</p>
<p>如果注册不成功，请检查一下返回的错误对象。最有可能的情况是用户名已经被另一个用户注册，错误代码 <a href="error_code.html#_202">202</a>，即 <code>_User</code> 表中的 <code>username</code> 字段已存在相同的值，此时需要提示用户尝试不同的用户名来注册。同样，邮件 <code>email</code> 和手机号码 <code>mobilePhoneNumber</code> 字段也要求在各自的列中不能有重复值出现，否则会出现 <a href="error_code.html#_203">203</a>、<a href="error_code.html#_214">214</a> 错误。</p>
<p>开发者也可以要求用户使用 Email 做为用户名注册，即在用户提交信息后将 <code>_User</code> 表中的 <code>username</code> 和 <code>email</code> 字段都设为相同的值，这样做的好处是用户在忘记密码的情况下可以直接使用「<a href="#重置密码">邮箱重置密码</a>」功能，无需再额外绑定电子邮件。</p>
<p>关于自定义邮件模板和验证链接，请参考《<a href="https://blog.leancloud.cn/607/">自定义应用内用户重设密码和邮箱验证页面</a>》。</p>
<h4 id="-">设置手机号码</h4>
<p>微信、陌陌等流行应用都会建议用户将账号和一个手机号绑定，这样方便进行身份认证以及日后的密码找回等安全模块的使用。我们也提供了一整套发送短信验证码以及验证手机号的流程，这部分流程以及代码演示请参考 <a href="sms-guide.html#注册验证">短信服务使用指南 · 注册验证</a>。</p>
<h4 id="-">验证邮箱</h4>
<p>许多应用会通过验证邮箱来确认用户注册的真实性。如果在 <a href="/app.html?appid={{appid}}#/permission">控制台 &gt; 应用设置 &gt; 应用选项</a> 中勾选了 <strong>用户注册时，发送验证邮件</strong>，那么当一个 <code>AVUser</code> 在注册时设置了邮箱，云端就会向该邮箱自动发送一封包含了激活链接的验证邮件，用户打开该邮件并点击激活链接后便视为通过了验证。有些用户可能在注册之后并没有点击激活链接，而在未来某一个时间又有验证邮箱的需求，这时需要调用如下接口让云端重新发送验证邮件：</p>
<pre><code class="lang-java">  AVUser.requestEmailVerifyInBackground(&quot;abc@xyz.com&quot;, new RequestEmailVerifyCallback() {
    @Override
    public void done(AVException e) {
      if (e == null) {
        // 求重发验证邮件成功
      }
    }
  });
</code></pre>
<h3 id="-">登录</h3>
<p>我们提供了多种登录方式，以满足不同场景的应用。</p>
<h4 id="-">用户名和密码登录</h4>
<pre><code class="lang-java">        AVUser.logInInBackground(&quot;Tom&quot;, &quot;cat!@#123&quot;, new LogInCallback&lt;AVUser&gt;() {
            @Override
            public void done(AVUser avUser, AVException e) {

            }
        });
</code></pre>
<h4 id="-">手机号和密码登录</h4>
<p><a href="sms-guide.html#注册验证">短信服务使用指南 · 注册验证</a> 可以帮助你更好地理解手机号匹配密码登录的流程以及适用范围，所以推荐详细阅读。</p>
<pre><code class="lang-java">        AVUser.loginByMobilePhoneNumberInBackground(&quot;13577778888&quot;, &quot;cat!@#123&quot;, new LogInCallback&lt;AVUser&gt;() {
            @Override
            public void done(AVUser avUser, AVException e) {

            }
        });
</code></pre>
<p>以上的手机号码即使没有经过验证，只要密码正确也可以成功登录。如果希望阻止未验证的手机号码用于登录，则需要在 <a href="/app.html?appid={{appid}}#/permission">控制台 &gt; 应用设置 &gt; 应用选项</a> 中勾选 <strong>未验证手机号码的用户，禁止登录</strong>。这种方式也提高了用户账号的合法性与安全性。</p>
<h4 id="-">手机号和验证码登录</h4>
<p>首先，调用发送登录验证码的接口：</p>
<pre><code class="lang-java">        AVUser.requestLoginSmsCodeInBackground(&quot;13577778888&quot;, new RequestMobileCodeCallback() {
            @Override
            public void done(AVException e) {

            }
        });
</code></pre>
<p>然后在界面上引导用户输入收到的 6 位短信验证码：</p>
<pre><code class="lang-java">        AVUser.signUpOrLoginByMobilePhoneInBackground(&quot;13577778888&quot;, &quot;238825&quot;, new LogInCallback&lt;AVUser&gt;() {
            @Override
            public void done(AVUser avUser, AVException e) {

            }
        });
</code></pre>
<h4 id="-">测试用的手机号和固定验证码</h4>
<p>对于使用「手机号 + 验证码」登录的应用来说，在上架前提交至 Apple Store 进行审核的过程中，可能会面临 Apple 人员因没有有效的手机号码而无法登录来进行评估审核，或者开发者也无法提供固定手机号和验证码的尴尬情况。</p>
<p>另外，开发者在开发测试过程中也会面临在短时间内需要多次登录或注销的操作，由于验证码有时间间隔与总次数限制，这样就会带来种种不便。</p>
<p>为解决这些问题，我们允许为每个应用设置一个用于测试目的的手机号码，LeanCloud 平台会为它生成一个<strong>固定的验证码</strong>，每次使用这一对号码组合进行验证都会得到成功的结果。</p>
<p>进入 <a href="/applist.html#/apps">应用控制台</a> &gt; <strong>消息</strong> &gt; <strong>短信</strong> &gt; <strong>设置</strong> &gt; <strong>其他</strong> 来设置 <strong>测试手机号</strong>。</p>
<h4 id="-">单点登录</h4>
<p>如果想实现在当前设备 A 上登录后，强制令之前在其他设备上的登录失效，可以按照以下方案来实现：</p>
<ol>
<li>建立一个设备表，记录用户登录信息和当前设备的信息。</li>
<li>设备 A 登录成功后，更新设备表，将当前设备标记为当前用户登录的最新设备。</li>
<li>设备 B 中的应用启动时，检查设备表，发现最新设备不是当前设备，调用 AVUser 的 <code>logout</code> 方法退出登录。</li>
</ol>
<h4 id="-">当前用户</h4>
<p>打开微博或者微信，它不会每次都要求用户都登录，这是因为它将用户数据缓存在了客户端。
同样，只要是调用了登录相关的接口，LeanCloud SDK 都会自动缓存登录用户的数据。
例如，判断当前用户是否为空，为空就跳转到登录页面让用户登录，如果不为空就跳转到首页：</p>
<pre><code class="lang-java">        AVUser currentUser = AVUser.getCurrentUser();
        if (currentUser != null) {
            // 跳转到首页
        } else {
            //缓存用户对象为空时，可打开用户注册界面…
        }
</code></pre>
<p>如果不调用 <a href="#登出">登出</a> 方法，当前用户的缓存将永久保存在客户端。</p>
<h4 id="sessiontoken">SessionToken</h4>
<p>所有登录接口调用成功之后，云端会返回一个 SessionToken 给客户端，客户端在发送 HTTP 请求的时候，Android SDK 会在 HTTP 请求的 Header 里面自动添加上当前用户的 SessionToken 作为这次请求发起者 <code>AVUser</code> 的身份认证信息。</p>
<p>如果在 <a href="/app.html?appid={{appid}}#/permission">控制台 &gt; 应用设置 &gt; 应用选项</a> 中勾选了 <strong>密码修改后，强制客户端重新登录</strong>，那么当用户密码再次被修改后，已登录的用户对象就会失效，开发者需要使用更改后的密码重新调用登录接口，使 SessionToken 得到更新，否则后续操作会遇到 <a href="error_code.html#_403">403 (Forbidden)</a> 的错误。</p>
<h5 id="-sessiontoken-">验证 SessionToken 是否在有效期内</h5>
<h5 id="-sessiontoken-">使用 SessionToken 登录</h5>
<p>在没有用户名密码的情况下，客户端可以使用 SessionToken 来登录。常见的使用场景有：</p>
<ul>
<li>应用内根据以前缓存的 SessionToken 登录</li>
<li>应用内的某个页面使用 WebView 方式来登录 LeanCloud </li>
<li>在服务端登录后，返回 SessionToken 给客户端，客户端根据返回的 SessionToken 登录。</li>
</ul>
<pre><code class="lang-java">String  sessionToken = AVUser.getCurrentUser().getSessionToken();
AVUser.becomeWithSessionTokenInBackground(sessionToken, new LogInCallback&lt;AVUser&gt;() {
            @Override
            public void done(AVUser user, AVException e) {
                // user.getCurrentUser()
            }
});
</code></pre>
  <div class="callout callout-danger">
  <p>请避免在外部浏览器使用 URL 来传递 SessionToken，以防范信息泄露风险。</p>
</div>





<h4 id="-">账户锁定</h4>
<p>输入错误的密码或验证码会导致用户登录失败。如果在 15 分钟内，同一个用户登录失败的次数大于 6 次，该用户账户即被云端暂时锁定，此时云端会返回错误码 <code>{&quot;code&quot;:1,&quot;error&quot;:&quot;登录失败次数超过限制，请稍候再试，或者通过忘记密码重设密码。&quot;}</code>，开发者可在客户端进行必要提示。</p>
<p>锁定将在最后一次错误登录的 15 分钟之后由云端自动解除，开发者无法通过 SDK 或 REST API 进行干预。在锁定期间，即使用户输入了正确的验证信息也不允许登录。这个限制在 SDK 和云引擎中都有效。</p>
<h3 id="-">重置密码</h3>
<h4 id="-">邮箱重置密码</h4>
<p>我们都知道，应用一旦加入账户密码系统，那么肯定会有用户忘记密码的情况发生。对于这种情况，我们为用户提供了一种安全重置密码的方法。</p>
<p>重置密码的过程很简单，用户只需要输入注册的电子邮件地址即可：</p>
<pre><code class="lang-java">        AVUser.requestPasswordResetInBackground(&quot;myemail@example.com&quot;, new RequestPasswordResetCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {

                } else {
                    e.printStackTrace();
                }
            }
        });
</code></pre>
<p>密码重置流程如下：</p>
<ol>
<li>用户输入注册的电子邮件，请求重置密码；</li>
<li>LeanStorage 向该邮箱发送一封包含重置密码的特殊链接的电子邮件；</li>
<li>用户点击重置密码链接后，一个特殊的页面会打开，让他们输入新密码；</li>
<li>用户的密码已被重置为新输入的密码。</li>
</ol>
<p>关于自定义邮件模板和验证链接，请参考《<a href="https://blog.leancloud.cn/607/">自定义应用内用户重设密码和邮箱验证页面</a>》。</p>
<h4 id="-">手机号码重置密码</h4>
<p>与使用 <a href="#邮箱重置密码">邮箱重置密码</a> 类似，「手机号码重置密码」使用下面的方法来获取短信验证码：</p>
<pre><code class="lang-java">        AVUser.requestPasswordResetBySmsCodeInBackground(&quot;18612340000&quot;, new RequestMobileCodeCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {

                } else {
                    e.printStackTrace();
                }
            }
        });
</code></pre>
<p>注意！用户需要先绑定手机号码，然后使用短信验证码来重置密码：</p>
<pre><code class="lang-java">        AVUser.resetPasswordBySmsCodeInBackground(&quot;123456&quot;, &quot;password&quot;, new UpdatePasswordCallback() {
            @Override
            public void done(AVException e) {
                if (e == null) {

                } else {
                    e.printStackTrace();
                }
            }
        });
</code></pre>
<h4 id="-">登出</h4>
<p>用户登出系统时，SDK 会自动清理缓存信息。</p>
<pre><code class="lang-java">        AVUser.logOut();// 清除缓存用户对象
        AVUser currentUser = AVUser.getCurrentUser();// 现在的 currentUser 是 null 了
</code></pre>
<h3 id="-">用户的查询</h3>
<p>为了安全起见，<strong>新创建的应用的 <code>_User</code> 表默认关闭了 find 权限</strong>，这样每位用户登录后只能查询到自己在 <code>_User</code> 表中的数据，无法查询其他用户的数据。如果需要让其查询其他用户的数据，建议单独创建一张表来保存这类数据，并开放这张表的 find 查询权限。</p>
<p>设置数据表权限的方法，请参考 <a href="data_security.html#Class_级别的_ACL">数据与安全 · Class 级别的权限</a>。我们推荐开发者在 <a href="leanengine_overview.html">云引擎</a> 中封装用户查询，只查询特定条件的用户，避免开放 <code>_User</code> 表的全部查询权限。</p>
<p>查询用户代码如下：</p>
<pre><code class="lang-java">        AVQuery&lt;AVUser&gt; userQuery = new AVQuery&lt;&gt;(&quot;_User&quot;);
</code></pre>
<h3 id="-">浏览器中查看用户表</h3>
<p>用户表是一个特殊的表，专门存储用户对象。在浏览器端，你会看到一个 <code>_User</code> 表。</p>
<h2 id="-">角色</h2>
<p>关于用户与角色的关系，我们有一个更为详尽的文档介绍这部分的内容，并且针对权限管理有深入的讲解，详情请阅读《<a href="acl-guide.html">ACL 权限管理指南</a>》。</p>
<h2 id="-">子类化</h2>
<p>LeanCloud 希望设计成能让人尽快上手并使用。你可以通过 <code>AVObject.get</code> 方法访问所有的数据。但是在很多现有成熟的代码中，子类化能带来更多优点，诸如简洁、可扩展性以及 IDE 提供的代码自动完成的支持等等。子类化不是必须的，你可以将下列代码转化：</p>
<pre><code>        AVObject student = new AVObject(&quot;Student&quot;);
        student.put(&quot;name&quot;, &quot;小明&quot;);
        student.saveInBackground();
</code></pre><p>可改写成:</p>
<pre><code>        Student student = new Student();
        student.put(&quot;name&quot;, &quot;小明&quot;);
        student.saveInBackground();
</code></pre><p>这样代码看起来是不是更简洁呢？</p>
<h3 id="-avobject">子类化 AVObject</h3>
<p>要实现子类化，需要下面几个步骤：</p>
<ol>
<li>首先声明一个子类继承自 <code>AVObject</code>；</li>
<li>添加 <code>@AVClassName</code> 注解。它的值必须是一个字符串，也就是你过去传入 <code>AVObject</code> 构造函数的类名。这样以来，后续就不需要再在代码中出现这个字符串类名；</li>
<li>确保你的子类有一个 public 的默认（参数个数为 0）的构造函数。切记不要在构造函数里修改任何 <code>AVObject</code> 的字段；</li>
<li>在你的应用初始化的地方，在调用 <code>AVOSCloud.initialize()</code> 之前注册子类 <code>AVObject.registerSubclass(YourClass.class)</code>。</li>
</ol>
<p>下面是实现 <code>Student</code> 子类化的例子:</p>
<pre><code class="lang-java">// Student.java
import com.avos.avoscloud.AVClassName;
import com.avos.avoscloud.AVObject;

@AVClassName(&quot;Student&quot;)
public class Student extends AVObject {
}

// App.java
import com.avos.avoscloud.AVOSCloud;
import android.app.Application;

public class App extends Application {
  @Override
  public void onCreate() {
    super.onCreate();

    AVObject.registerSubclass(Student.class);
    AVOSCloud.initialize(this, &quot;...&quot;, &quot;...&quot;);
  }
}
</code></pre>
<h3 id="-">访问器、修改器和方法</h3>
<p>添加方法到 AVObject 的子类有助于封装类的逻辑。你可以将所有跟子类有关的逻辑放到一个地方，而不是分成多个类来分别处理商业逻辑和存储/转换逻辑。</p>
<p>你可以很容易地添加访问器和修改器到你的 AVObject 子类。像平常那样声明字段的<code>getter</code> 和 <code>setter</code> 方法，但是通过 AVObject 的 <code>get</code> 和 <code>put</code> 方法来实现它们。下面是这个例子为 <code>Student</code> 类创建了一个 <code>content</code> 的字段：</p>
<pre><code class="lang-java">// Student.java
@AVClassName(&quot;Student&quot;)
public class Student extends AVObject {
  public String getContent() {
    return getString(&quot;content&quot;);
  }
  public void setContent(String value) {
    put(&quot;content&quot;, value);
  }
}
</code></pre>
<p>现在你就可以使用 <code>student.getContent()</code> 方法来访问 <code>content</code> 字段，并通过 <code>student.setContent(&quot;blah blah blah&quot;)</code> 来修改它。这样就允许你的 IDE 提供代码自动完成功能，并且可以在编译时发现到类型错误。
+</p>
<p>各种数据类型的访问器和修改器都可以这样被定义，使用各种 <code>get()</code> 方法的变种，例如 <code>getInt()</code>，<code>getAVFile()</code> 或者 <code>getMap()</code>。
+</p>
<p>如果你不仅需要一个简单的访问器，而是有更复杂的逻辑，你可以实现自己的方法，例如：</p>
<pre><code class="lang-java">public void takeAccusation() {
  // 处理用户举报，当达到某个条数的时候，自动打上屏蔽标志
  increment(&quot;accusation&quot;, 1);
  if (getAccusation() &gt; 50) {
    setSpam(true);
  }
}
</code></pre>
<h3 id="-">初始化子类</h3>
<p>你可以使用你自定义的构造函数来创建你的子类对象。你的子类必须定义一个公开的默认构造函数，并且不修改任何父类 AVObject 中的字段，这个默认构造函数将会被 SDK 使用来创建子类的强类型的对象。</p>
<p>要创建一个到现有对象的引用，可以使用 <code>AVObject.createWithoutData()</code>:</p>
<pre><code class="lang-java">Student postReference = AVObject.createWithoutData(Student.class, student.getObjectId());
</code></pre>
<h3 id="-">子类的序列化与反序列化</h3>
<p>在 v3.4 版本以后，如果希望 AVObject 子类也支持 Parcelable，则需要至少满足以下几个要求：</p>
<ol>
<li>确保子类有一个 public 并且参数为 Parcel 的构造函数，并且在内部调用父类的该构造函数。</li>
<li>内部需要有一个静态变量 CREATOR 实现 <code>Parcelable.Creator</code>。</li>
</ol>
<pre><code class="lang-java">// Stduent.java
@AVClassName(&quot;Student&quot;)
public class Student extends AVObject {
  public Student(){
    super();
  }

  public Student(Parcel in){
    super(in);
  }
  //此处为我们的默认实现，当然你也可以自行实现
  public static final Creator CREATOR = AVObjectCreator.instance;
}
</code></pre>
<h3 id="-">查询子类</h3>
<p>你可以通过 <code>AVObject.getQuery()</code> 或者 <code>AVQuery.getQuery</code> 的静态方法获取特定的子类的查询对象。下面的例子就查询了用户发表的所有微博列表：</p>
<pre><code class="lang-java">AVQuery&lt;Student&gt; query = AVObject.getQuery(Student.class);
query.whereEqualTo(&quot;pubUser&quot;, AVUser.getCurrentUser().getUsername());
query.findInBackground(new FindCallback&lt;Student&gt;() {
  @Override
  public void done(List&lt;Student&gt; results, AVException e) {
    for (Student a : results) {
      // ...
    }
  }
});
</code></pre>
<h3 id="avuser-">AVUser 的子类化</h3>
<p>AVUser 作为 AVObject 的子类，同样允许子类化，你可以定义自己的 User 对象，不过比起 AVObject 子类化会更简单一些，只要继承 AVUser 就可以了：</p>
<pre><code class="lang-java">import com.avos.avoscloud.AVObject;
import com.avos.avoscloud.AVUser;

@AVClassName(&quot;MyUser&quot;)
public class MyUser extends AVUser {
  public void setNickName(String name) {
    this.put(&quot;nickName&quot;, name);
  }

  public String getNickName() {
    return this.getString(&quot;nickName&quot;);
  }
}
</code></pre>
<p>为了防止 AVUser 子类在序列化与反序列化时丢失数据，需要在调用 AVOSCloud.initialize() 之前注册该子类：</p>
<pre><code class="lang-java">AVUser.registerSubclass(subUser.class);
</code></pre>
<p>当用户子类化 AVUser 后，如果希望以后查询 AVUser 所得到的对象会自动转化为用户子类化的对象，则需要在调用 AVOSCloud.initialize() 之前添加：</p>
<pre><code class="lang-java">AVUser.alwaysUseSubUserClass(subUser.class);
</code></pre>
<p>注册跟普通的 AVUser 对象没有什么不同，但是登录如果希望返回自定义的子类，必须这样：</p>
<pre><code class="lang-java">MyUser cloudUser = AVUser.logIn(username, password, MyUser.class);
</code></pre>
<div class="callout callout-info">由于 fastjson 内部的 bug，请在定义 AVUser 时<u>不要定义</u>跟 AVRelation 相关的 <code>get</code> 方法。如果一定要定义的话，请通过在 Class 上添加 <code>@JSONType(ignores = {&quot;属性名&quot;})</code> 的方式，将其注释为非序列化字段。</div>



<h2 id="-">应用内搜索</h2>
<p>应用内搜索是一个针对应用数据进行全局搜索的接口，它基于搜索引擎构建，提供更强大的搜索功能。要深入了解其用法和阅读示例代码，请阅读 <a href="app_search_guide.html">Android 应用内搜索指南</a>。</p>
<h2 id="-">应用内社交</h2>
<p>应用内社交，又称「事件流」，在应用开发中出现的场景非常多，包括用户间关注（好友）、朋友圈（时间线）、状态、互动（点赞）、私信等常用功能，请参考 <a href="status_system.html#Android_SDK">Android 应用内社交模块</a>。</p>
<h2 id="-">第三方账户登录</h2>
<p>社交账号的登录方便了应用开发者在提升用户体验，我们特地开发了一套支持第三方账号登录的组件，请参考 <a href="sns.html#Android_SNS_组件">Android SNS 开发指南</a>。</p>
<h2 id="-">用户反馈</h2>
<p>用户反馈是一个非常轻量的模块，可以用最少两行的代码来实现一个支持文字和图片的用户反馈系统，并且能够方便的在我们的移动 App 中查看用户的反馈，请参考  <a href="feedback.html#Android_反馈组件">Android 用户反馈指南</a>。</p>
<h2 id="-">常见问题</h2>
<h3 id="-already-has-one-request-sending">错误 already has one request sending</h3>
<p>日志中出现了 <code>com.avos.avoscloud.AVException: already has one request sending</code> 的错误信息，这说明存在对同一个 AVObject 实例对象同时进行了 2 次异步的 save 操作。为防止数据错乱，LeanCloud SDK 对于这种同一数据的并发写入做了限制，所以抛出了这个异常。</p>
<p>需要检查代码，通过打印 log 和断点的方式来定位究竟是由哪一行 save 所引发的。  </p>
<h2 id="-">相关文档</h2>
<ul>
<li><a href="app-sample-restaurant.html">《教程 · 开发餐厅座位预订系统》</a></li>
</ul>


      </div>
    </div>
    <!-- .col-md-9 -->
  </div>
  <!-- .row -->

</div>
<!-- .container-fluid -->
<div id="comment-container" ng-class="{'no-comments': currentComments.length<1}">
  <div class="comment-head">
    {{allComment[version]}}
    <span class="close" ng-click="closeCommentModal()">&times;</span>
  </div>
  <div class="comment-body">
    <div class="comment-list" ng-class="{'no-login': !currentCommentUser.username}">
      <ul>
        <li ng-show="currentComments.length<1">暂无评论</li>
        <li ng-repeat="comment in currentComments">
          <div class="comment-author">{{comment.author}}</div>
          <div class="comment-timestamp">{{ comment.createdAt | date: 'yyyy-MM-dd HH:mm:ss '}}</div>
          <div class="comment-content">{{comment.content}}</div>
        </li>
      </ul>
    </div>
  </div>
  <div class="comment-compose" ng-show="currentCommentUser.username">
    <div class="form-group"> <textarea class="form-control comment-content" ng-model="commentContent"></textarea></div>
    <div class="form-meta">
      <!-- 您已登录为 <b>{{currentCommentUser.username}}</b> -->
      <button class="btn btn-sm btn-default create-comment pull-right" ng-click="createComment($event)">
        <i class="icon icon-chat-bold"></i> 评论
      </button>
    </div>
  </div>
  <div class="comment-compose no-login" ng-show="!currentCommentUser.username">
    您需要 <a class="comment-login" ng-click="loginComment()">授权</a> 后才能评论
  </div>
</div>

<script src="https://download.leancloud.cn/sdk/latest.js"></script>


<script src="custom/js/lib/contents.js"></script>
<script src="custom/js/md.js"></script>


<script type="text/javascript">
ZeroClipboard.setDefaults({
    moviePath: 'custom/js/lib/zeroclipboard/zeroclipboard.swf'
});
$(function(){
    // $('#content [version]').each(function(k,v){
    //     var version = $(v).attr('version');
    //     $(v).append('<div class="toggle-comment" ng-click="showCommentDialog(\''+version+'\''+',$event)">+ <span> {{}}</span> </div>');
    // })

    $('#content [version]').each(function(k,v){
        var version = $(v).attr('version');
        $(v).append('<div class="inline-comment-wrap" version="'+version+'" all-comment="allComment" showDialogMethod="showCommentDialog()" lc-comment> </div>');
    });

    angular.element(document).ready(function() {

      angular.bootstrap(document, ['app']);

    });
});

</script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42629236-7', 'auto');
  ga('send', 'pageview');

</script>





  <footer class="footer" role="contentinfo">
  <div class="container-fluid">
    <!-- <a href="http://leancloud.cn/" class="logo font-logo pull-left">
      LeanCloud
    </a> -->

    <ul class="footer-links pull-right">
      <li class="muted">·</li>
      <li><a href="/pricing">价格</a></li>
      <li class="muted">·</li>
      <li><a href="/docs/sdk_down.html">下载</a></li>
      <!-- <li class="muted">·</li>
      <li><a href="/apps.html" target="_self">App</a></li> -->
      <li class="muted">·</li>
      <li><a href="http://leancloud.cn/docs/faq.html" target="_self">常见问题</a></li>
      <li class="muted">·</li>
      <li><a href="http://leanticket.cn" target="_self"><span class="mobile-hide">技术</span>支持</a></li>
      <!-- <li><a href="http://ticket.leancloud.cn/tickets?token={{user.session_token || 'Gs5Xw4vjyCznrP6OcgMheOWDuatVpbFPiL78eMo6JC0dENB8'}}" target="_blank"><span class="mobile-hide">用户</span>反馈</a></li> -->
      <li class="muted">·</li>
      <li><a href="https://status.leancloud.cn/"><span class="mobile-hide">健康</span>状态</a></li>
      <li class="muted">·</li>
      <li><a href="http://forum.leancloud.cn/">社区</a></li>
      <li class="muted">·</li>
      <li><a href="http://blog.leancloud.cn/">Blog</a></li>
      <li class="muted">·</li>
      <li><a href="https://github.com/leancloud/docs">文档源码</a></li>
    </ul>
  </div>
</footer>



</body>

</html>
